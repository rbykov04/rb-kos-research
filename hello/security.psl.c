/**
 * This file was automatically generated by nk-psl-gen-c.
 * The following copyright applies to the portions of nk-psl-gen-c located in this file:
 * (C) 2024 AO Kaspersky Lab. All Rights Reserved.
 */


#ifdef __KOS_KERNEL__
  extern int printk(const char*, ...);
  #define PSL_PRINT_FN(fmt, ...) printk(fmt, ##__VA_ARGS__)
#else
  #include <stdio.h>
  #define PSL_PRINT_FN(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)
#endif
    
#include "kss/audit.h"
#include "kss/kss.h"
#include "kss/security-gen-api.h"
#include "kss/services.h"
#include "kss/types.h"
#include "kss/utf8.h"
#include "kssaudit/constants.h"
#include "kssaudit/encode.h"
#include "nk/stand.h"
#include "nk/types.h"
#include <qcbor/qcbor_encode.h>
typedef enum kss_audit_profile {
            KSS_AUDIT_NEVER = 0,
            KSS_AUDIT_DENIED = 1,
            KSS_AUDIT_GRANTED = 2,
            KSS_AUDIT_ALWAYS = 3,
        } kss_audit_profile_t;
#include <nk/transport.h>
#include <nk/types.h>
#include <nk/layout.h>
#ifndef __NK_ASSERT___NK_SIZEOF_NK_HANDLE_DESC_T_IS_16
#define __NK_ASSERT___NK_SIZEOF_NK_HANDLE_DESC_T_IS_16
nk_static_assert(__NK_SIZEOF_NK_HANDLE_DESC_T == 16, __NK_ASSERT___NK_SIZEOF_NK_HANDLE_DESC_T_IS_16_FAIL);
#endif
#ifndef __NK_ASSERT___NK_ALIGNOF_NK_HANDLE_DESC_T_IS_8
#define __NK_ASSERT___NK_ALIGNOF_NK_HANDLE_DESC_T_IS_8
nk_static_assert(__NK_ALIGNOF_NK_HANDLE_DESC_T == 8, __NK_ASSERT___NK_ALIGNOF_NK_HANDLE_DESC_T_IS_8_FAIL);
#endif
#ifndef __NK_ASSERT___NK_SIZEOF_NK_PTR_T_IS_8
#define __NK_ASSERT___NK_SIZEOF_NK_PTR_T_IS_8
nk_static_assert(__NK_SIZEOF_NK_PTR_T == 8, __NK_ASSERT___NK_SIZEOF_NK_PTR_T_IS_8_FAIL);
#endif
#ifndef __NK_ASSERT___NK_ALIGNOF_NK_PTR_T_IS_4
#define __NK_ASSERT___NK_ALIGNOF_NK_PTR_T_IS_4
nk_static_assert(__NK_ALIGNOF_NK_PTR_T == 4, __NK_ASSERT___NK_ALIGNOF_NK_PTR_T_IS_4_FAIL);
#endif
#ifndef __NK_ASSERT___NK_SIZEOF_NK_MESSAGE_IS_24
#define __NK_ASSERT___NK_SIZEOF_NK_MESSAGE_IS_24
nk_static_assert(__NK_SIZEOF_NK_MESSAGE == 24, __NK_ASSERT___NK_SIZEOF_NK_MESSAGE_IS_24_FAIL);
#endif
#ifndef __NK_ASSERT___NK_ALIGNOF_NK_MESSAGE_IS_8
#define __NK_ASSERT___NK_ALIGNOF_NK_MESSAGE_IS_8
nk_static_assert(__NK_ALIGNOF_NK_MESSAGE == 8, __NK_ASSERT___NK_ALIGNOF_NK_MESSAGE_IS_8_FAIL);
#endif
#ifndef __NK_ASSERT___NK_MESSAGE_SIZE_MAX_IS_8388607
#define __NK_ASSERT___NK_MESSAGE_SIZE_MAX_IS_8388607
nk_static_assert(__NK_MESSAGE_SIZE_MAX == 8388607, __NK_ASSERT___NK_MESSAGE_SIZE_MAX_IS_8388607_FAIL);
#endif
#ifndef __NK_ASSERT___NK_MESSAGE_HANDLES_MAX_IS_255
#define __NK_ASSERT___NK_MESSAGE_HANDLES_MAX_IS_255
nk_static_assert(__NK_MESSAGE_HANDLES_MAX == 255, __NK_ASSERT___NK_MESSAGE_HANDLES_MAX_IS_255_FAIL);
#endif
#ifndef __NK_ASSERT___NK_IID_MAX_IS_65535
#define __NK_ASSERT___NK_IID_MAX_IS_65535
nk_static_assert(__NK_IID_MAX == 65535, __NK_ASSERT___NK_IID_MAX_IS_65535_FAIL);
#endif
#ifndef __NK_ASSERT___NK_MID_MAX_IS_65535
#define __NK_ASSERT___NK_MID_MAX_IS_65535
nk_static_assert(__NK_MID_MAX == 65535, __NK_ASSERT___NK_MID_MAX_IS_65535_FAIL);
#endif

#ifndef __NK_GEN_CPP_MANGLE
#  ifdef __cplusplus
#    define __NK_GEN_CPP_MANGLE(name) name ## _
#  else
#    define __NK_GEN_CPP_MANGLE(name) name
#  endif
#endif

#ifdef __cplusplus
    extern "C" {
#endif

#ifndef ____nk_ptr_t__NKTYPE__
#define ____nk_ptr_t__NKTYPE__
nk_static_assert(sizeof(nk_ptr_t) == 8, bad_nk_ptr_t_size);
nk_static_assert(nk_alignof(nk_ptr_t) == 4, bad_nk_ptr_t_align);

#endif /* ____nk_ptr_t__NKTYPE__ */

#ifndef ____SInt16__RAWTYPE__
#define ____SInt16__RAWTYPE__
nk_static_assert(sizeof(nk_sint16_t) == 2, bad_nk_sint16_t_size);
nk_static_assert(nk_alignof(nk_sint16_t) == 2, bad_nk_sint16_t_align);

#endif /* ____SInt16__RAWTYPE__ */

#ifndef ____SInt32__RAWTYPE__
#define ____SInt32__RAWTYPE__
nk_static_assert(sizeof(nk_sint32_t) == 4, bad_nk_sint32_t_size);
nk_static_assert(nk_alignof(nk_sint32_t) == 4, bad_nk_sint32_t_align);

#endif /* ____SInt32__RAWTYPE__ */

#ifndef ____SInt64__RAWTYPE__
#define ____SInt64__RAWTYPE__
nk_static_assert(sizeof(nk_sint64_t) == 8, bad_nk_sint64_t_size);
nk_static_assert(nk_alignof(nk_sint64_t) == 8, bad_nk_sint64_t_align);

#endif /* ____SInt64__RAWTYPE__ */

#ifndef ____UInt16__RAWTYPE__
#define ____UInt16__RAWTYPE__
nk_static_assert(sizeof(nk_uint16_t) == 2, bad_nk_uint16_t_size);
nk_static_assert(nk_alignof(nk_uint16_t) == 2, bad_nk_uint16_t_align);

#endif /* ____UInt16__RAWTYPE__ */

#ifndef ____UInt32__RAWTYPE__
#define ____UInt32__RAWTYPE__
nk_static_assert(sizeof(nk_uint32_t) == 4, bad_nk_uint32_t_size);
nk_static_assert(nk_alignof(nk_uint32_t) == 4, bad_nk_uint32_t_align);

#endif /* ____UInt32__RAWTYPE__ */

#ifndef ____UInt64__RAWTYPE__
#define ____UInt64__RAWTYPE__
nk_static_assert(sizeof(nk_uint64_t) == 8, bad_nk_uint64_t_size);
nk_static_assert(nk_alignof(nk_uint64_t) == 8, bad_nk_uint64_t_align);

#endif /* ____UInt64__RAWTYPE__ */

#ifndef ____UInt8__RAWTYPE__
#define ____UInt8__RAWTYPE__
nk_static_assert(sizeof(nk_uint8_t) == 1, bad_nk_uint8_t_size);
nk_static_assert(nk_alignof(nk_uint8_t) == 1, bad_nk_uint8_t_align);

#endif /* ____UInt8__RAWTYPE__ */

#ifndef ____nk_handle_desc_t__NKTYPE__
#define ____nk_handle_desc_t__NKTYPE__
nk_static_assert(sizeof(nk_handle_desc_t) == 16, bad_nk_handle_desc_t_size);
nk_static_assert(nk_alignof(nk_handle_desc_t) == 8, bad_nk_handle_desc_t_align);

#endif /* ____nk_handle_desc_t__NKTYPE__ */

#ifndef __kl_core_Efi__EfiGuid__STRUCT__
#define __kl_core_Efi__EfiGuid__STRUCT__
typedef struct __nk_packed kl_core_Efi_EfiGuid {
            __nk_alignas(4) nk_uint32_t data1;
            __nk_alignas(2) nk_uint16_t data2;
            __nk_alignas(2) nk_uint16_t data3;
            __nk_alignas(1) nk_uint8_t data4[8];
        } kl_core_Efi_EfiGuid;
nk_static_assert(nk_offsetof(kl_core_Efi_EfiGuid, data1) == 0, bad_kl_core_Efi_EfiGuid_data1_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiGuid, data2) == 4, bad_kl_core_Efi_EfiGuid_data2_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiGuid, data3) == 6, bad_kl_core_Efi_EfiGuid_data3_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiGuid, data4) == 8, bad_kl_core_Efi_EfiGuid_data4_offset);
nk_static_assert(sizeof(struct kl_core_Efi_EfiGuid) == 16, bad_kl_core_Efi_EfiGuid_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Efi_EfiGuid kl_core_Efi_EfiGuid
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Efi__EfiGuid__STRUCT__ */

#ifndef __kl_core_Efi__EfiTimeCapabilities__STRUCT__
#define __kl_core_Efi__EfiTimeCapabilities__STRUCT__
typedef struct __nk_packed kl_core_Efi_EfiTimeCapabilities {
            __nk_alignas(4)
            nk_uint32_t Resolution;
            __nk_alignas(4) nk_uint32_t Accuracy;
            __nk_alignas(1) nk_uint8_t SetsToZero;
        } kl_core_Efi_EfiTimeCapabilities;
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTimeCapabilities, Resolution) == 0, bad_kl_core_Efi_EfiTimeCapabilities_Resolution_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTimeCapabilities, Accuracy) == 4, bad_kl_core_Efi_EfiTimeCapabilities_Accuracy_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTimeCapabilities, SetsToZero) == 8, bad_kl_core_Efi_EfiTimeCapabilities_SetsToZero_offset);
nk_static_assert(sizeof(struct kl_core_Efi_EfiTimeCapabilities) == 12, bad_kl_core_Efi_EfiTimeCapabilities_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Efi_EfiTimeCapabilities kl_core_Efi_EfiTimeCapabilities
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Efi__EfiTimeCapabilities__STRUCT__ */

#ifndef __kl_core_Efi__EfiTime__STRUCT__
#define __kl_core_Efi__EfiTime__STRUCT__
typedef struct __nk_packed kl_core_Efi_EfiTime {
            __nk_alignas(2) nk_uint16_t Year;
            __nk_alignas(1) nk_uint8_t Month;
            __nk_alignas(1) nk_uint8_t Day;
            __nk_alignas(1) nk_uint8_t Hour;
            __nk_alignas(1) nk_uint8_t Minute;
            __nk_alignas(1) nk_uint8_t Second;
            __nk_alignas(1) nk_uint8_t Pad1;
            __nk_alignas(4)
            nk_uint32_t Nanosecond;
            __nk_alignas(2) nk_sint16_t TimeZone;
            __nk_alignas(1) nk_uint8_t Daylight;
            __nk_alignas(1) nk_uint8_t Pad2;
        } kl_core_Efi_EfiTime;
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTime, Year) == 0, bad_kl_core_Efi_EfiTime_Year_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTime, Month) == 2, bad_kl_core_Efi_EfiTime_Month_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTime, Day) == 3, bad_kl_core_Efi_EfiTime_Day_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTime, Hour) == 4, bad_kl_core_Efi_EfiTime_Hour_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTime, Minute) == 5, bad_kl_core_Efi_EfiTime_Minute_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTime, Second) == 6, bad_kl_core_Efi_EfiTime_Second_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTime, Pad1) == 7, bad_kl_core_Efi_EfiTime_Pad1_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTime, Nanosecond) == 8, bad_kl_core_Efi_EfiTime_Nanosecond_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTime, TimeZone) == 12, bad_kl_core_Efi_EfiTime_TimeZone_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTime, Daylight) == 14, bad_kl_core_Efi_EfiTime_Daylight_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_EfiTime, Pad2) == 15, bad_kl_core_Efi_EfiTime_Pad2_offset);
nk_static_assert(sizeof(struct kl_core_Efi_EfiTime) == 16, bad_kl_core_Efi_EfiTime_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Efi_EfiTime kl_core_Efi_EfiTime
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Efi__EfiTime__STRUCT__ */

#ifndef __kl_core_IO__DmaFrame__STRUCT__
#define __kl_core_IO__DmaFrame__STRUCT__
typedef struct __nk_packed kl_core_IO_DmaFrame {
            __nk_alignas(8) nk_uint64_t frame;
            __nk_alignas(4) nk_uint32_t order;
        } kl_core_IO_DmaFrame;
nk_static_assert(nk_offsetof(kl_core_IO_DmaFrame, frame) == 0, bad_kl_core_IO_DmaFrame_frame_offset);
nk_static_assert(nk_offsetof(kl_core_IO_DmaFrame, order) == 8, bad_kl_core_IO_DmaFrame_order_offset);
nk_static_assert(sizeof(struct kl_core_IO_DmaFrame) == 16, bad_kl_core_IO_DmaFrame_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define IO_DmaFrame kl_core_IO_DmaFrame
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_IO__DmaFrame__STRUCT__ */

#ifndef __kl_core_Notice__EventDescr__STRUCT__
#define __kl_core_Notice__EventDescr__STRUCT__
typedef struct __nk_packed kl_core_Notice_EventDescr {
            __nk_alignas(8) nk_uint64_t eventId;
            __nk_alignas(4) nk_uint32_t eventMask;
            __nk_alignas(4)
            nk_uint32_t eventCounter;
        } kl_core_Notice_EventDescr;
nk_static_assert(nk_offsetof(kl_core_Notice_EventDescr, eventId) == 0, bad_kl_core_Notice_EventDescr_eventId_offset);
nk_static_assert(nk_offsetof(kl_core_Notice_EventDescr, eventMask) == 8, bad_kl_core_Notice_EventDescr_eventMask_offset);
nk_static_assert(nk_offsetof(kl_core_Notice_EventDescr, eventCounter) == 12, bad_kl_core_Notice_EventDescr_eventCounter_offset);
nk_static_assert(sizeof(struct kl_core_Notice_EventDescr) == 16, bad_kl_core_Notice_EventDescr_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Notice_EventDescr kl_core_Notice_EventDescr
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Notice__EventDescr__STRUCT__ */

#ifndef __kl_core_Profiler__PerfCounterS64__STRUCT__
#define __kl_core_Profiler__PerfCounterS64__STRUCT__
typedef struct __nk_packed kl_core_Profiler_PerfCounterS64 {
            __nk_alignas(8) nk_sint64_t value;
            __nk_alignas(4) nk_uint32_t unit;
        } kl_core_Profiler_PerfCounterS64;
nk_static_assert(nk_offsetof(kl_core_Profiler_PerfCounterS64, value) == 0, bad_kl_core_Profiler_PerfCounterS64_value_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_PerfCounterS64, unit) == 8, bad_kl_core_Profiler_PerfCounterS64_unit_offset);
nk_static_assert(sizeof(struct kl_core_Profiler_PerfCounterS64) == 16, bad_kl_core_Profiler_PerfCounterS64_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Profiler_PerfCounterS64 kl_core_Profiler_PerfCounterS64
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Profiler__PerfCounterS64__STRUCT__ */

#ifndef __kl_core_Profiler__PerfCounterU64__STRUCT__
#define __kl_core_Profiler__PerfCounterU64__STRUCT__
typedef struct __nk_packed kl_core_Profiler_PerfCounterU64 {
            __nk_alignas(8) nk_uint64_t value;
            __nk_alignas(4) nk_uint32_t unit;
        } kl_core_Profiler_PerfCounterU64;
nk_static_assert(nk_offsetof(kl_core_Profiler_PerfCounterU64, value) == 0, bad_kl_core_Profiler_PerfCounterU64_value_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_PerfCounterU64, unit) == 8, bad_kl_core_Profiler_PerfCounterU64_unit_offset);
nk_static_assert(sizeof(struct kl_core_Profiler_PerfCounterU64) == 16, bad_kl_core_Profiler_PerfCounterU64_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Profiler_PerfCounterU64 kl_core_Profiler_PerfCounterU64
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Profiler__PerfCounterU64__STRUCT__ */

#ifndef __kl_core_Task__ExceptionInfo__STRUCT__
#define __kl_core_Task__ExceptionInfo__STRUCT__
typedef struct __nk_packed kl_core_Task_ExceptionInfo {
            __nk_alignas(4) nk_uint32_t type;
            __nk_alignas(4) nk_uint32_t id;
            __nk_alignas(4) nk_ptr_t frame;
        } kl_core_Task_ExceptionInfo;
nk_static_assert(nk_offsetof(kl_core_Task_ExceptionInfo, type) == 0, bad_kl_core_Task_ExceptionInfo_type_offset);
nk_static_assert(nk_offsetof(kl_core_Task_ExceptionInfo, id) == 4, bad_kl_core_Task_ExceptionInfo_id_offset);
nk_static_assert(nk_offsetof(kl_core_Task_ExceptionInfo, frame) == 8, bad_kl_core_Task_ExceptionInfo_frame_offset);
nk_static_assert(sizeof(struct kl_core_Task_ExceptionInfo) == 16, bad_kl_core_Task_ExceptionInfo_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Task_ExceptionInfo kl_core_Task_ExceptionInfo
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Task__ExceptionInfo__STRUCT__ */

#ifndef __kl_core_Task__InitialStateParams__STRUCT__
#define __kl_core_Task__InitialStateParams__STRUCT__
typedef struct __nk_packed kl_core_Task_InitialStateParams {
            __nk_alignas(8) nk_uint64_t entryAddr;
            __nk_alignas(8) nk_uint64_t relocBase;
        } kl_core_Task_InitialStateParams;
nk_static_assert(nk_offsetof(kl_core_Task_InitialStateParams, entryAddr) == 0, bad_kl_core_Task_InitialStateParams_entryAddr_offset);
nk_static_assert(nk_offsetof(kl_core_Task_InitialStateParams, relocBase) == 8, bad_kl_core_Task_InitialStateParams_relocBase_offset);
nk_static_assert(sizeof(struct kl_core_Task_InitialStateParams) == 16, bad_kl_core_Task_InitialStateParams_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Task_InitialStateParams kl_core_Task_InitialStateParams
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Task__InitialStateParams__STRUCT__ */

#ifndef __kl_core_Task__ThreadContext__STRUCT__
#define __kl_core_Task__ThreadContext__STRUCT__
typedef struct __nk_packed kl_core_Task_ThreadContext {
            __nk_alignas(4) nk_uint32_t tid;
            __nk_alignas(4) nk_ptr_t frame;
        } kl_core_Task_ThreadContext;
nk_static_assert(nk_offsetof(kl_core_Task_ThreadContext, tid) == 0, bad_kl_core_Task_ThreadContext_tid_offset);
nk_static_assert(nk_offsetof(kl_core_Task_ThreadContext, frame) == 4, bad_kl_core_Task_ThreadContext_frame_offset);
nk_static_assert(sizeof(struct kl_core_Task_ThreadContext) == 12, bad_kl_core_Task_ThreadContext_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Task_ThreadContext kl_core_Task_ThreadContext
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Task__ThreadContext__STRUCT__ */

#ifndef __kl_core_Task__VmSegAttr__STRUCT__
#define __kl_core_Task__VmSegAttr__STRUCT__
typedef struct __nk_packed kl_core_Task_VmSegAttr {
            __nk_alignas(8) nk_uint64_t loadAddr;
            __nk_alignas(8) nk_uint64_t offset;
            __nk_alignas(8) nk_uint64_t size;
            __nk_alignas(4) nk_uint32_t flags;
        } kl_core_Task_VmSegAttr;
nk_static_assert(nk_offsetof(kl_core_Task_VmSegAttr, loadAddr) == 0, bad_kl_core_Task_VmSegAttr_loadAddr_offset);
nk_static_assert(nk_offsetof(kl_core_Task_VmSegAttr, offset) == 8, bad_kl_core_Task_VmSegAttr_offset_offset);
nk_static_assert(nk_offsetof(kl_core_Task_VmSegAttr, size) == 16, bad_kl_core_Task_VmSegAttr_size_offset);
nk_static_assert(nk_offsetof(kl_core_Task_VmSegAttr, flags) == 24, bad_kl_core_Task_VmSegAttr_flags_offset);
nk_static_assert(sizeof(struct kl_core_Task_VmSegAttr) == 32, bad_kl_core_Task_VmSegAttr_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Task_VmSegAttr kl_core_Task_VmSegAttr
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Task__VmSegAttr__STRUCT__ */

#ifndef __kl_core_Thread__TrThreadInfo__STRUCT__
#define __kl_core_Thread__TrThreadInfo__STRUCT__
typedef struct __nk_packed kl_core_Thread_TrThreadInfo {
            __nk_alignas(8) nk_uint64_t stackSize;
            __nk_alignas(8)
            nk_uint64_t stackStart;
            __nk_alignas(4) nk_uint32_t tid;
        } kl_core_Thread_TrThreadInfo;
nk_static_assert(nk_offsetof(kl_core_Thread_TrThreadInfo, stackSize) == 0, bad_kl_core_Thread_TrThreadInfo_stackSize_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_TrThreadInfo, stackStart) == 8, bad_kl_core_Thread_TrThreadInfo_stackStart_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_TrThreadInfo, tid) == 16, bad_kl_core_Thread_TrThreadInfo_tid_offset);
nk_static_assert(sizeof(struct kl_core_Thread_TrThreadInfo) == 24, bad_kl_core_Thread_TrThreadInfo_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Thread_TrThreadInfo kl_core_Thread_TrThreadInfo
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Thread__TrThreadInfo__STRUCT__ */

#ifndef __kl_core_Types__TimeSpec__STRUCT__
#define __kl_core_Types__TimeSpec__STRUCT__
typedef struct __nk_packed kl_core_Types_TimeSpec {
            __nk_alignas(8) nk_sint64_t sec;
            __nk_alignas(4) nk_uint32_t nsec;
        } kl_core_Types_TimeSpec;
nk_static_assert(nk_offsetof(kl_core_Types_TimeSpec, sec) == 0, bad_kl_core_Types_TimeSpec_sec_offset);
nk_static_assert(nk_offsetof(kl_core_Types_TimeSpec, nsec) == 8, bad_kl_core_Types_TimeSpec_nsec_offset);
nk_static_assert(sizeof(struct kl_core_Types_TimeSpec) == 16, bad_kl_core_Types_TimeSpec_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Types_TimeSpec kl_core_Types_TimeSpec
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Types__TimeSpec__STRUCT__ */

#ifndef __kl_core_Types__TrNoneParam__STRUCT__
#define __kl_core_Types__TrNoneParam__STRUCT__
typedef struct __nk_packed kl_core_Types_TrNoneParam {
            __nk_alignas(4) nk_uint32_t empty;
        } kl_core_Types_TrNoneParam;
nk_static_assert(nk_offsetof(kl_core_Types_TrNoneParam, empty) == 0, bad_kl_core_Types_TrNoneParam_empty_offset);
nk_static_assert(sizeof(struct kl_core_Types_TrNoneParam) == 4, bad_kl_core_Types_TrNoneParam_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Types_TrNoneParam kl_core_Types_TrNoneParam
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Types__TrNoneParam__STRUCT__ */

#ifndef __kl_core_Types__TrRoundRobinParam__STRUCT__
#define __kl_core_Types__TrRoundRobinParam__STRUCT__
typedef struct __nk_packed kl_core_Types_TrRoundRobinParam {
            __nk_alignas(8) nk_uint64_t sec;
            __nk_alignas(4) nk_uint32_t nsec;
        } kl_core_Types_TrRoundRobinParam;
nk_static_assert(nk_offsetof(kl_core_Types_TrRoundRobinParam, sec) == 0, bad_kl_core_Types_TrRoundRobinParam_sec_offset);
nk_static_assert(nk_offsetof(kl_core_Types_TrRoundRobinParam, nsec) == 8, bad_kl_core_Types_TrRoundRobinParam_nsec_offset);
nk_static_assert(sizeof(struct kl_core_Types_TrRoundRobinParam) == 16, bad_kl_core_Types_TrRoundRobinParam_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Types_TrRoundRobinParam kl_core_Types_TrRoundRobinParam
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Types__TrRoundRobinParam__STRUCT__ */

#ifndef __kl_core_Profiler__PerfCounterValue__UNION__
#define __kl_core_Profiler__PerfCounterValue__UNION__
enum {
    kl_core_Profiler_PerfCounterValue_rc_tag,
    kl_core_Profiler_PerfCounterValue_s64_tag,
    kl_core_Profiler_PerfCounterValue_u64_tag,
    kl_core_Profiler_PerfCounterValue_tag_max,
};
typedef struct __nk_packed kl_core_Profiler_PerfCounterValue {
            __nk_alignas(4) nk_uint32_t tag;
            __nk_alignas(8) union {
                                __nk_alignas(4)
                                nk_sint32_t rc;
                                __nk_alignas(8)
                                struct kl_core_Profiler_PerfCounterS64 s64;
                                __nk_alignas(8)
                                struct kl_core_Profiler_PerfCounterU64 u64;
                            } data;
        } kl_core_Profiler_PerfCounterValue;
nk_static_assert(nk_offsetof(kl_core_Profiler_PerfCounterValue, tag) == 0, bad_kl_core_Profiler_PerfCounterValue_tag_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_PerfCounterValue, data) == 8, bad_kl_core_Profiler_PerfCounterValue_data_offset);
nk_static_assert(sizeof(struct kl_core_Profiler_PerfCounterValue) == 24, bad_kl_core_Profiler_PerfCounterValue_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Profiler_PerfCounterValue kl_core_Profiler_PerfCounterValue
#define Profiler_PerfCounterValue_tag_max kl_core_Profiler_PerfCounterValue_tag_max
#define Profiler_PerfCounterValue_rc_tag kl_core_Profiler_PerfCounterValue_rc_tag
#define Profiler_PerfCounterValue_s64_tag kl_core_Profiler_PerfCounterValue_s64_tag
#define Profiler_PerfCounterValue_u64_tag kl_core_Profiler_PerfCounterValue_u64_tag
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Profiler__PerfCounterValue__UNION__ */

#ifndef __kl_core_TaskDebug__HandleInfo__STRUCT__
#define __kl_core_TaskDebug__HandleInfo__STRUCT__
typedef struct __nk_packed kl_core_TaskDebug_HandleInfo {
            __nk_alignas(4) nk_uint32_t type;
            __nk_alignas(4) nk_uint32_t rights;
            __nk_alignas(8)
            struct kl_core_Types_TimeSpec timeStamp;
            __nk_alignas(4) nk_uint32_t objSid;
            __nk_alignas(4) nk_sint32_t objRefs;
            __nk_alignas(4) nk_ptr_t owner;
            __nk_alignas(4) nk_ptr_t traceBuf;
            __nk_alignas(4) nk_ptr_t traceCreator;
        } kl_core_TaskDebug_HandleInfo;
nk_static_assert(nk_offsetof(kl_core_TaskDebug_HandleInfo, type) == 0, bad_kl_core_TaskDebug_HandleInfo_type_offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_HandleInfo, rights) == 4, bad_kl_core_TaskDebug_HandleInfo_rights_offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_HandleInfo, timeStamp) == 8, bad_kl_core_TaskDebug_HandleInfo_timeStamp_offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_HandleInfo, objSid) == 24, bad_kl_core_TaskDebug_HandleInfo_objSid_offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_HandleInfo, objRefs) == 28, bad_kl_core_TaskDebug_HandleInfo_objRefs_offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_HandleInfo, owner) == 32, bad_kl_core_TaskDebug_HandleInfo_owner_offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_HandleInfo, traceBuf) == 40, bad_kl_core_TaskDebug_HandleInfo_traceBuf_offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_HandleInfo, traceCreator) == 48, bad_kl_core_TaskDebug_HandleInfo_traceCreator_offset);
nk_static_assert(sizeof(struct kl_core_TaskDebug_HandleInfo) == 56, bad_kl_core_TaskDebug_HandleInfo_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define TaskDebug_HandleInfo kl_core_TaskDebug_HandleInfo
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_TaskDebug__HandleInfo__STRUCT__ */

#ifndef __kl_core_Task__ExitInfo__UNION__
#define __kl_core_Task__ExitInfo__UNION__
enum {
    kl_core_Task_ExitInfo_code_tag,
    kl_core_Task_ExitInfo_exc_tag,
    kl_core_Task_ExitInfo_tag_max,
};
typedef struct __nk_packed kl_core_Task_ExitInfo {
            __nk_alignas(4) nk_uint32_t tag;
            __nk_alignas(4) union {
                                __nk_alignas(4)
                                nk_uint32_t code;
                                __nk_alignas(4)
                                struct kl_core_Task_ExceptionInfo exc;
                            } data;
        } kl_core_Task_ExitInfo;
nk_static_assert(nk_offsetof(kl_core_Task_ExitInfo, tag) == 0, bad_kl_core_Task_ExitInfo_tag_offset);
nk_static_assert(nk_offsetof(kl_core_Task_ExitInfo, data) == 4, bad_kl_core_Task_ExitInfo_data_offset);
nk_static_assert(sizeof(struct kl_core_Task_ExitInfo) == 20, bad_kl_core_Task_ExitInfo_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Task_ExitInfo kl_core_Task_ExitInfo
#define Task_ExitInfo_tag_max kl_core_Task_ExitInfo_tag_max
#define Task_ExitInfo_code_tag kl_core_Task_ExitInfo_code_tag
#define Task_ExitInfo_exc_tag kl_core_Task_ExitInfo_exc_tag
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Task__ExitInfo__UNION__ */

#ifndef __kl_core_Types__TrSchedParam__UNION__
#define __kl_core_Types__TrSchedParam__UNION__
enum {
    kl_core_Types_TrSchedParam_none_tag,
    kl_core_Types_TrSchedParam_rr_tag,
    kl_core_Types_TrSchedParam_tag_max,
};
typedef struct __nk_packed kl_core_Types_TrSchedParam {
            __nk_alignas(4) nk_uint32_t tag;
            __nk_alignas(8) union {
                                __nk_alignas(4)
                                struct kl_core_Types_TrNoneParam none;
                                __nk_alignas(8)
                                struct kl_core_Types_TrRoundRobinParam rr;
                            } data;
        } kl_core_Types_TrSchedParam;
nk_static_assert(nk_offsetof(kl_core_Types_TrSchedParam, tag) == 0, bad_kl_core_Types_TrSchedParam_tag_offset);
nk_static_assert(nk_offsetof(kl_core_Types_TrSchedParam, data) == 8, bad_kl_core_Types_TrSchedParam_data_offset);
nk_static_assert(sizeof(struct kl_core_Types_TrSchedParam) == 24, bad_kl_core_Types_TrSchedParam_size);
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Types_TrSchedParam kl_core_Types_TrSchedParam
#define Types_TrSchedParam_tag_max kl_core_Types_TrSchedParam_tag_max
#define Types_TrSchedParam_none_tag kl_core_Types_TrSchedParam_none_tag
#define Types_TrSchedParam_rr_tag kl_core_Types_TrSchedParam_rr_tag
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core_Types__TrSchedParam__UNION__ */

#ifndef __kl_core__Audit__INTERFACE__
#define __kl_core__Audit__INTERFACE__
enum {
    kl_core_Audit_Open_mid,
    kl_core_Audit_Close_mid,
    kl_core_Audit_Read_mid,
    kl_core_Audit_mid_max,
};
enum {
    kl_core_Audit_Open_req_name_size = 1024,
    kl_core_Audit_Open_req_arena_size = 1024,
    kl_core_Audit_Open_res_arena_size = 0,
    kl_core_Audit_Open_req_handles = 0,
    kl_core_Audit_Open_res_handles = 1,
    kl_core_Audit_Open_err_handles = 0,
    kl_core_Audit_Close_req_arena_size = 0,
    kl_core_Audit_Close_res_arena_size = 0,
    kl_core_Audit_Close_req_handles = 1,
    kl_core_Audit_Close_res_handles = 0,
    kl_core_Audit_Close_err_handles = 0,
    kl_core_Audit_Read_res_msg_size = 512,
    kl_core_Audit_Read_req_arena_size = 0,
    kl_core_Audit_Read_res_arena_size = 512,
    kl_core_Audit_Read_req_handles = 1,
    kl_core_Audit_Read_res_handles = 0,
    kl_core_Audit_Read_err_handles = 0,
    kl_core_Audit_req_arena_size = 1024,
    kl_core_Audit_res_arena_size = 512,
    kl_core_Audit_req_handles = 1,
    kl_core_Audit_res_handles = 1,
    kl_core_Audit_err_handles = 0,
};
typedef struct __nk_packed kl_core_Audit_Open_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t name;
        } kl_core_Audit_Open_req;
nk_static_assert(sizeof(kl_core_Audit_Open_req) == 32, bad_kl_core_Audit_Open_req_size);
nk_static_assert(nk_offsetof(kl_core_Audit_Open_req, base_) == 0, bad_kl_core_Audit_Open_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Audit_Open_req, name) == 24, bad_kl_core_Audit_Open_req_name_offset);
#pragma pack(push, 8) /* kl_core_Audit_Open_res */
typedef struct kl_core_Audit_Open_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Audit_Open_err;
nk_static_assert(sizeof(kl_core_Audit_Open_err) == 24, bad_kl_core_Audit_Open_err_size);
nk_static_assert(nk_offsetof(kl_core_Audit_Open_err, base_) == 0, bad_kl_core_Audit_Open_err_base__offset);
typedef struct kl_core_Audit_Open_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Audit_Open_err err_;
            };
        } kl_core_Audit_Open_res;
nk_static_assert(sizeof(kl_core_Audit_Open_res) == 48, bad_kl_core_Audit_Open_res_size);
nk_static_assert(nk_offsetof(kl_core_Audit_Open_res, base_) == 0, bad_kl_core_Audit_Open_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Audit_Open_res, handle) == 24, bad_kl_core_Audit_Open_res_handle_offset);
nk_static_assert(nk_offsetof(kl_core_Audit_Open_res, rc) == 40, bad_kl_core_Audit_Open_res_rc_offset);
#pragma pack(pop) /* kl_core_Audit_Open_res */
typedef struct __nk_packed kl_core_Audit_Close_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
        } kl_core_Audit_Close_req;
nk_static_assert(sizeof(kl_core_Audit_Close_req) == 40, bad_kl_core_Audit_Close_req_size);
nk_static_assert(nk_offsetof(kl_core_Audit_Close_req, base_) == 0, bad_kl_core_Audit_Close_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Audit_Close_req, handle) == 24, bad_kl_core_Audit_Close_req_handle_offset);
#pragma pack(push, 8) /* kl_core_Audit_Close_res */
typedef struct kl_core_Audit_Close_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Audit_Close_err;
nk_static_assert(sizeof(kl_core_Audit_Close_err) == 24, bad_kl_core_Audit_Close_err_size);
nk_static_assert(nk_offsetof(kl_core_Audit_Close_err, base_) == 0, bad_kl_core_Audit_Close_err_base__offset);
typedef struct kl_core_Audit_Close_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Audit_Close_err err_;
            };
        } kl_core_Audit_Close_res;
nk_static_assert(sizeof(kl_core_Audit_Close_res) == 32, bad_kl_core_Audit_Close_res_size);
nk_static_assert(nk_offsetof(kl_core_Audit_Close_res, base_) == 0, bad_kl_core_Audit_Close_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Audit_Close_res, rc) == 24, bad_kl_core_Audit_Close_res_rc_offset);
#pragma pack(pop) /* kl_core_Audit_Close_res */
typedef struct __nk_packed kl_core_Audit_Read_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
        } kl_core_Audit_Read_req;
nk_static_assert(sizeof(kl_core_Audit_Read_req) == 40, bad_kl_core_Audit_Read_req_size);
nk_static_assert(nk_offsetof(kl_core_Audit_Read_req, base_) == 0, bad_kl_core_Audit_Read_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Audit_Read_req, handle) == 24, bad_kl_core_Audit_Read_req_handle_offset);
#pragma pack(push, 8) /* kl_core_Audit_Read_res */
typedef struct kl_core_Audit_Read_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Audit_Read_err;
nk_static_assert(sizeof(kl_core_Audit_Read_err) == 24, bad_kl_core_Audit_Read_err_size);
nk_static_assert(nk_offsetof(kl_core_Audit_Read_err, base_) == 0, bad_kl_core_Audit_Read_err_base__offset);
typedef struct kl_core_Audit_Read_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t msg;
                    __nk_alignas(4)
                    nk_uint32_t outDropMsgs;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t msg;
                    __nk_alignas(4)
                    nk_uint32_t outDropMsgs;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Audit_Read_err err_;
            };
        } kl_core_Audit_Read_res;
nk_static_assert(sizeof(kl_core_Audit_Read_res) == 40, bad_kl_core_Audit_Read_res_size);
nk_static_assert(nk_offsetof(kl_core_Audit_Read_res, base_) == 0, bad_kl_core_Audit_Read_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Audit_Read_res, msg) == 24, bad_kl_core_Audit_Read_res_msg_offset);
nk_static_assert(nk_offsetof(kl_core_Audit_Read_res, outDropMsgs) == 32, bad_kl_core_Audit_Read_res_outDropMsgs_offset);
nk_static_assert(nk_offsetof(kl_core_Audit_Read_res, rc) == 36, bad_kl_core_Audit_Read_res_rc_offset);
#pragma pack(pop) /* kl_core_Audit_Read_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Audit_Open_mid kl_core_Audit_Open_mid
#define Audit_Close_mid kl_core_Audit_Close_mid
#define Audit_Read_mid kl_core_Audit_Read_mid
#define Audit_mid_max kl_core_Audit_mid_max
#define Audit_Open_req_name_size kl_core_Audit_Open_req_name_size
#define Audit_Open_req_arena_size kl_core_Audit_Open_req_arena_size
#define Audit_Open_res_arena_size kl_core_Audit_Open_res_arena_size
#define Audit_Open_req_handles kl_core_Audit_Open_req_handles
#define Audit_Open_res_handles kl_core_Audit_Open_res_handles
#define Audit_Open_err_handles kl_core_Audit_Open_err_handles
#define Audit_Close_req_arena_size kl_core_Audit_Close_req_arena_size
#define Audit_Close_res_arena_size kl_core_Audit_Close_res_arena_size
#define Audit_Close_req_handles kl_core_Audit_Close_req_handles
#define Audit_Close_res_handles kl_core_Audit_Close_res_handles
#define Audit_Close_err_handles kl_core_Audit_Close_err_handles
#define Audit_Read_res_msg_size kl_core_Audit_Read_res_msg_size
#define Audit_Read_req_arena_size kl_core_Audit_Read_req_arena_size
#define Audit_Read_res_arena_size kl_core_Audit_Read_res_arena_size
#define Audit_Read_req_handles kl_core_Audit_Read_req_handles
#define Audit_Read_res_handles kl_core_Audit_Read_res_handles
#define Audit_Read_err_handles kl_core_Audit_Read_err_handles
#define Audit_req_arena_size kl_core_Audit_req_arena_size
#define Audit_res_arena_size kl_core_Audit_res_arena_size
#define Audit_req_handles kl_core_Audit_req_handles
#define Audit_res_handles kl_core_Audit_res_handles
#define Audit_err_handles kl_core_Audit_err_handles
#define Audit_Open_req kl_core_Audit_Open_req
#define Audit_Open_res kl_core_Audit_Open_res
#define Audit_Close_req kl_core_Audit_Close_req
#define Audit_Close_res kl_core_Audit_Close_res
#define Audit_Read_req kl_core_Audit_Read_req
#define Audit_Read_res kl_core_Audit_Read_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Audit__INTERFACE__ */

#ifndef __kl_core__CM__INTERFACE__
#define __kl_core__CM__INTERFACE__
enum {
    kl_core_CM_Connect_mid,
    kl_core_CM_Listen_mid,
    kl_core_CM_Drop_mid,
    kl_core_CM_Accept_mid,
    kl_core_CM_mid_max,
};
enum {
    kl_core_CM_Connect_req_server_size = 1024,
    kl_core_CM_Connect_req_service_size = 1024,
    kl_core_CM_Connect_req_arena_size = 2048,
    kl_core_CM_Connect_res_arena_size = 0,
    kl_core_CM_Connect_req_handles = 0,
    kl_core_CM_Connect_res_handles = 1,
    kl_core_CM_Connect_err_handles = 0,
    kl_core_CM_Listen_req_filter_size = 1024,
    kl_core_CM_Listen_res_client_size = 1024,
    kl_core_CM_Listen_res_service_size = 1024,
    kl_core_CM_Listen_req_arena_size = 1024,
    kl_core_CM_Listen_res_arena_size = 2048,
    kl_core_CM_Listen_req_handles = 0,
    kl_core_CM_Listen_res_handles = 0,
    kl_core_CM_Listen_err_handles = 0,
    kl_core_CM_Drop_req_client_size = 1024,
    kl_core_CM_Drop_req_service_size = 1024,
    kl_core_CM_Drop_req_arena_size = 2048,
    kl_core_CM_Drop_res_arena_size = 0,
    kl_core_CM_Drop_req_handles = 0,
    kl_core_CM_Drop_res_handles = 0,
    kl_core_CM_Drop_err_handles = 0,
    kl_core_CM_Accept_req_client_size = 1024,
    kl_core_CM_Accept_req_service_size = 1024,
    kl_core_CM_Accept_req_arena_size = 2048,
    kl_core_CM_Accept_res_arena_size = 0,
    kl_core_CM_Accept_req_handles = 1,
    kl_core_CM_Accept_res_handles = 1,
    kl_core_CM_Accept_err_handles = 0,
    kl_core_CM_req_arena_size = 2048,
    kl_core_CM_res_arena_size = 2048,
    kl_core_CM_req_handles = 1,
    kl_core_CM_res_handles = 1,
    kl_core_CM_err_handles = 0,
};
typedef struct __nk_packed kl_core_CM_Connect_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t server;
            __nk_alignas(4) nk_ptr_t service;
            __nk_alignas(4) nk_uint32_t msecs;
        } kl_core_CM_Connect_req;
nk_static_assert(sizeof(kl_core_CM_Connect_req) == 48, bad_kl_core_CM_Connect_req_size);
nk_static_assert(nk_offsetof(kl_core_CM_Connect_req, base_) == 0, bad_kl_core_CM_Connect_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_CM_Connect_req, server) == 24, bad_kl_core_CM_Connect_req_server_offset);
nk_static_assert(nk_offsetof(kl_core_CM_Connect_req, service) == 32, bad_kl_core_CM_Connect_req_service_offset);
nk_static_assert(nk_offsetof(kl_core_CM_Connect_req, msecs) == 40, bad_kl_core_CM_Connect_req_msecs_offset);
#pragma pack(push, 8) /* kl_core_CM_Connect_res */
typedef struct kl_core_CM_Connect_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_CM_Connect_err;
nk_static_assert(sizeof(kl_core_CM_Connect_err) == 24, bad_kl_core_CM_Connect_err_size);
nk_static_assert(nk_offsetof(kl_core_CM_Connect_err, base_) == 0, bad_kl_core_CM_Connect_err_base__offset);
typedef struct kl_core_CM_Connect_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_uint32_t id;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_uint32_t id;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_CM_Connect_err err_;
            };
        } kl_core_CM_Connect_res;
nk_static_assert(sizeof(kl_core_CM_Connect_res) == 48, bad_kl_core_CM_Connect_res_size);
nk_static_assert(nk_offsetof(kl_core_CM_Connect_res, base_) == 0, bad_kl_core_CM_Connect_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_CM_Connect_res, handle) == 24, bad_kl_core_CM_Connect_res_handle_offset);
nk_static_assert(nk_offsetof(kl_core_CM_Connect_res, id) == 40, bad_kl_core_CM_Connect_res_id_offset);
nk_static_assert(nk_offsetof(kl_core_CM_Connect_res, rc) == 44, bad_kl_core_CM_Connect_res_rc_offset);
#pragma pack(pop) /* kl_core_CM_Connect_res */
typedef struct __nk_packed kl_core_CM_Listen_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t filter;
            __nk_alignas(4) nk_uint32_t msecs;
        } kl_core_CM_Listen_req;
nk_static_assert(sizeof(kl_core_CM_Listen_req) == 40, bad_kl_core_CM_Listen_req_size);
nk_static_assert(nk_offsetof(kl_core_CM_Listen_req, base_) == 0, bad_kl_core_CM_Listen_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_CM_Listen_req, filter) == 24, bad_kl_core_CM_Listen_req_filter_offset);
nk_static_assert(nk_offsetof(kl_core_CM_Listen_req, msecs) == 32, bad_kl_core_CM_Listen_req_msecs_offset);
#pragma pack(push, 8) /* kl_core_CM_Listen_res */
typedef struct kl_core_CM_Listen_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_CM_Listen_err;
nk_static_assert(sizeof(kl_core_CM_Listen_err) == 24, bad_kl_core_CM_Listen_err_size);
nk_static_assert(nk_offsetof(kl_core_CM_Listen_err, base_) == 0, bad_kl_core_CM_Listen_err_base__offset);
typedef struct kl_core_CM_Listen_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_ptr_t client;
                    __nk_alignas(4)
                    nk_ptr_t service;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_ptr_t client;
                    __nk_alignas(4)
                    nk_ptr_t service;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_CM_Listen_err err_;
            };
        } kl_core_CM_Listen_res;
nk_static_assert(sizeof(kl_core_CM_Listen_res) == 48, bad_kl_core_CM_Listen_res_size);
nk_static_assert(nk_offsetof(kl_core_CM_Listen_res, base_) == 0, bad_kl_core_CM_Listen_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_CM_Listen_res, client) == 24, bad_kl_core_CM_Listen_res_client_offset);
nk_static_assert(nk_offsetof(kl_core_CM_Listen_res, service) == 32, bad_kl_core_CM_Listen_res_service_offset);
nk_static_assert(nk_offsetof(kl_core_CM_Listen_res, rc) == 40, bad_kl_core_CM_Listen_res_rc_offset);
#pragma pack(pop) /* kl_core_CM_Listen_res */
typedef struct __nk_packed kl_core_CM_Drop_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t client;
            __nk_alignas(4) nk_ptr_t service;
        } kl_core_CM_Drop_req;
nk_static_assert(sizeof(kl_core_CM_Drop_req) == 40, bad_kl_core_CM_Drop_req_size);
nk_static_assert(nk_offsetof(kl_core_CM_Drop_req, base_) == 0, bad_kl_core_CM_Drop_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_CM_Drop_req, client) == 24, bad_kl_core_CM_Drop_req_client_offset);
nk_static_assert(nk_offsetof(kl_core_CM_Drop_req, service) == 32, bad_kl_core_CM_Drop_req_service_offset);
#pragma pack(push, 8) /* kl_core_CM_Drop_res */
typedef struct kl_core_CM_Drop_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_CM_Drop_err;
nk_static_assert(sizeof(kl_core_CM_Drop_err) == 24, bad_kl_core_CM_Drop_err_size);
nk_static_assert(nk_offsetof(kl_core_CM_Drop_err, base_) == 0, bad_kl_core_CM_Drop_err_base__offset);
typedef struct kl_core_CM_Drop_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_CM_Drop_err err_;
            };
        } kl_core_CM_Drop_res;
nk_static_assert(sizeof(kl_core_CM_Drop_res) == 32, bad_kl_core_CM_Drop_res_size);
nk_static_assert(nk_offsetof(kl_core_CM_Drop_res, base_) == 0, bad_kl_core_CM_Drop_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_CM_Drop_res, rc) == 24, bad_kl_core_CM_Drop_res_rc_offset);
#pragma pack(pop) /* kl_core_CM_Drop_res */
typedef struct __nk_packed kl_core_CM_Accept_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t listener;
            __nk_alignas(4) nk_ptr_t client;
            __nk_alignas(4) nk_ptr_t service;
            __nk_alignas(4) nk_uint32_t id;
        } kl_core_CM_Accept_req;
nk_static_assert(sizeof(kl_core_CM_Accept_req) == 64, bad_kl_core_CM_Accept_req_size);
nk_static_assert(nk_offsetof(kl_core_CM_Accept_req, base_) == 0, bad_kl_core_CM_Accept_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_CM_Accept_req, listener) == 24, bad_kl_core_CM_Accept_req_listener_offset);
nk_static_assert(nk_offsetof(kl_core_CM_Accept_req, client) == 40, bad_kl_core_CM_Accept_req_client_offset);
nk_static_assert(nk_offsetof(kl_core_CM_Accept_req, service) == 48, bad_kl_core_CM_Accept_req_service_offset);
nk_static_assert(nk_offsetof(kl_core_CM_Accept_req, id) == 56, bad_kl_core_CM_Accept_req_id_offset);
#pragma pack(push, 8) /* kl_core_CM_Accept_res */
typedef struct kl_core_CM_Accept_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_CM_Accept_err;
nk_static_assert(sizeof(kl_core_CM_Accept_err) == 24, bad_kl_core_CM_Accept_err_size);
nk_static_assert(nk_offsetof(kl_core_CM_Accept_err, base_) == 0, bad_kl_core_CM_Accept_err_base__offset);
typedef struct kl_core_CM_Accept_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_CM_Accept_err err_;
            };
        } kl_core_CM_Accept_res;
nk_static_assert(sizeof(kl_core_CM_Accept_res) == 48, bad_kl_core_CM_Accept_res_size);
nk_static_assert(nk_offsetof(kl_core_CM_Accept_res, base_) == 0, bad_kl_core_CM_Accept_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_CM_Accept_res, handle) == 24, bad_kl_core_CM_Accept_res_handle_offset);
nk_static_assert(nk_offsetof(kl_core_CM_Accept_res, rc) == 40, bad_kl_core_CM_Accept_res_rc_offset);
#pragma pack(pop) /* kl_core_CM_Accept_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define CM_Connect_mid kl_core_CM_Connect_mid
#define CM_Listen_mid kl_core_CM_Listen_mid
#define CM_Drop_mid kl_core_CM_Drop_mid
#define CM_Accept_mid kl_core_CM_Accept_mid
#define CM_mid_max kl_core_CM_mid_max
#define CM_Connect_req_server_size kl_core_CM_Connect_req_server_size
#define CM_Connect_req_service_size kl_core_CM_Connect_req_service_size
#define CM_Connect_req_arena_size kl_core_CM_Connect_req_arena_size
#define CM_Connect_res_arena_size kl_core_CM_Connect_res_arena_size
#define CM_Connect_req_handles kl_core_CM_Connect_req_handles
#define CM_Connect_res_handles kl_core_CM_Connect_res_handles
#define CM_Connect_err_handles kl_core_CM_Connect_err_handles
#define CM_Listen_req_filter_size kl_core_CM_Listen_req_filter_size
#define CM_Listen_res_client_size kl_core_CM_Listen_res_client_size
#define CM_Listen_res_service_size kl_core_CM_Listen_res_service_size
#define CM_Listen_req_arena_size kl_core_CM_Listen_req_arena_size
#define CM_Listen_res_arena_size kl_core_CM_Listen_res_arena_size
#define CM_Listen_req_handles kl_core_CM_Listen_req_handles
#define CM_Listen_res_handles kl_core_CM_Listen_res_handles
#define CM_Listen_err_handles kl_core_CM_Listen_err_handles
#define CM_Drop_req_client_size kl_core_CM_Drop_req_client_size
#define CM_Drop_req_service_size kl_core_CM_Drop_req_service_size
#define CM_Drop_req_arena_size kl_core_CM_Drop_req_arena_size
#define CM_Drop_res_arena_size kl_core_CM_Drop_res_arena_size
#define CM_Drop_req_handles kl_core_CM_Drop_req_handles
#define CM_Drop_res_handles kl_core_CM_Drop_res_handles
#define CM_Drop_err_handles kl_core_CM_Drop_err_handles
#define CM_Accept_req_client_size kl_core_CM_Accept_req_client_size
#define CM_Accept_req_service_size kl_core_CM_Accept_req_service_size
#define CM_Accept_req_arena_size kl_core_CM_Accept_req_arena_size
#define CM_Accept_res_arena_size kl_core_CM_Accept_res_arena_size
#define CM_Accept_req_handles kl_core_CM_Accept_req_handles
#define CM_Accept_res_handles kl_core_CM_Accept_res_handles
#define CM_Accept_err_handles kl_core_CM_Accept_err_handles
#define CM_req_arena_size kl_core_CM_req_arena_size
#define CM_res_arena_size kl_core_CM_res_arena_size
#define CM_req_handles kl_core_CM_req_handles
#define CM_res_handles kl_core_CM_res_handles
#define CM_err_handles kl_core_CM_err_handles
#define CM_Connect_req kl_core_CM_Connect_req
#define CM_Connect_res kl_core_CM_Connect_res
#define CM_Listen_req kl_core_CM_Listen_req
#define CM_Listen_res kl_core_CM_Listen_res
#define CM_Drop_req kl_core_CM_Drop_req
#define CM_Drop_res kl_core_CM_Drop_res
#define CM_Accept_req kl_core_CM_Accept_req
#define CM_Accept_res kl_core_CM_Accept_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__CM__INTERFACE__ */

#ifndef __kl_core__Efi__INTERFACE__
#define __kl_core__Efi__INTERFACE__
enum {
    kl_core_Efi_GetTime_mid,
    kl_core_Efi_SetTime_mid,
    kl_core_Efi_GetVariable_mid,
    kl_core_Efi_GetNextVariableName_mid,
    kl_core_Efi_SetVariable_mid,
    kl_core_Efi_QueryVariableInfo_mid,
    kl_core_Efi_ResetSystem_mid,
    kl_core_Efi_mid_max,
};
enum {
    kl_core_Efi_GetTime_req_arena_size = 0,
    kl_core_Efi_GetTime_res_arena_size = 0,
    kl_core_Efi_GetTime_req_handles = 0,
    kl_core_Efi_GetTime_res_handles = 0,
    kl_core_Efi_GetTime_err_handles = 0,
    kl_core_Efi_SetTime_req_arena_size = 0,
    kl_core_Efi_SetTime_res_arena_size = 0,
    kl_core_Efi_SetTime_req_handles = 0,
    kl_core_Efi_SetTime_res_handles = 0,
    kl_core_Efi_SetTime_err_handles = 0,
    kl_core_Efi_GetVariable_req_variableName_size =
    1024,
    kl_core_Efi_GetVariable_req_vendorGuid_data4_size =
    8,
    kl_core_Efi_GetVariable_res_data_size = 16384,
    kl_core_Efi_GetVariable_req_arena_size = 2048,
    kl_core_Efi_GetVariable_res_arena_size =
    16384,
    kl_core_Efi_GetVariable_req_handles = 0,
    kl_core_Efi_GetVariable_res_handles = 0,
    kl_core_Efi_GetVariable_err_handles = 0,
    kl_core_Efi_GetNextVariableName_req_variableNamePrev_size =
    1024,
    kl_core_Efi_GetNextVariableName_req_vendorGuidPrev_data4_size =
    8,
    kl_core_Efi_GetNextVariableName_res_variableNameNext_size =
    1024,
    kl_core_Efi_GetNextVariableName_res_vendorGuidNext_data4_size =
    8,
    kl_core_Efi_GetNextVariableName_req_arena_size =
    2048,
    kl_core_Efi_GetNextVariableName_res_arena_size =
    2048,
    kl_core_Efi_GetNextVariableName_req_handles =
    0,
    kl_core_Efi_GetNextVariableName_res_handles =
    0,
    kl_core_Efi_GetNextVariableName_err_handles =
    0,
    kl_core_Efi_SetVariable_req_variableName_size =
    1024,
    kl_core_Efi_SetVariable_req_vendorGuid_data4_size =
    8,
    kl_core_Efi_SetVariable_req_data_size = 16384,
    kl_core_Efi_SetVariable_req_arena_size =
    18432,
    kl_core_Efi_SetVariable_res_arena_size = 0,
    kl_core_Efi_SetVariable_req_handles = 0,
    kl_core_Efi_SetVariable_res_handles = 0,
    kl_core_Efi_SetVariable_err_handles = 0,
    kl_core_Efi_QueryVariableInfo_req_arena_size =
    0,
    kl_core_Efi_QueryVariableInfo_res_arena_size =
    0,
    kl_core_Efi_QueryVariableInfo_req_handles = 0,
    kl_core_Efi_QueryVariableInfo_res_handles = 0,
    kl_core_Efi_QueryVariableInfo_err_handles = 0,
    kl_core_Efi_ResetSystem_req_resetData_size =
    2048,
    kl_core_Efi_ResetSystem_req_arena_size = 2048,
    kl_core_Efi_ResetSystem_res_arena_size = 0,
    kl_core_Efi_ResetSystem_req_handles = 0,
    kl_core_Efi_ResetSystem_res_handles = 0,
    kl_core_Efi_ResetSystem_err_handles = 0,
    kl_core_Efi_req_arena_size = 18432,
    kl_core_Efi_res_arena_size = 16384,
    kl_core_Efi_req_handles = 0,
    kl_core_Efi_res_handles = 0,
    kl_core_Efi_err_handles = 0,
};
typedef struct __nk_packed kl_core_Efi_GetTime_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Efi_GetTime_req;
nk_static_assert(sizeof(kl_core_Efi_GetTime_req) == 24, bad_kl_core_Efi_GetTime_req_size);
nk_static_assert(nk_offsetof(kl_core_Efi_GetTime_req, base_) == 0, bad_kl_core_Efi_GetTime_req_base__offset);
#pragma pack(push, 8) /* kl_core_Efi_GetTime_res */
typedef struct kl_core_Efi_GetTime_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Efi_GetTime_err;
nk_static_assert(sizeof(kl_core_Efi_GetTime_err) == 24, bad_kl_core_Efi_GetTime_err_size);
nk_static_assert(nk_offsetof(kl_core_Efi_GetTime_err, base_) == 0, bad_kl_core_Efi_GetTime_err_base__offset);
typedef struct kl_core_Efi_GetTime_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    struct kl_core_Efi_EfiTime time;
                    __nk_alignas(4)
                    struct kl_core_Efi_EfiTimeCapabilities capabilities;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    struct kl_core_Efi_EfiTime time;
                    __nk_alignas(4)
                    struct kl_core_Efi_EfiTimeCapabilities capabilities;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Efi_GetTime_err err_;
            };
        } kl_core_Efi_GetTime_res;
nk_static_assert(sizeof(kl_core_Efi_GetTime_res) == 56, bad_kl_core_Efi_GetTime_res_size);
nk_static_assert(nk_offsetof(kl_core_Efi_GetTime_res, base_) == 0, bad_kl_core_Efi_GetTime_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetTime_res, time) == 24, bad_kl_core_Efi_GetTime_res_time_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetTime_res, capabilities) == 40, bad_kl_core_Efi_GetTime_res_capabilities_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetTime_res, rc) == 52, bad_kl_core_Efi_GetTime_res_rc_offset);
#pragma pack(pop) /* kl_core_Efi_GetTime_res */
typedef struct __nk_packed kl_core_Efi_SetTime_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4)
            struct kl_core_Efi_EfiTime time;
        } kl_core_Efi_SetTime_req;
nk_static_assert(sizeof(kl_core_Efi_SetTime_req) == 40, bad_kl_core_Efi_SetTime_req_size);
nk_static_assert(nk_offsetof(kl_core_Efi_SetTime_req, base_) == 0, bad_kl_core_Efi_SetTime_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Efi_SetTime_req, time) == 24, bad_kl_core_Efi_SetTime_req_time_offset);
#pragma pack(push, 8) /* kl_core_Efi_SetTime_res */
typedef struct kl_core_Efi_SetTime_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Efi_SetTime_err;
nk_static_assert(sizeof(kl_core_Efi_SetTime_err) == 24, bad_kl_core_Efi_SetTime_err_size);
nk_static_assert(nk_offsetof(kl_core_Efi_SetTime_err, base_) == 0, bad_kl_core_Efi_SetTime_err_base__offset);
typedef struct kl_core_Efi_SetTime_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Efi_SetTime_err err_;
            };
        } kl_core_Efi_SetTime_res;
nk_static_assert(sizeof(kl_core_Efi_SetTime_res) == 32, bad_kl_core_Efi_SetTime_res_size);
nk_static_assert(nk_offsetof(kl_core_Efi_SetTime_res, base_) == 0, bad_kl_core_Efi_SetTime_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Efi_SetTime_res, rc) == 24, bad_kl_core_Efi_SetTime_res_rc_offset);
#pragma pack(pop) /* kl_core_Efi_SetTime_res */
typedef struct __nk_packed kl_core_Efi_GetVariable_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t variableName;
            __nk_alignas(4)
            struct kl_core_Efi_EfiGuid vendorGuid;
        } kl_core_Efi_GetVariable_req;
nk_static_assert(sizeof(kl_core_Efi_GetVariable_req) == 48, bad_kl_core_Efi_GetVariable_req_size);
nk_static_assert(nk_offsetof(kl_core_Efi_GetVariable_req, base_) == 0, bad_kl_core_Efi_GetVariable_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetVariable_req, variableName) == 24, bad_kl_core_Efi_GetVariable_req_variableName_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetVariable_req, vendorGuid) == 32, bad_kl_core_Efi_GetVariable_req_vendorGuid_offset);
#pragma pack(push, 8) /* kl_core_Efi_GetVariable_res */
typedef struct kl_core_Efi_GetVariable_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Efi_GetVariable_err;
nk_static_assert(sizeof(kl_core_Efi_GetVariable_err) == 24, bad_kl_core_Efi_GetVariable_err_size);
nk_static_assert(nk_offsetof(kl_core_Efi_GetVariable_err, base_) == 0, bad_kl_core_Efi_GetVariable_err_base__offset);
typedef struct kl_core_Efi_GetVariable_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t attributes;
                    __nk_alignas(8)
                    nk_uint64_t dataSizeReal;
                    __nk_alignas(4) nk_ptr_t data;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t attributes;
                    __nk_alignas(8)
                    nk_uint64_t dataSizeReal;
                    __nk_alignas(4) nk_ptr_t data;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Efi_GetVariable_err err_;
            };
        } kl_core_Efi_GetVariable_res;
nk_static_assert(sizeof(kl_core_Efi_GetVariable_res) == 56, bad_kl_core_Efi_GetVariable_res_size);
nk_static_assert(nk_offsetof(kl_core_Efi_GetVariable_res, base_) == 0, bad_kl_core_Efi_GetVariable_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetVariable_res, attributes) == 24, bad_kl_core_Efi_GetVariable_res_attributes_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetVariable_res, dataSizeReal) == 32, bad_kl_core_Efi_GetVariable_res_dataSizeReal_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetVariable_res, data) == 40, bad_kl_core_Efi_GetVariable_res_data_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetVariable_res, rc) == 48, bad_kl_core_Efi_GetVariable_res_rc_offset);
#pragma pack(pop) /* kl_core_Efi_GetVariable_res */
typedef struct __nk_packed kl_core_Efi_GetNextVariableName_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4)
            nk_ptr_t variableNamePrev;
            __nk_alignas(4)
            struct kl_core_Efi_EfiGuid vendorGuidPrev;
        } kl_core_Efi_GetNextVariableName_req;
nk_static_assert(sizeof(kl_core_Efi_GetNextVariableName_req) == 48, bad_kl_core_Efi_GetNextVariableName_req_size);
nk_static_assert(nk_offsetof(kl_core_Efi_GetNextVariableName_req, base_) == 0, bad_kl_core_Efi_GetNextVariableName_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetNextVariableName_req, variableNamePrev) == 24, bad_kl_core_Efi_GetNextVariableName_req_variableNamePrev_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetNextVariableName_req, vendorGuidPrev) == 32, bad_kl_core_Efi_GetNextVariableName_req_vendorGuidPrev_offset);
#pragma pack(push, 8) /* kl_core_Efi_GetNextVariableName_res */
typedef struct kl_core_Efi_GetNextVariableName_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Efi_GetNextVariableName_err;
nk_static_assert(sizeof(kl_core_Efi_GetNextVariableName_err) == 24, bad_kl_core_Efi_GetNextVariableName_err_size);
nk_static_assert(nk_offsetof(kl_core_Efi_GetNextVariableName_err, base_) == 0, bad_kl_core_Efi_GetNextVariableName_err_base__offset);
typedef struct kl_core_Efi_GetNextVariableName_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t variableNameSizeReal;
                    __nk_alignas(4)
                    nk_ptr_t variableNameNext;
                    __nk_alignas(4)
                    struct kl_core_Efi_EfiGuid vendorGuidNext;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t variableNameSizeReal;
                    __nk_alignas(4)
                    nk_ptr_t variableNameNext;
                    __nk_alignas(4)
                    struct kl_core_Efi_EfiGuid vendorGuidNext;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Efi_GetNextVariableName_err err_;
            };
        } kl_core_Efi_GetNextVariableName_res;
nk_static_assert(sizeof(kl_core_Efi_GetNextVariableName_res) == 64, bad_kl_core_Efi_GetNextVariableName_res_size);
nk_static_assert(nk_offsetof(kl_core_Efi_GetNextVariableName_res, base_) == 0, bad_kl_core_Efi_GetNextVariableName_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetNextVariableName_res, variableNameSizeReal) == 24, bad_kl_core_Efi_GetNextVariableName_res_variableNameSizeReal_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetNextVariableName_res, variableNameNext) == 32, bad_kl_core_Efi_GetNextVariableName_res_variableNameNext_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetNextVariableName_res, vendorGuidNext) == 40, bad_kl_core_Efi_GetNextVariableName_res_vendorGuidNext_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_GetNextVariableName_res, rc) == 56, bad_kl_core_Efi_GetNextVariableName_res_rc_offset);
#pragma pack(pop) /* kl_core_Efi_GetNextVariableName_res */
typedef struct __nk_packed kl_core_Efi_SetVariable_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t variableName;
            __nk_alignas(4)
            struct kl_core_Efi_EfiGuid vendorGuid;
            __nk_alignas(4)
            nk_uint32_t attributes;
            __nk_alignas(4) nk_ptr_t data;
        } kl_core_Efi_SetVariable_req;
nk_static_assert(sizeof(kl_core_Efi_SetVariable_req) == 64, bad_kl_core_Efi_SetVariable_req_size);
nk_static_assert(nk_offsetof(kl_core_Efi_SetVariable_req, base_) == 0, bad_kl_core_Efi_SetVariable_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Efi_SetVariable_req, variableName) == 24, bad_kl_core_Efi_SetVariable_req_variableName_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_SetVariable_req, vendorGuid) == 32, bad_kl_core_Efi_SetVariable_req_vendorGuid_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_SetVariable_req, attributes) == 48, bad_kl_core_Efi_SetVariable_req_attributes_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_SetVariable_req, data) == 52, bad_kl_core_Efi_SetVariable_req_data_offset);
#pragma pack(push, 8) /* kl_core_Efi_SetVariable_res */
typedef struct kl_core_Efi_SetVariable_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Efi_SetVariable_err;
nk_static_assert(sizeof(kl_core_Efi_SetVariable_err) == 24, bad_kl_core_Efi_SetVariable_err_size);
nk_static_assert(nk_offsetof(kl_core_Efi_SetVariable_err, base_) == 0, bad_kl_core_Efi_SetVariable_err_base__offset);
typedef struct kl_core_Efi_SetVariable_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Efi_SetVariable_err err_;
            };
        } kl_core_Efi_SetVariable_res;
nk_static_assert(sizeof(kl_core_Efi_SetVariable_res) == 32, bad_kl_core_Efi_SetVariable_res_size);
nk_static_assert(nk_offsetof(kl_core_Efi_SetVariable_res, base_) == 0, bad_kl_core_Efi_SetVariable_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Efi_SetVariable_res, rc) == 24, bad_kl_core_Efi_SetVariable_res_rc_offset);
#pragma pack(pop) /* kl_core_Efi_SetVariable_res */
typedef struct __nk_packed kl_core_Efi_QueryVariableInfo_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4)
            nk_uint32_t attributes;
        } kl_core_Efi_QueryVariableInfo_req;
nk_static_assert(sizeof(kl_core_Efi_QueryVariableInfo_req) == 32, bad_kl_core_Efi_QueryVariableInfo_req_size);
nk_static_assert(nk_offsetof(kl_core_Efi_QueryVariableInfo_req, base_) == 0, bad_kl_core_Efi_QueryVariableInfo_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Efi_QueryVariableInfo_req, attributes) == 24, bad_kl_core_Efi_QueryVariableInfo_req_attributes_offset);
#pragma pack(push, 8) /* kl_core_Efi_QueryVariableInfo_res */
typedef struct kl_core_Efi_QueryVariableInfo_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Efi_QueryVariableInfo_err;
nk_static_assert(sizeof(kl_core_Efi_QueryVariableInfo_err) == 24, bad_kl_core_Efi_QueryVariableInfo_err_size);
nk_static_assert(nk_offsetof(kl_core_Efi_QueryVariableInfo_err, base_) == 0, bad_kl_core_Efi_QueryVariableInfo_err_base__offset);
typedef struct kl_core_Efi_QueryVariableInfo_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t maximumVariableStorageSize;
                    __nk_alignas(8)
                    nk_uint64_t remainingVariableStorageSize;
                    __nk_alignas(8)
                    nk_uint64_t maximumVariableSize;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t maximumVariableStorageSize;
                    __nk_alignas(8)
                    nk_uint64_t remainingVariableStorageSize;
                    __nk_alignas(8)
                    nk_uint64_t maximumVariableSize;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Efi_QueryVariableInfo_err err_;
            };
        } kl_core_Efi_QueryVariableInfo_res;
nk_static_assert(sizeof(kl_core_Efi_QueryVariableInfo_res) == 56, bad_kl_core_Efi_QueryVariableInfo_res_size);
nk_static_assert(nk_offsetof(kl_core_Efi_QueryVariableInfo_res, base_) == 0, bad_kl_core_Efi_QueryVariableInfo_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Efi_QueryVariableInfo_res, maximumVariableStorageSize) == 24, bad_kl_core_Efi_QueryVariableInfo_res_maximumVariableStorageSize_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_QueryVariableInfo_res, remainingVariableStorageSize) == 32, bad_kl_core_Efi_QueryVariableInfo_res_remainingVariableStorageSize_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_QueryVariableInfo_res, maximumVariableSize) == 40, bad_kl_core_Efi_QueryVariableInfo_res_maximumVariableSize_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_QueryVariableInfo_res, rc) == 48, bad_kl_core_Efi_QueryVariableInfo_res_rc_offset);
#pragma pack(pop) /* kl_core_Efi_QueryVariableInfo_res */
typedef struct __nk_packed kl_core_Efi_ResetSystem_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_sint32_t resetType;
            __nk_alignas(8)
            nk_uint64_t resetStatus;
            __nk_alignas(4) nk_ptr_t resetData;
        } kl_core_Efi_ResetSystem_req;
nk_static_assert(sizeof(kl_core_Efi_ResetSystem_req) == 48, bad_kl_core_Efi_ResetSystem_req_size);
nk_static_assert(nk_offsetof(kl_core_Efi_ResetSystem_req, base_) == 0, bad_kl_core_Efi_ResetSystem_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Efi_ResetSystem_req, resetType) == 24, bad_kl_core_Efi_ResetSystem_req_resetType_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_ResetSystem_req, resetStatus) == 32, bad_kl_core_Efi_ResetSystem_req_resetStatus_offset);
nk_static_assert(nk_offsetof(kl_core_Efi_ResetSystem_req, resetData) == 40, bad_kl_core_Efi_ResetSystem_req_resetData_offset);
#pragma pack(push, 8) /* kl_core_Efi_ResetSystem_res */
typedef struct kl_core_Efi_ResetSystem_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Efi_ResetSystem_err;
nk_static_assert(sizeof(kl_core_Efi_ResetSystem_err) == 24, bad_kl_core_Efi_ResetSystem_err_size);
nk_static_assert(nk_offsetof(kl_core_Efi_ResetSystem_err, base_) == 0, bad_kl_core_Efi_ResetSystem_err_base__offset);
typedef struct kl_core_Efi_ResetSystem_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Efi_ResetSystem_err err_;
            };
        } kl_core_Efi_ResetSystem_res;
nk_static_assert(sizeof(kl_core_Efi_ResetSystem_res) == 32, bad_kl_core_Efi_ResetSystem_res_size);
nk_static_assert(nk_offsetof(kl_core_Efi_ResetSystem_res, base_) == 0, bad_kl_core_Efi_ResetSystem_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Efi_ResetSystem_res, rc) == 24, bad_kl_core_Efi_ResetSystem_res_rc_offset);
#pragma pack(pop) /* kl_core_Efi_ResetSystem_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Efi_GetTime_mid kl_core_Efi_GetTime_mid
#define Efi_SetTime_mid kl_core_Efi_SetTime_mid
#define Efi_GetVariable_mid kl_core_Efi_GetVariable_mid
#define Efi_GetNextVariableName_mid kl_core_Efi_GetNextVariableName_mid
#define Efi_SetVariable_mid kl_core_Efi_SetVariable_mid
#define Efi_QueryVariableInfo_mid kl_core_Efi_QueryVariableInfo_mid
#define Efi_ResetSystem_mid kl_core_Efi_ResetSystem_mid
#define Efi_mid_max kl_core_Efi_mid_max
#define Efi_GetTime_req_arena_size kl_core_Efi_GetTime_req_arena_size
#define Efi_GetTime_res_arena_size kl_core_Efi_GetTime_res_arena_size
#define Efi_GetTime_req_handles kl_core_Efi_GetTime_req_handles
#define Efi_GetTime_res_handles kl_core_Efi_GetTime_res_handles
#define Efi_GetTime_err_handles kl_core_Efi_GetTime_err_handles
#define Efi_SetTime_req_arena_size kl_core_Efi_SetTime_req_arena_size
#define Efi_SetTime_res_arena_size kl_core_Efi_SetTime_res_arena_size
#define Efi_SetTime_req_handles kl_core_Efi_SetTime_req_handles
#define Efi_SetTime_res_handles kl_core_Efi_SetTime_res_handles
#define Efi_SetTime_err_handles kl_core_Efi_SetTime_err_handles
#define Efi_GetVariable_req_variableName_size kl_core_Efi_GetVariable_req_variableName_size
#define Efi_GetVariable_req_vendorGuid_data4_size kl_core_Efi_GetVariable_req_vendorGuid_data4_size
#define Efi_GetVariable_res_data_size kl_core_Efi_GetVariable_res_data_size
#define Efi_GetVariable_req_arena_size kl_core_Efi_GetVariable_req_arena_size
#define Efi_GetVariable_res_arena_size kl_core_Efi_GetVariable_res_arena_size
#define Efi_GetVariable_req_handles kl_core_Efi_GetVariable_req_handles
#define Efi_GetVariable_res_handles kl_core_Efi_GetVariable_res_handles
#define Efi_GetVariable_err_handles kl_core_Efi_GetVariable_err_handles
#define Efi_GetNextVariableName_req_variableNamePrev_size kl_core_Efi_GetNextVariableName_req_variableNamePrev_size
#define Efi_GetNextVariableName_req_vendorGuidPrev_data4_size kl_core_Efi_GetNextVariableName_req_vendorGuidPrev_data4_size
#define Efi_GetNextVariableName_res_variableNameNext_size kl_core_Efi_GetNextVariableName_res_variableNameNext_size
#define Efi_GetNextVariableName_res_vendorGuidNext_data4_size kl_core_Efi_GetNextVariableName_res_vendorGuidNext_data4_size
#define Efi_GetNextVariableName_req_arena_size kl_core_Efi_GetNextVariableName_req_arena_size
#define Efi_GetNextVariableName_res_arena_size kl_core_Efi_GetNextVariableName_res_arena_size
#define Efi_GetNextVariableName_req_handles kl_core_Efi_GetNextVariableName_req_handles
#define Efi_GetNextVariableName_res_handles kl_core_Efi_GetNextVariableName_res_handles
#define Efi_GetNextVariableName_err_handles kl_core_Efi_GetNextVariableName_err_handles
#define Efi_SetVariable_req_variableName_size kl_core_Efi_SetVariable_req_variableName_size
#define Efi_SetVariable_req_vendorGuid_data4_size kl_core_Efi_SetVariable_req_vendorGuid_data4_size
#define Efi_SetVariable_req_data_size kl_core_Efi_SetVariable_req_data_size
#define Efi_SetVariable_req_arena_size kl_core_Efi_SetVariable_req_arena_size
#define Efi_SetVariable_res_arena_size kl_core_Efi_SetVariable_res_arena_size
#define Efi_SetVariable_req_handles kl_core_Efi_SetVariable_req_handles
#define Efi_SetVariable_res_handles kl_core_Efi_SetVariable_res_handles
#define Efi_SetVariable_err_handles kl_core_Efi_SetVariable_err_handles
#define Efi_QueryVariableInfo_req_arena_size kl_core_Efi_QueryVariableInfo_req_arena_size
#define Efi_QueryVariableInfo_res_arena_size kl_core_Efi_QueryVariableInfo_res_arena_size
#define Efi_QueryVariableInfo_req_handles kl_core_Efi_QueryVariableInfo_req_handles
#define Efi_QueryVariableInfo_res_handles kl_core_Efi_QueryVariableInfo_res_handles
#define Efi_QueryVariableInfo_err_handles kl_core_Efi_QueryVariableInfo_err_handles
#define Efi_ResetSystem_req_resetData_size kl_core_Efi_ResetSystem_req_resetData_size
#define Efi_ResetSystem_req_arena_size kl_core_Efi_ResetSystem_req_arena_size
#define Efi_ResetSystem_res_arena_size kl_core_Efi_ResetSystem_res_arena_size
#define Efi_ResetSystem_req_handles kl_core_Efi_ResetSystem_req_handles
#define Efi_ResetSystem_res_handles kl_core_Efi_ResetSystem_res_handles
#define Efi_ResetSystem_err_handles kl_core_Efi_ResetSystem_err_handles
#define Efi_req_arena_size kl_core_Efi_req_arena_size
#define Efi_res_arena_size kl_core_Efi_res_arena_size
#define Efi_req_handles kl_core_Efi_req_handles
#define Efi_res_handles kl_core_Efi_res_handles
#define Efi_err_handles kl_core_Efi_err_handles
#define Efi_GetTime_req kl_core_Efi_GetTime_req
#define Efi_GetTime_res kl_core_Efi_GetTime_res
#define Efi_SetTime_req kl_core_Efi_SetTime_req
#define Efi_SetTime_res kl_core_Efi_SetTime_res
#define Efi_GetVariable_req kl_core_Efi_GetVariable_req
#define Efi_GetVariable_res kl_core_Efi_GetVariable_res
#define Efi_GetNextVariableName_req kl_core_Efi_GetNextVariableName_req
#define Efi_GetNextVariableName_res kl_core_Efi_GetNextVariableName_res
#define Efi_SetVariable_req kl_core_Efi_SetVariable_req
#define Efi_SetVariable_res kl_core_Efi_SetVariable_res
#define Efi_QueryVariableInfo_req kl_core_Efi_QueryVariableInfo_req
#define Efi_QueryVariableInfo_res kl_core_Efi_QueryVariableInfo_res
#define Efi_ResetSystem_req kl_core_Efi_ResetSystem_req
#define Efi_ResetSystem_res kl_core_Efi_ResetSystem_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Efi__INTERFACE__ */

#ifndef __kl_core__FSUnsafe__INTERFACE__
#define __kl_core__FSUnsafe__INTERFACE__
enum {
    kl_core_FSUnsafe_Change_mid,
    kl_core_FSUnsafe_mid_max,
};
enum {
    kl_core_FSUnsafe_Change_req_arena_size = 0,
    kl_core_FSUnsafe_Change_res_arena_size = 0,
    kl_core_FSUnsafe_Change_req_handles = 0,
    kl_core_FSUnsafe_Change_res_handles = 0,
    kl_core_FSUnsafe_Change_err_handles = 0,
    kl_core_FSUnsafe_req_arena_size = 0,
    kl_core_FSUnsafe_res_arena_size = 0,
    kl_core_FSUnsafe_req_handles = 0,
    kl_core_FSUnsafe_res_handles = 0,
    kl_core_FSUnsafe_err_handles = 0,
};
typedef struct __nk_packed kl_core_FSUnsafe_Change_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t base;
            __nk_alignas(8) nk_uint64_t size;
        } kl_core_FSUnsafe_Change_req;
nk_static_assert(sizeof(kl_core_FSUnsafe_Change_req) == 40, bad_kl_core_FSUnsafe_Change_req_size);
nk_static_assert(nk_offsetof(kl_core_FSUnsafe_Change_req, base_) == 0, bad_kl_core_FSUnsafe_Change_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_FSUnsafe_Change_req, base) == 24, bad_kl_core_FSUnsafe_Change_req_base_offset);
nk_static_assert(nk_offsetof(kl_core_FSUnsafe_Change_req, size) == 32, bad_kl_core_FSUnsafe_Change_req_size_offset);
#pragma pack(push, 8) /* kl_core_FSUnsafe_Change_res */
typedef struct kl_core_FSUnsafe_Change_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_FSUnsafe_Change_err;
nk_static_assert(sizeof(kl_core_FSUnsafe_Change_err) == 24, bad_kl_core_FSUnsafe_Change_err_size);
nk_static_assert(nk_offsetof(kl_core_FSUnsafe_Change_err, base_) == 0, bad_kl_core_FSUnsafe_Change_err_base__offset);
typedef struct kl_core_FSUnsafe_Change_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_FSUnsafe_Change_err err_;
            };
        } kl_core_FSUnsafe_Change_res;
nk_static_assert(sizeof(kl_core_FSUnsafe_Change_res) == 32, bad_kl_core_FSUnsafe_Change_res_size);
nk_static_assert(nk_offsetof(kl_core_FSUnsafe_Change_res, base_) == 0, bad_kl_core_FSUnsafe_Change_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_FSUnsafe_Change_res, rc) == 24, bad_kl_core_FSUnsafe_Change_res_rc_offset);
#pragma pack(pop) /* kl_core_FSUnsafe_Change_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define FSUnsafe_Change_mid kl_core_FSUnsafe_Change_mid
#define FSUnsafe_mid_max kl_core_FSUnsafe_mid_max
#define FSUnsafe_Change_req_arena_size kl_core_FSUnsafe_Change_req_arena_size
#define FSUnsafe_Change_res_arena_size kl_core_FSUnsafe_Change_res_arena_size
#define FSUnsafe_Change_req_handles kl_core_FSUnsafe_Change_req_handles
#define FSUnsafe_Change_res_handles kl_core_FSUnsafe_Change_res_handles
#define FSUnsafe_Change_err_handles kl_core_FSUnsafe_Change_err_handles
#define FSUnsafe_req_arena_size kl_core_FSUnsafe_req_arena_size
#define FSUnsafe_res_arena_size kl_core_FSUnsafe_res_arena_size
#define FSUnsafe_req_handles kl_core_FSUnsafe_req_handles
#define FSUnsafe_res_handles kl_core_FSUnsafe_res_handles
#define FSUnsafe_err_handles kl_core_FSUnsafe_err_handles
#define FSUnsafe_Change_req kl_core_FSUnsafe_Change_req
#define FSUnsafe_Change_res kl_core_FSUnsafe_Change_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__FSUnsafe__INTERFACE__ */

#ifndef __kl_core__FS__INTERFACE__
#define __kl_core__FS__INTERFACE__
enum {
    kl_core_FS_Open_mid,
    kl_core_FS_Close_mid,
    kl_core_FS_Read_mid,
    kl_core_FS_GetSize_mid,
    kl_core_FS_GetId_mid,
    kl_core_FS_Count_mid,
    kl_core_FS_GetInfo_mid,
    kl_core_FS_GetFsSize_mid,
    kl_core_FS_mid_max,
};
enum {
    kl_core_FS_Open_req_name_size = 1024,
    kl_core_FS_Open_req_arena_size = 1024,
    kl_core_FS_Open_res_arena_size = 0,
    kl_core_FS_Open_req_handles = 0,
    kl_core_FS_Open_res_handles = 1,
    kl_core_FS_Open_err_handles = 0,
    kl_core_FS_Close_req_arena_size = 0,
    kl_core_FS_Close_res_arena_size = 0,
    kl_core_FS_Close_req_handles = 1,
    kl_core_FS_Close_res_handles = 0,
    kl_core_FS_Close_err_handles = 0,
    kl_core_FS_Read_res_data_size = 4096,
    kl_core_FS_Read_req_arena_size = 0,
    kl_core_FS_Read_res_arena_size = 4096,
    kl_core_FS_Read_req_handles = 1,
    kl_core_FS_Read_res_handles = 0,
    kl_core_FS_Read_err_handles = 0,
    kl_core_FS_GetSize_req_arena_size = 0,
    kl_core_FS_GetSize_res_arena_size = 0,
    kl_core_FS_GetSize_req_handles = 1,
    kl_core_FS_GetSize_res_handles = 0,
    kl_core_FS_GetSize_err_handles = 0,
    kl_core_FS_GetId_req_arena_size = 0,
    kl_core_FS_GetId_res_arena_size = 0,
    kl_core_FS_GetId_req_handles = 1,
    kl_core_FS_GetId_res_handles = 0,
    kl_core_FS_GetId_err_handles = 0,
    kl_core_FS_Count_req_arena_size = 0,
    kl_core_FS_Count_res_arena_size = 0,
    kl_core_FS_Count_req_handles = 0,
    kl_core_FS_Count_res_handles = 0,
    kl_core_FS_Count_err_handles = 0,
    kl_core_FS_GetInfo_res_name_size = 1024,
    kl_core_FS_GetInfo_req_arena_size = 0,
    kl_core_FS_GetInfo_res_arena_size = 1024,
    kl_core_FS_GetInfo_req_handles = 0,
    kl_core_FS_GetInfo_res_handles = 0,
    kl_core_FS_GetInfo_err_handles = 0,
    kl_core_FS_GetFsSize_req_arena_size = 0,
    kl_core_FS_GetFsSize_res_arena_size = 0,
    kl_core_FS_GetFsSize_req_handles = 0,
    kl_core_FS_GetFsSize_res_handles = 0,
    kl_core_FS_GetFsSize_err_handles = 0,
    kl_core_FS_req_arena_size = 1024,
    kl_core_FS_res_arena_size = 4096,
    kl_core_FS_req_handles = 1,
    kl_core_FS_res_handles = 1,
    kl_core_FS_err_handles = 0,
};
typedef struct __nk_packed kl_core_FS_Open_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t name;
        } kl_core_FS_Open_req;
nk_static_assert(sizeof(kl_core_FS_Open_req) == 32, bad_kl_core_FS_Open_req_size);
nk_static_assert(nk_offsetof(kl_core_FS_Open_req, base_) == 0, bad_kl_core_FS_Open_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_Open_req, name) == 24, bad_kl_core_FS_Open_req_name_offset);
#pragma pack(push, 8) /* kl_core_FS_Open_res */
typedef struct kl_core_FS_Open_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_FS_Open_err;
nk_static_assert(sizeof(kl_core_FS_Open_err) == 24, bad_kl_core_FS_Open_err_size);
nk_static_assert(nk_offsetof(kl_core_FS_Open_err, base_) == 0, bad_kl_core_FS_Open_err_base__offset);
typedef struct kl_core_FS_Open_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_FS_Open_err err_;
            };
        } kl_core_FS_Open_res;
nk_static_assert(sizeof(kl_core_FS_Open_res) == 48, bad_kl_core_FS_Open_res_size);
nk_static_assert(nk_offsetof(kl_core_FS_Open_res, base_) == 0, bad_kl_core_FS_Open_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_Open_res, handle) == 24, bad_kl_core_FS_Open_res_handle_offset);
nk_static_assert(nk_offsetof(kl_core_FS_Open_res, rc) == 40, bad_kl_core_FS_Open_res_rc_offset);
#pragma pack(pop) /* kl_core_FS_Open_res */
typedef struct __nk_packed kl_core_FS_Close_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
        } kl_core_FS_Close_req;
nk_static_assert(sizeof(kl_core_FS_Close_req) == 40, bad_kl_core_FS_Close_req_size);
nk_static_assert(nk_offsetof(kl_core_FS_Close_req, base_) == 0, bad_kl_core_FS_Close_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_Close_req, handle) == 24, bad_kl_core_FS_Close_req_handle_offset);
#pragma pack(push, 8) /* kl_core_FS_Close_res */
typedef struct kl_core_FS_Close_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_FS_Close_err;
nk_static_assert(sizeof(kl_core_FS_Close_err) == 24, bad_kl_core_FS_Close_err_size);
nk_static_assert(nk_offsetof(kl_core_FS_Close_err, base_) == 0, bad_kl_core_FS_Close_err_base__offset);
typedef struct kl_core_FS_Close_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_FS_Close_err err_;
            };
        } kl_core_FS_Close_res;
nk_static_assert(sizeof(kl_core_FS_Close_res) == 32, bad_kl_core_FS_Close_res_size);
nk_static_assert(nk_offsetof(kl_core_FS_Close_res, base_) == 0, bad_kl_core_FS_Close_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_Close_res, rc) == 24, bad_kl_core_FS_Close_res_rc_offset);
#pragma pack(pop) /* kl_core_FS_Close_res */
typedef struct __nk_packed kl_core_FS_Read_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
            __nk_alignas(4)
            nk_uint32_t sectorNumber;
        } kl_core_FS_Read_req;
nk_static_assert(sizeof(kl_core_FS_Read_req) == 48, bad_kl_core_FS_Read_req_size);
nk_static_assert(nk_offsetof(kl_core_FS_Read_req, base_) == 0, bad_kl_core_FS_Read_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_Read_req, handle) == 24, bad_kl_core_FS_Read_req_handle_offset);
nk_static_assert(nk_offsetof(kl_core_FS_Read_req, sectorNumber) == 40, bad_kl_core_FS_Read_req_sectorNumber_offset);
#pragma pack(push, 8) /* kl_core_FS_Read_res */
typedef struct kl_core_FS_Read_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_FS_Read_err;
nk_static_assert(sizeof(kl_core_FS_Read_err) == 24, bad_kl_core_FS_Read_err_size);
nk_static_assert(nk_offsetof(kl_core_FS_Read_err, base_) == 0, bad_kl_core_FS_Read_err_base__offset);
typedef struct kl_core_FS_Read_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t read;
                    __nk_alignas(4) nk_ptr_t data;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t read;
                    __nk_alignas(4) nk_ptr_t data;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_FS_Read_err err_;
            };
        } kl_core_FS_Read_res;
nk_static_assert(sizeof(kl_core_FS_Read_res) == 40, bad_kl_core_FS_Read_res_size);
nk_static_assert(nk_offsetof(kl_core_FS_Read_res, base_) == 0, bad_kl_core_FS_Read_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_Read_res, read) == 24, bad_kl_core_FS_Read_res_read_offset);
nk_static_assert(nk_offsetof(kl_core_FS_Read_res, data) == 28, bad_kl_core_FS_Read_res_data_offset);
nk_static_assert(nk_offsetof(kl_core_FS_Read_res, rc) == 36, bad_kl_core_FS_Read_res_rc_offset);
#pragma pack(pop) /* kl_core_FS_Read_res */
typedef struct __nk_packed kl_core_FS_GetSize_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
        } kl_core_FS_GetSize_req;
nk_static_assert(sizeof(kl_core_FS_GetSize_req) == 40, bad_kl_core_FS_GetSize_req_size);
nk_static_assert(nk_offsetof(kl_core_FS_GetSize_req, base_) == 0, bad_kl_core_FS_GetSize_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_GetSize_req, handle) == 24, bad_kl_core_FS_GetSize_req_handle_offset);
#pragma pack(push, 8) /* kl_core_FS_GetSize_res */
typedef struct kl_core_FS_GetSize_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_FS_GetSize_err;
nk_static_assert(sizeof(kl_core_FS_GetSize_err) == 24, bad_kl_core_FS_GetSize_err_size);
nk_static_assert(nk_offsetof(kl_core_FS_GetSize_err, base_) == 0, bad_kl_core_FS_GetSize_err_base__offset);
typedef struct kl_core_FS_GetSize_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t size;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t size;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_FS_GetSize_err err_;
            };
        } kl_core_FS_GetSize_res;
nk_static_assert(sizeof(kl_core_FS_GetSize_res) == 40, bad_kl_core_FS_GetSize_res_size);
nk_static_assert(nk_offsetof(kl_core_FS_GetSize_res, base_) == 0, bad_kl_core_FS_GetSize_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_GetSize_res, size) == 24, bad_kl_core_FS_GetSize_res_size_offset);
nk_static_assert(nk_offsetof(kl_core_FS_GetSize_res, rc) == 32, bad_kl_core_FS_GetSize_res_rc_offset);
#pragma pack(pop) /* kl_core_FS_GetSize_res */
typedef struct __nk_packed kl_core_FS_GetId_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
        } kl_core_FS_GetId_req;
nk_static_assert(sizeof(kl_core_FS_GetId_req) == 40, bad_kl_core_FS_GetId_req_size);
nk_static_assert(nk_offsetof(kl_core_FS_GetId_req, base_) == 0, bad_kl_core_FS_GetId_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_GetId_req, handle) == 24, bad_kl_core_FS_GetId_req_handle_offset);
#pragma pack(push, 8) /* kl_core_FS_GetId_res */
typedef struct kl_core_FS_GetId_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_FS_GetId_err;
nk_static_assert(sizeof(kl_core_FS_GetId_err) == 24, bad_kl_core_FS_GetId_err_size);
nk_static_assert(nk_offsetof(kl_core_FS_GetId_err, base_) == 0, bad_kl_core_FS_GetId_err_base__offset);
typedef struct kl_core_FS_GetId_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t id;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t id;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_FS_GetId_err err_;
            };
        } kl_core_FS_GetId_res;
nk_static_assert(sizeof(kl_core_FS_GetId_res) == 32, bad_kl_core_FS_GetId_res_size);
nk_static_assert(nk_offsetof(kl_core_FS_GetId_res, base_) == 0, bad_kl_core_FS_GetId_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_GetId_res, id) == 24, bad_kl_core_FS_GetId_res_id_offset);
nk_static_assert(nk_offsetof(kl_core_FS_GetId_res, rc) == 28, bad_kl_core_FS_GetId_res_rc_offset);
#pragma pack(pop) /* kl_core_FS_GetId_res */
typedef struct __nk_packed kl_core_FS_Count_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_FS_Count_req;
nk_static_assert(sizeof(kl_core_FS_Count_req) == 24, bad_kl_core_FS_Count_req_size);
nk_static_assert(nk_offsetof(kl_core_FS_Count_req, base_) == 0, bad_kl_core_FS_Count_req_base__offset);
#pragma pack(push, 8) /* kl_core_FS_Count_res */
typedef struct kl_core_FS_Count_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_FS_Count_err;
nk_static_assert(sizeof(kl_core_FS_Count_err) == 24, bad_kl_core_FS_Count_err_size);
nk_static_assert(nk_offsetof(kl_core_FS_Count_err, base_) == 0, bad_kl_core_FS_Count_err_base__offset);
typedef struct kl_core_FS_Count_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t count;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t count;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_FS_Count_err err_;
            };
        } kl_core_FS_Count_res;
nk_static_assert(sizeof(kl_core_FS_Count_res) == 32, bad_kl_core_FS_Count_res_size);
nk_static_assert(nk_offsetof(kl_core_FS_Count_res, base_) == 0, bad_kl_core_FS_Count_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_Count_res, count) == 24, bad_kl_core_FS_Count_res_count_offset);
nk_static_assert(nk_offsetof(kl_core_FS_Count_res, rc) == 28, bad_kl_core_FS_Count_res_rc_offset);
#pragma pack(pop) /* kl_core_FS_Count_res */
typedef struct __nk_packed kl_core_FS_GetInfo_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t index;
            __nk_alignas(4)
            nk_uint32_t nameLenMax;
        } kl_core_FS_GetInfo_req;
nk_static_assert(sizeof(kl_core_FS_GetInfo_req) == 32, bad_kl_core_FS_GetInfo_req_size);
nk_static_assert(nk_offsetof(kl_core_FS_GetInfo_req, base_) == 0, bad_kl_core_FS_GetInfo_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_GetInfo_req, index) == 24, bad_kl_core_FS_GetInfo_req_index_offset);
nk_static_assert(nk_offsetof(kl_core_FS_GetInfo_req, nameLenMax) == 28, bad_kl_core_FS_GetInfo_req_nameLenMax_offset);
#pragma pack(push, 8) /* kl_core_FS_GetInfo_res */
typedef struct kl_core_FS_GetInfo_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_FS_GetInfo_err;
nk_static_assert(sizeof(kl_core_FS_GetInfo_err) == 24, bad_kl_core_FS_GetInfo_err_size);
nk_static_assert(nk_offsetof(kl_core_FS_GetInfo_err, base_) == 0, bad_kl_core_FS_GetInfo_err_base__offset);
typedef struct kl_core_FS_GetInfo_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t name;
                    __nk_alignas(4)
                    nk_uint32_t id;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t name;
                    __nk_alignas(4)
                    nk_uint32_t id;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_FS_GetInfo_err err_;
            };
        } kl_core_FS_GetInfo_res;
nk_static_assert(sizeof(kl_core_FS_GetInfo_res) == 40, bad_kl_core_FS_GetInfo_res_size);
nk_static_assert(nk_offsetof(kl_core_FS_GetInfo_res, base_) == 0, bad_kl_core_FS_GetInfo_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_GetInfo_res, name) == 24, bad_kl_core_FS_GetInfo_res_name_offset);
nk_static_assert(nk_offsetof(kl_core_FS_GetInfo_res, id) == 32, bad_kl_core_FS_GetInfo_res_id_offset);
nk_static_assert(nk_offsetof(kl_core_FS_GetInfo_res, rc) == 36, bad_kl_core_FS_GetInfo_res_rc_offset);
#pragma pack(pop) /* kl_core_FS_GetInfo_res */
typedef struct __nk_packed kl_core_FS_GetFsSize_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_FS_GetFsSize_req;
nk_static_assert(sizeof(kl_core_FS_GetFsSize_req) == 24, bad_kl_core_FS_GetFsSize_req_size);
nk_static_assert(nk_offsetof(kl_core_FS_GetFsSize_req, base_) == 0, bad_kl_core_FS_GetFsSize_req_base__offset);
#pragma pack(push, 8) /* kl_core_FS_GetFsSize_res */
typedef struct kl_core_FS_GetFsSize_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_FS_GetFsSize_err;
nk_static_assert(sizeof(kl_core_FS_GetFsSize_err) == 24, bad_kl_core_FS_GetFsSize_err_size);
nk_static_assert(nk_offsetof(kl_core_FS_GetFsSize_err, base_) == 0, bad_kl_core_FS_GetFsSize_err_base__offset);
typedef struct kl_core_FS_GetFsSize_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t fsSize;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t fsSize;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_FS_GetFsSize_err err_;
            };
        } kl_core_FS_GetFsSize_res;
nk_static_assert(sizeof(kl_core_FS_GetFsSize_res) == 40, bad_kl_core_FS_GetFsSize_res_size);
nk_static_assert(nk_offsetof(kl_core_FS_GetFsSize_res, base_) == 0, bad_kl_core_FS_GetFsSize_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_FS_GetFsSize_res, fsSize) == 24, bad_kl_core_FS_GetFsSize_res_fsSize_offset);
nk_static_assert(nk_offsetof(kl_core_FS_GetFsSize_res, rc) == 32, bad_kl_core_FS_GetFsSize_res_rc_offset);
#pragma pack(pop) /* kl_core_FS_GetFsSize_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define FS_Open_mid kl_core_FS_Open_mid
#define FS_Close_mid kl_core_FS_Close_mid
#define FS_Read_mid kl_core_FS_Read_mid
#define FS_GetSize_mid kl_core_FS_GetSize_mid
#define FS_GetId_mid kl_core_FS_GetId_mid
#define FS_Count_mid kl_core_FS_Count_mid
#define FS_GetInfo_mid kl_core_FS_GetInfo_mid
#define FS_GetFsSize_mid kl_core_FS_GetFsSize_mid
#define FS_mid_max kl_core_FS_mid_max
#define FS_Open_req_name_size kl_core_FS_Open_req_name_size
#define FS_Open_req_arena_size kl_core_FS_Open_req_arena_size
#define FS_Open_res_arena_size kl_core_FS_Open_res_arena_size
#define FS_Open_req_handles kl_core_FS_Open_req_handles
#define FS_Open_res_handles kl_core_FS_Open_res_handles
#define FS_Open_err_handles kl_core_FS_Open_err_handles
#define FS_Close_req_arena_size kl_core_FS_Close_req_arena_size
#define FS_Close_res_arena_size kl_core_FS_Close_res_arena_size
#define FS_Close_req_handles kl_core_FS_Close_req_handles
#define FS_Close_res_handles kl_core_FS_Close_res_handles
#define FS_Close_err_handles kl_core_FS_Close_err_handles
#define FS_Read_res_data_size kl_core_FS_Read_res_data_size
#define FS_Read_req_arena_size kl_core_FS_Read_req_arena_size
#define FS_Read_res_arena_size kl_core_FS_Read_res_arena_size
#define FS_Read_req_handles kl_core_FS_Read_req_handles
#define FS_Read_res_handles kl_core_FS_Read_res_handles
#define FS_Read_err_handles kl_core_FS_Read_err_handles
#define FS_GetSize_req_arena_size kl_core_FS_GetSize_req_arena_size
#define FS_GetSize_res_arena_size kl_core_FS_GetSize_res_arena_size
#define FS_GetSize_req_handles kl_core_FS_GetSize_req_handles
#define FS_GetSize_res_handles kl_core_FS_GetSize_res_handles
#define FS_GetSize_err_handles kl_core_FS_GetSize_err_handles
#define FS_GetId_req_arena_size kl_core_FS_GetId_req_arena_size
#define FS_GetId_res_arena_size kl_core_FS_GetId_res_arena_size
#define FS_GetId_req_handles kl_core_FS_GetId_req_handles
#define FS_GetId_res_handles kl_core_FS_GetId_res_handles
#define FS_GetId_err_handles kl_core_FS_GetId_err_handles
#define FS_Count_req_arena_size kl_core_FS_Count_req_arena_size
#define FS_Count_res_arena_size kl_core_FS_Count_res_arena_size
#define FS_Count_req_handles kl_core_FS_Count_req_handles
#define FS_Count_res_handles kl_core_FS_Count_res_handles
#define FS_Count_err_handles kl_core_FS_Count_err_handles
#define FS_GetInfo_res_name_size kl_core_FS_GetInfo_res_name_size
#define FS_GetInfo_req_arena_size kl_core_FS_GetInfo_req_arena_size
#define FS_GetInfo_res_arena_size kl_core_FS_GetInfo_res_arena_size
#define FS_GetInfo_req_handles kl_core_FS_GetInfo_req_handles
#define FS_GetInfo_res_handles kl_core_FS_GetInfo_res_handles
#define FS_GetInfo_err_handles kl_core_FS_GetInfo_err_handles
#define FS_GetFsSize_req_arena_size kl_core_FS_GetFsSize_req_arena_size
#define FS_GetFsSize_res_arena_size kl_core_FS_GetFsSize_res_arena_size
#define FS_GetFsSize_req_handles kl_core_FS_GetFsSize_req_handles
#define FS_GetFsSize_res_handles kl_core_FS_GetFsSize_res_handles
#define FS_GetFsSize_err_handles kl_core_FS_GetFsSize_err_handles
#define FS_req_arena_size kl_core_FS_req_arena_size
#define FS_res_arena_size kl_core_FS_res_arena_size
#define FS_req_handles kl_core_FS_req_handles
#define FS_res_handles kl_core_FS_res_handles
#define FS_err_handles kl_core_FS_err_handles
#define FS_Open_req kl_core_FS_Open_req
#define FS_Open_res kl_core_FS_Open_res
#define FS_Close_req kl_core_FS_Close_req
#define FS_Close_res kl_core_FS_Close_res
#define FS_Read_req kl_core_FS_Read_req
#define FS_Read_res kl_core_FS_Read_res
#define FS_GetSize_req kl_core_FS_GetSize_req
#define FS_GetSize_res kl_core_FS_GetSize_res
#define FS_GetId_req kl_core_FS_GetId_req
#define FS_GetId_res kl_core_FS_GetId_res
#define FS_Count_req kl_core_FS_Count_req
#define FS_Count_res kl_core_FS_Count_res
#define FS_GetInfo_req kl_core_FS_GetInfo_req
#define FS_GetInfo_res kl_core_FS_GetInfo_res
#define FS_GetFsSize_req kl_core_FS_GetFsSize_req
#define FS_GetFsSize_res kl_core_FS_GetFsSize_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__FS__INTERFACE__ */

#ifndef __kl_core__HAL__INTERFACE__
#define __kl_core__HAL__INTERFACE__
enum {
    kl_core_HAL_GetEnv_mid,
    kl_core_HAL_GetPrivReg_mid,
    kl_core_HAL_SetPrivReg_mid,
    kl_core_HAL_GetPrivRegRange_mid,
    kl_core_HAL_SetPrivRegRange_mid,
    kl_core_HAL_FlushCache_mid,
    kl_core_HAL_DebugWrite_mid,
    kl_core_HAL_GetEntropy_mid,
    kl_core_HAL_mid_max,
};
enum {
    kl_core_HAL_GetEnv_req_name_size = 1024,
    kl_core_HAL_GetEnv_res_value_size = 1024,
    kl_core_HAL_GetEnv_req_arena_size = 1024,
    kl_core_HAL_GetEnv_res_arena_size = 1024,
    kl_core_HAL_GetEnv_req_handles = 0,
    kl_core_HAL_GetEnv_res_handles = 0,
    kl_core_HAL_GetEnv_err_handles = 0,
    kl_core_HAL_GetPrivReg_req_reg_size = 1024,
    kl_core_HAL_GetPrivReg_req_arena_size = 1024,
    kl_core_HAL_GetPrivReg_res_arena_size = 0,
    kl_core_HAL_GetPrivReg_req_handles = 0,
    kl_core_HAL_GetPrivReg_res_handles = 0,
    kl_core_HAL_GetPrivReg_err_handles = 0,
    kl_core_HAL_SetPrivReg_req_reg_size = 1024,
    kl_core_HAL_SetPrivReg_req_arena_size = 1024,
    kl_core_HAL_SetPrivReg_res_arena_size = 0,
    kl_core_HAL_SetPrivReg_req_handles = 0,
    kl_core_HAL_SetPrivReg_res_handles = 0,
    kl_core_HAL_SetPrivReg_err_handles = 0,
    kl_core_HAL_GetPrivRegRange_req_regRange_size =
    1024,
    kl_core_HAL_GetPrivRegRange_req_arena_size =
    1024,
    kl_core_HAL_GetPrivRegRange_res_arena_size =
    0,
    kl_core_HAL_GetPrivRegRange_req_handles = 0,
    kl_core_HAL_GetPrivRegRange_res_handles = 0,
    kl_core_HAL_GetPrivRegRange_err_handles = 0,
    kl_core_HAL_SetPrivRegRange_req_regRange_size =
    1024,
    kl_core_HAL_SetPrivRegRange_req_arena_size =
    1024,
    kl_core_HAL_SetPrivRegRange_res_arena_size =
    0,
    kl_core_HAL_SetPrivRegRange_req_handles = 0,
    kl_core_HAL_SetPrivRegRange_res_handles = 0,
    kl_core_HAL_SetPrivRegRange_err_handles = 0,
    kl_core_HAL_FlushCache_req_arena_size = 0,
    kl_core_HAL_FlushCache_res_arena_size = 0,
    kl_core_HAL_FlushCache_req_handles = 0,
    kl_core_HAL_FlushCache_res_handles = 0,
    kl_core_HAL_FlushCache_err_handles = 0,
    kl_core_HAL_DebugWrite_req_data_size = 1024,
    kl_core_HAL_DebugWrite_req_arena_size = 1024,
    kl_core_HAL_DebugWrite_res_arena_size = 0,
    kl_core_HAL_DebugWrite_req_handles = 0,
    kl_core_HAL_DebugWrite_res_handles = 0,
    kl_core_HAL_DebugWrite_err_handles = 0,
    kl_core_HAL_GetEntropy_res_buffer_size = 32,
    kl_core_HAL_GetEntropy_req_arena_size = 0,
    kl_core_HAL_GetEntropy_res_arena_size = 32,
    kl_core_HAL_GetEntropy_req_handles = 0,
    kl_core_HAL_GetEntropy_res_handles = 0,
    kl_core_HAL_GetEntropy_err_handles = 0,
    kl_core_HAL_req_arena_size = 1024,
    kl_core_HAL_res_arena_size = 1024,
    kl_core_HAL_req_handles = 0,
    kl_core_HAL_res_handles = 0,
    kl_core_HAL_err_handles = 0,
};
typedef struct __nk_packed kl_core_HAL_GetEnv_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t name;
        } kl_core_HAL_GetEnv_req;
nk_static_assert(sizeof(kl_core_HAL_GetEnv_req) == 32, bad_kl_core_HAL_GetEnv_req_size);
nk_static_assert(nk_offsetof(kl_core_HAL_GetEnv_req, base_) == 0, bad_kl_core_HAL_GetEnv_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_GetEnv_req, name) == 24, bad_kl_core_HAL_GetEnv_req_name_offset);
#pragma pack(push, 8) /* kl_core_HAL_GetEnv_res */
typedef struct kl_core_HAL_GetEnv_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_HAL_GetEnv_err;
nk_static_assert(sizeof(kl_core_HAL_GetEnv_err) == 24, bad_kl_core_HAL_GetEnv_err_size);
nk_static_assert(nk_offsetof(kl_core_HAL_GetEnv_err, base_) == 0, bad_kl_core_HAL_GetEnv_err_base__offset);
typedef struct kl_core_HAL_GetEnv_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_ptr_t value;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_ptr_t value;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_HAL_GetEnv_err err_;
            };
        } kl_core_HAL_GetEnv_res;
nk_static_assert(sizeof(kl_core_HAL_GetEnv_res) == 40, bad_kl_core_HAL_GetEnv_res_size);
nk_static_assert(nk_offsetof(kl_core_HAL_GetEnv_res, base_) == 0, bad_kl_core_HAL_GetEnv_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_GetEnv_res, value) == 24, bad_kl_core_HAL_GetEnv_res_value_offset);
nk_static_assert(nk_offsetof(kl_core_HAL_GetEnv_res, rc) == 32, bad_kl_core_HAL_GetEnv_res_rc_offset);
#pragma pack(pop) /* kl_core_HAL_GetEnv_res */
typedef struct __nk_packed kl_core_HAL_GetPrivReg_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t reg;
        } kl_core_HAL_GetPrivReg_req;
nk_static_assert(sizeof(kl_core_HAL_GetPrivReg_req) == 32, bad_kl_core_HAL_GetPrivReg_req_size);
nk_static_assert(nk_offsetof(kl_core_HAL_GetPrivReg_req, base_) == 0, bad_kl_core_HAL_GetPrivReg_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_GetPrivReg_req, reg) == 24, bad_kl_core_HAL_GetPrivReg_req_reg_offset);
#pragma pack(push, 8) /* kl_core_HAL_GetPrivReg_res */
typedef struct kl_core_HAL_GetPrivReg_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_HAL_GetPrivReg_err;
nk_static_assert(sizeof(kl_core_HAL_GetPrivReg_err) == 24, bad_kl_core_HAL_GetPrivReg_err_size);
nk_static_assert(nk_offsetof(kl_core_HAL_GetPrivReg_err, base_) == 0, bad_kl_core_HAL_GetPrivReg_err_base__offset);
typedef struct kl_core_HAL_GetPrivReg_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t val;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t val;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_HAL_GetPrivReg_err err_;
            };
        } kl_core_HAL_GetPrivReg_res;
nk_static_assert(sizeof(kl_core_HAL_GetPrivReg_res) == 32, bad_kl_core_HAL_GetPrivReg_res_size);
nk_static_assert(nk_offsetof(kl_core_HAL_GetPrivReg_res, base_) == 0, bad_kl_core_HAL_GetPrivReg_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_GetPrivReg_res, val) == 24, bad_kl_core_HAL_GetPrivReg_res_val_offset);
nk_static_assert(nk_offsetof(kl_core_HAL_GetPrivReg_res, rc) == 28, bad_kl_core_HAL_GetPrivReg_res_rc_offset);
#pragma pack(pop) /* kl_core_HAL_GetPrivReg_res */
typedef struct __nk_packed kl_core_HAL_SetPrivReg_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t reg;
            __nk_alignas(4) nk_uint32_t val;
        } kl_core_HAL_SetPrivReg_req;
nk_static_assert(sizeof(kl_core_HAL_SetPrivReg_req) == 40, bad_kl_core_HAL_SetPrivReg_req_size);
nk_static_assert(nk_offsetof(kl_core_HAL_SetPrivReg_req, base_) == 0, bad_kl_core_HAL_SetPrivReg_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_SetPrivReg_req, reg) == 24, bad_kl_core_HAL_SetPrivReg_req_reg_offset);
nk_static_assert(nk_offsetof(kl_core_HAL_SetPrivReg_req, val) == 32, bad_kl_core_HAL_SetPrivReg_req_val_offset);
#pragma pack(push, 8) /* kl_core_HAL_SetPrivReg_res */
typedef struct kl_core_HAL_SetPrivReg_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_HAL_SetPrivReg_err;
nk_static_assert(sizeof(kl_core_HAL_SetPrivReg_err) == 24, bad_kl_core_HAL_SetPrivReg_err_size);
nk_static_assert(nk_offsetof(kl_core_HAL_SetPrivReg_err, base_) == 0, bad_kl_core_HAL_SetPrivReg_err_base__offset);
typedef struct kl_core_HAL_SetPrivReg_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_HAL_SetPrivReg_err err_;
            };
        } kl_core_HAL_SetPrivReg_res;
nk_static_assert(sizeof(kl_core_HAL_SetPrivReg_res) == 32, bad_kl_core_HAL_SetPrivReg_res_size);
nk_static_assert(nk_offsetof(kl_core_HAL_SetPrivReg_res, base_) == 0, bad_kl_core_HAL_SetPrivReg_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_SetPrivReg_res, rc) == 24, bad_kl_core_HAL_SetPrivReg_res_rc_offset);
#pragma pack(pop) /* kl_core_HAL_SetPrivReg_res */
typedef struct __nk_packed kl_core_HAL_GetPrivRegRange_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t regRange;
            __nk_alignas(8) nk_uint64_t offset;
        } kl_core_HAL_GetPrivRegRange_req;
nk_static_assert(sizeof(kl_core_HAL_GetPrivRegRange_req) == 40, bad_kl_core_HAL_GetPrivRegRange_req_size);
nk_static_assert(nk_offsetof(kl_core_HAL_GetPrivRegRange_req, base_) == 0, bad_kl_core_HAL_GetPrivRegRange_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_GetPrivRegRange_req, regRange) == 24, bad_kl_core_HAL_GetPrivRegRange_req_regRange_offset);
nk_static_assert(nk_offsetof(kl_core_HAL_GetPrivRegRange_req, offset) == 32, bad_kl_core_HAL_GetPrivRegRange_req_offset_offset);
#pragma pack(push, 8) /* kl_core_HAL_GetPrivRegRange_res */
typedef struct kl_core_HAL_GetPrivRegRange_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_HAL_GetPrivRegRange_err;
nk_static_assert(sizeof(kl_core_HAL_GetPrivRegRange_err) == 24, bad_kl_core_HAL_GetPrivRegRange_err_size);
nk_static_assert(nk_offsetof(kl_core_HAL_GetPrivRegRange_err, base_) == 0, bad_kl_core_HAL_GetPrivRegRange_err_base__offset);
typedef struct kl_core_HAL_GetPrivRegRange_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t val;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t val;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_HAL_GetPrivRegRange_err err_;
            };
        } kl_core_HAL_GetPrivRegRange_res;
nk_static_assert(sizeof(kl_core_HAL_GetPrivRegRange_res) == 32, bad_kl_core_HAL_GetPrivRegRange_res_size);
nk_static_assert(nk_offsetof(kl_core_HAL_GetPrivRegRange_res, base_) == 0, bad_kl_core_HAL_GetPrivRegRange_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_GetPrivRegRange_res, val) == 24, bad_kl_core_HAL_GetPrivRegRange_res_val_offset);
nk_static_assert(nk_offsetof(kl_core_HAL_GetPrivRegRange_res, rc) == 28, bad_kl_core_HAL_GetPrivRegRange_res_rc_offset);
#pragma pack(pop) /* kl_core_HAL_GetPrivRegRange_res */
typedef struct __nk_packed kl_core_HAL_SetPrivRegRange_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t regRange;
            __nk_alignas(8) nk_uint64_t offset;
            __nk_alignas(4) nk_uint32_t val;
        } kl_core_HAL_SetPrivRegRange_req;
nk_static_assert(sizeof(kl_core_HAL_SetPrivRegRange_req) == 48, bad_kl_core_HAL_SetPrivRegRange_req_size);
nk_static_assert(nk_offsetof(kl_core_HAL_SetPrivRegRange_req, base_) == 0, bad_kl_core_HAL_SetPrivRegRange_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_SetPrivRegRange_req, regRange) == 24, bad_kl_core_HAL_SetPrivRegRange_req_regRange_offset);
nk_static_assert(nk_offsetof(kl_core_HAL_SetPrivRegRange_req, offset) == 32, bad_kl_core_HAL_SetPrivRegRange_req_offset_offset);
nk_static_assert(nk_offsetof(kl_core_HAL_SetPrivRegRange_req, val) == 40, bad_kl_core_HAL_SetPrivRegRange_req_val_offset);
#pragma pack(push, 8) /* kl_core_HAL_SetPrivRegRange_res */
typedef struct kl_core_HAL_SetPrivRegRange_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_HAL_SetPrivRegRange_err;
nk_static_assert(sizeof(kl_core_HAL_SetPrivRegRange_err) == 24, bad_kl_core_HAL_SetPrivRegRange_err_size);
nk_static_assert(nk_offsetof(kl_core_HAL_SetPrivRegRange_err, base_) == 0, bad_kl_core_HAL_SetPrivRegRange_err_base__offset);
typedef struct kl_core_HAL_SetPrivRegRange_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_HAL_SetPrivRegRange_err err_;
            };
        } kl_core_HAL_SetPrivRegRange_res;
nk_static_assert(sizeof(kl_core_HAL_SetPrivRegRange_res) == 32, bad_kl_core_HAL_SetPrivRegRange_res_size);
nk_static_assert(nk_offsetof(kl_core_HAL_SetPrivRegRange_res, base_) == 0, bad_kl_core_HAL_SetPrivRegRange_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_SetPrivRegRange_res, rc) == 24, bad_kl_core_HAL_SetPrivRegRange_res_rc_offset);
#pragma pack(pop) /* kl_core_HAL_SetPrivRegRange_res */
typedef struct __nk_packed kl_core_HAL_FlushCache_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t type;
            __nk_alignas(8) nk_uint64_t va;
            __nk_alignas(8) nk_uint64_t size;
        } kl_core_HAL_FlushCache_req;
nk_static_assert(sizeof(kl_core_HAL_FlushCache_req) == 48, bad_kl_core_HAL_FlushCache_req_size);
nk_static_assert(nk_offsetof(kl_core_HAL_FlushCache_req, base_) == 0, bad_kl_core_HAL_FlushCache_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_FlushCache_req, type) == 24, bad_kl_core_HAL_FlushCache_req_type_offset);
nk_static_assert(nk_offsetof(kl_core_HAL_FlushCache_req, va) == 32, bad_kl_core_HAL_FlushCache_req_va_offset);
nk_static_assert(nk_offsetof(kl_core_HAL_FlushCache_req, size) == 40, bad_kl_core_HAL_FlushCache_req_size_offset);
#pragma pack(push, 8) /* kl_core_HAL_FlushCache_res */
typedef struct kl_core_HAL_FlushCache_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_HAL_FlushCache_err;
nk_static_assert(sizeof(kl_core_HAL_FlushCache_err) == 24, bad_kl_core_HAL_FlushCache_err_size);
nk_static_assert(nk_offsetof(kl_core_HAL_FlushCache_err, base_) == 0, bad_kl_core_HAL_FlushCache_err_base__offset);
typedef struct kl_core_HAL_FlushCache_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_HAL_FlushCache_err err_;
            };
        } kl_core_HAL_FlushCache_res;
nk_static_assert(sizeof(kl_core_HAL_FlushCache_res) == 32, bad_kl_core_HAL_FlushCache_res_size);
nk_static_assert(nk_offsetof(kl_core_HAL_FlushCache_res, base_) == 0, bad_kl_core_HAL_FlushCache_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_FlushCache_res, rc) == 24, bad_kl_core_HAL_FlushCache_res_rc_offset);
#pragma pack(pop) /* kl_core_HAL_FlushCache_res */
typedef struct __nk_packed kl_core_HAL_DebugWrite_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t data;
        } kl_core_HAL_DebugWrite_req;
nk_static_assert(sizeof(kl_core_HAL_DebugWrite_req) == 32, bad_kl_core_HAL_DebugWrite_req_size);
nk_static_assert(nk_offsetof(kl_core_HAL_DebugWrite_req, base_) == 0, bad_kl_core_HAL_DebugWrite_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_DebugWrite_req, data) == 24, bad_kl_core_HAL_DebugWrite_req_data_offset);
#pragma pack(push, 8) /* kl_core_HAL_DebugWrite_res */
typedef struct kl_core_HAL_DebugWrite_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_HAL_DebugWrite_err;
nk_static_assert(sizeof(kl_core_HAL_DebugWrite_err) == 24, bad_kl_core_HAL_DebugWrite_err_size);
nk_static_assert(nk_offsetof(kl_core_HAL_DebugWrite_err, base_) == 0, bad_kl_core_HAL_DebugWrite_err_base__offset);
typedef struct kl_core_HAL_DebugWrite_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_HAL_DebugWrite_err err_;
            };
        } kl_core_HAL_DebugWrite_res;
nk_static_assert(sizeof(kl_core_HAL_DebugWrite_res) == 32, bad_kl_core_HAL_DebugWrite_res_size);
nk_static_assert(nk_offsetof(kl_core_HAL_DebugWrite_res, base_) == 0, bad_kl_core_HAL_DebugWrite_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_DebugWrite_res, rc) == 24, bad_kl_core_HAL_DebugWrite_res_rc_offset);
#pragma pack(pop) /* kl_core_HAL_DebugWrite_res */
typedef struct __nk_packed kl_core_HAL_GetEntropy_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t size;
        } kl_core_HAL_GetEntropy_req;
nk_static_assert(sizeof(kl_core_HAL_GetEntropy_req) == 32, bad_kl_core_HAL_GetEntropy_req_size);
nk_static_assert(nk_offsetof(kl_core_HAL_GetEntropy_req, base_) == 0, bad_kl_core_HAL_GetEntropy_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_GetEntropy_req, size) == 24, bad_kl_core_HAL_GetEntropy_req_size_offset);
#pragma pack(push, 8) /* kl_core_HAL_GetEntropy_res */
typedef struct kl_core_HAL_GetEntropy_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_HAL_GetEntropy_err;
nk_static_assert(sizeof(kl_core_HAL_GetEntropy_err) == 24, bad_kl_core_HAL_GetEntropy_err_size);
nk_static_assert(nk_offsetof(kl_core_HAL_GetEntropy_err, base_) == 0, bad_kl_core_HAL_GetEntropy_err_base__offset);
typedef struct kl_core_HAL_GetEntropy_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_ptr_t buffer;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_ptr_t buffer;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_HAL_GetEntropy_err err_;
            };
        } kl_core_HAL_GetEntropy_res;
nk_static_assert(sizeof(kl_core_HAL_GetEntropy_res) == 40, bad_kl_core_HAL_GetEntropy_res_size);
nk_static_assert(nk_offsetof(kl_core_HAL_GetEntropy_res, base_) == 0, bad_kl_core_HAL_GetEntropy_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_HAL_GetEntropy_res, buffer) == 24, bad_kl_core_HAL_GetEntropy_res_buffer_offset);
nk_static_assert(nk_offsetof(kl_core_HAL_GetEntropy_res, rc) == 32, bad_kl_core_HAL_GetEntropy_res_rc_offset);
#pragma pack(pop) /* kl_core_HAL_GetEntropy_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define HAL_GetEnv_mid kl_core_HAL_GetEnv_mid
#define HAL_GetPrivReg_mid kl_core_HAL_GetPrivReg_mid
#define HAL_SetPrivReg_mid kl_core_HAL_SetPrivReg_mid
#define HAL_GetPrivRegRange_mid kl_core_HAL_GetPrivRegRange_mid
#define HAL_SetPrivRegRange_mid kl_core_HAL_SetPrivRegRange_mid
#define HAL_FlushCache_mid kl_core_HAL_FlushCache_mid
#define HAL_DebugWrite_mid kl_core_HAL_DebugWrite_mid
#define HAL_GetEntropy_mid kl_core_HAL_GetEntropy_mid
#define HAL_mid_max kl_core_HAL_mid_max
#define HAL_GetEnv_req_name_size kl_core_HAL_GetEnv_req_name_size
#define HAL_GetEnv_res_value_size kl_core_HAL_GetEnv_res_value_size
#define HAL_GetEnv_req_arena_size kl_core_HAL_GetEnv_req_arena_size
#define HAL_GetEnv_res_arena_size kl_core_HAL_GetEnv_res_arena_size
#define HAL_GetEnv_req_handles kl_core_HAL_GetEnv_req_handles
#define HAL_GetEnv_res_handles kl_core_HAL_GetEnv_res_handles
#define HAL_GetEnv_err_handles kl_core_HAL_GetEnv_err_handles
#define HAL_GetPrivReg_req_reg_size kl_core_HAL_GetPrivReg_req_reg_size
#define HAL_GetPrivReg_req_arena_size kl_core_HAL_GetPrivReg_req_arena_size
#define HAL_GetPrivReg_res_arena_size kl_core_HAL_GetPrivReg_res_arena_size
#define HAL_GetPrivReg_req_handles kl_core_HAL_GetPrivReg_req_handles
#define HAL_GetPrivReg_res_handles kl_core_HAL_GetPrivReg_res_handles
#define HAL_GetPrivReg_err_handles kl_core_HAL_GetPrivReg_err_handles
#define HAL_SetPrivReg_req_reg_size kl_core_HAL_SetPrivReg_req_reg_size
#define HAL_SetPrivReg_req_arena_size kl_core_HAL_SetPrivReg_req_arena_size
#define HAL_SetPrivReg_res_arena_size kl_core_HAL_SetPrivReg_res_arena_size
#define HAL_SetPrivReg_req_handles kl_core_HAL_SetPrivReg_req_handles
#define HAL_SetPrivReg_res_handles kl_core_HAL_SetPrivReg_res_handles
#define HAL_SetPrivReg_err_handles kl_core_HAL_SetPrivReg_err_handles
#define HAL_GetPrivRegRange_req_regRange_size kl_core_HAL_GetPrivRegRange_req_regRange_size
#define HAL_GetPrivRegRange_req_arena_size kl_core_HAL_GetPrivRegRange_req_arena_size
#define HAL_GetPrivRegRange_res_arena_size kl_core_HAL_GetPrivRegRange_res_arena_size
#define HAL_GetPrivRegRange_req_handles kl_core_HAL_GetPrivRegRange_req_handles
#define HAL_GetPrivRegRange_res_handles kl_core_HAL_GetPrivRegRange_res_handles
#define HAL_GetPrivRegRange_err_handles kl_core_HAL_GetPrivRegRange_err_handles
#define HAL_SetPrivRegRange_req_regRange_size kl_core_HAL_SetPrivRegRange_req_regRange_size
#define HAL_SetPrivRegRange_req_arena_size kl_core_HAL_SetPrivRegRange_req_arena_size
#define HAL_SetPrivRegRange_res_arena_size kl_core_HAL_SetPrivRegRange_res_arena_size
#define HAL_SetPrivRegRange_req_handles kl_core_HAL_SetPrivRegRange_req_handles
#define HAL_SetPrivRegRange_res_handles kl_core_HAL_SetPrivRegRange_res_handles
#define HAL_SetPrivRegRange_err_handles kl_core_HAL_SetPrivRegRange_err_handles
#define HAL_FlushCache_req_arena_size kl_core_HAL_FlushCache_req_arena_size
#define HAL_FlushCache_res_arena_size kl_core_HAL_FlushCache_res_arena_size
#define HAL_FlushCache_req_handles kl_core_HAL_FlushCache_req_handles
#define HAL_FlushCache_res_handles kl_core_HAL_FlushCache_res_handles
#define HAL_FlushCache_err_handles kl_core_HAL_FlushCache_err_handles
#define HAL_DebugWrite_req_data_size kl_core_HAL_DebugWrite_req_data_size
#define HAL_DebugWrite_req_arena_size kl_core_HAL_DebugWrite_req_arena_size
#define HAL_DebugWrite_res_arena_size kl_core_HAL_DebugWrite_res_arena_size
#define HAL_DebugWrite_req_handles kl_core_HAL_DebugWrite_req_handles
#define HAL_DebugWrite_res_handles kl_core_HAL_DebugWrite_res_handles
#define HAL_DebugWrite_err_handles kl_core_HAL_DebugWrite_err_handles
#define HAL_GetEntropy_res_buffer_size kl_core_HAL_GetEntropy_res_buffer_size
#define HAL_GetEntropy_req_arena_size kl_core_HAL_GetEntropy_req_arena_size
#define HAL_GetEntropy_res_arena_size kl_core_HAL_GetEntropy_res_arena_size
#define HAL_GetEntropy_req_handles kl_core_HAL_GetEntropy_req_handles
#define HAL_GetEntropy_res_handles kl_core_HAL_GetEntropy_res_handles
#define HAL_GetEntropy_err_handles kl_core_HAL_GetEntropy_err_handles
#define HAL_req_arena_size kl_core_HAL_req_arena_size
#define HAL_res_arena_size kl_core_HAL_res_arena_size
#define HAL_req_handles kl_core_HAL_req_handles
#define HAL_res_handles kl_core_HAL_res_handles
#define HAL_err_handles kl_core_HAL_err_handles
#define HAL_GetEnv_req kl_core_HAL_GetEnv_req
#define HAL_GetEnv_res kl_core_HAL_GetEnv_res
#define HAL_GetPrivReg_req kl_core_HAL_GetPrivReg_req
#define HAL_GetPrivReg_res kl_core_HAL_GetPrivReg_res
#define HAL_SetPrivReg_req kl_core_HAL_SetPrivReg_req
#define HAL_SetPrivReg_res kl_core_HAL_SetPrivReg_res
#define HAL_GetPrivRegRange_req kl_core_HAL_GetPrivRegRange_req
#define HAL_GetPrivRegRange_res kl_core_HAL_GetPrivRegRange_res
#define HAL_SetPrivRegRange_req kl_core_HAL_SetPrivRegRange_req
#define HAL_SetPrivRegRange_res kl_core_HAL_SetPrivRegRange_res
#define HAL_FlushCache_req kl_core_HAL_FlushCache_req
#define HAL_FlushCache_res kl_core_HAL_FlushCache_res
#define HAL_DebugWrite_req kl_core_HAL_DebugWrite_req
#define HAL_DebugWrite_res kl_core_HAL_DebugWrite_res
#define HAL_GetEntropy_req kl_core_HAL_GetEntropy_req
#define HAL_GetEntropy_res kl_core_HAL_GetEntropy_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__HAL__INTERFACE__ */

#ifndef __kl_core__Handle__INTERFACE__
#define __kl_core__Handle__INTERFACE__
enum {
    kl_core_Handle_Alloc_mid,
    kl_core_Handle_Free_mid,
    kl_core_Handle_Copy_mid,
    kl_core_Handle_Init_mid,
    kl_core_Handle_Fini_mid,
    kl_core_Handle_CreateUserObject_mid,
    kl_core_Handle_Close_mid,
    kl_core_Handle_Connect_mid,
    kl_core_Handle_Disconnect_mid,
    kl_core_Handle_SecurityConnect_mid,
    kl_core_Handle_UidAlloc_mid,
    kl_core_Handle_UidFree_mid,
    kl_core_Handle_GetSidByHandle_mid,
    kl_core_Handle_Revoke_mid,
    kl_core_Handle_RevokeSubtree_mid,
    kl_core_Handle_CreateBadge_mid,
    kl_core_Handle_mid_max,
};
enum {
    kl_core_Handle_Alloc_req_arena_size = 0,
    kl_core_Handle_Alloc_res_arena_size = 0,
    kl_core_Handle_Alloc_req_handles = 0,
    kl_core_Handle_Alloc_res_handles = 1,
    kl_core_Handle_Alloc_err_handles = 0,
    kl_core_Handle_Free_req_arena_size = 0,
    kl_core_Handle_Free_res_arena_size = 0,
    kl_core_Handle_Free_req_handles = 1,
    kl_core_Handle_Free_res_handles = 0,
    kl_core_Handle_Free_err_handles = 0,
    kl_core_Handle_Copy_req_arena_size = 0,
    kl_core_Handle_Copy_res_arena_size = 0,
    kl_core_Handle_Copy_req_handles = 2,
    kl_core_Handle_Copy_res_handles = 1,
    kl_core_Handle_Copy_err_handles = 0,
    kl_core_Handle_Init_req_arena_size = 0,
    kl_core_Handle_Init_res_arena_size = 0,
    kl_core_Handle_Init_req_handles = 1,
    kl_core_Handle_Init_res_handles = 0,
    kl_core_Handle_Init_err_handles = 0,
    kl_core_Handle_Fini_req_arena_size = 0,
    kl_core_Handle_Fini_res_arena_size = 0,
    kl_core_Handle_Fini_req_handles = 1,
    kl_core_Handle_Fini_res_handles = 0,
    kl_core_Handle_Fini_err_handles = 0,
    kl_core_Handle_CreateUserObject_req_arena_size =
    0,
    kl_core_Handle_CreateUserObject_res_arena_size =
    0,
    kl_core_Handle_CreateUserObject_req_handles =
    1,
    kl_core_Handle_CreateUserObject_res_handles =
    1,
    kl_core_Handle_CreateUserObject_err_handles =
    0,
    kl_core_Handle_Close_req_arena_size = 0,
    kl_core_Handle_Close_res_arena_size = 0,
    kl_core_Handle_Close_req_handles = 1,
    kl_core_Handle_Close_res_handles = 0,
    kl_core_Handle_Close_err_handles = 0,
    kl_core_Handle_Connect_req_arena_size = 0,
    kl_core_Handle_Connect_res_arena_size = 0,
    kl_core_Handle_Connect_req_handles = 2,
    kl_core_Handle_Connect_res_handles = 0,
    kl_core_Handle_Connect_err_handles = 0,
    kl_core_Handle_Disconnect_req_arena_size = 0,
    kl_core_Handle_Disconnect_res_arena_size = 0,
    kl_core_Handle_Disconnect_req_handles = 1,
    kl_core_Handle_Disconnect_res_handles = 0,
    kl_core_Handle_Disconnect_err_handles = 0,
    kl_core_Handle_SecurityConnect_req_arena_size =
    0,
    kl_core_Handle_SecurityConnect_res_arena_size =
    0,
    kl_core_Handle_SecurityConnect_req_handles =
    0,
    kl_core_Handle_SecurityConnect_res_handles =
    1,
    kl_core_Handle_SecurityConnect_err_handles =
    0,
    kl_core_Handle_UidAlloc_req_arena_size = 0,
    kl_core_Handle_UidAlloc_res_arena_size = 0,
    kl_core_Handle_UidAlloc_req_handles = 0,
    kl_core_Handle_UidAlloc_res_handles = 0,
    kl_core_Handle_UidAlloc_err_handles = 0,
    kl_core_Handle_UidFree_req_arena_size = 0,
    kl_core_Handle_UidFree_res_arena_size = 0,
    kl_core_Handle_UidFree_req_handles = 0,
    kl_core_Handle_UidFree_res_handles = 0,
    kl_core_Handle_UidFree_err_handles = 0,
    kl_core_Handle_GetSidByHandle_req_arena_size =
    0,
    kl_core_Handle_GetSidByHandle_res_arena_size =
    0,
    kl_core_Handle_GetSidByHandle_req_handles = 1,
    kl_core_Handle_GetSidByHandle_res_handles = 0,
    kl_core_Handle_GetSidByHandle_err_handles = 0,
    kl_core_Handle_Revoke_req_arena_size = 0,
    kl_core_Handle_Revoke_res_arena_size = 0,
    kl_core_Handle_Revoke_req_handles = 1,
    kl_core_Handle_Revoke_res_handles = 0,
    kl_core_Handle_Revoke_err_handles = 0,
    kl_core_Handle_RevokeSubtree_req_arena_size =
    0,
    kl_core_Handle_RevokeSubtree_res_arena_size =
    0,
    kl_core_Handle_RevokeSubtree_req_handles = 2,
    kl_core_Handle_RevokeSubtree_res_handles = 0,
    kl_core_Handle_RevokeSubtree_err_handles = 0,
    kl_core_Handle_CreateBadge_req_arena_size = 0,
    kl_core_Handle_CreateBadge_res_arena_size = 0,
    kl_core_Handle_CreateBadge_req_handles = 1,
    kl_core_Handle_CreateBadge_res_handles = 1,
    kl_core_Handle_CreateBadge_err_handles = 0,
    kl_core_Handle_req_arena_size = 0,
    kl_core_Handle_res_arena_size = 0,
    kl_core_Handle_req_handles = 2,
    kl_core_Handle_res_handles = 1,
    kl_core_Handle_err_handles = 0,
};
typedef struct __nk_packed kl_core_Handle_Alloc_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_Alloc_req;
nk_static_assert(sizeof(kl_core_Handle_Alloc_req) == 24, bad_kl_core_Handle_Alloc_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Alloc_req, base_) == 0, bad_kl_core_Handle_Alloc_req_base__offset);
#pragma pack(push, 8) /* kl_core_Handle_Alloc_res */
typedef struct kl_core_Handle_Alloc_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_Alloc_err;
nk_static_assert(sizeof(kl_core_Handle_Alloc_err) == 24, bad_kl_core_Handle_Alloc_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Alloc_err, base_) == 0, bad_kl_core_Handle_Alloc_err_base__offset);
typedef struct kl_core_Handle_Alloc_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_Alloc_err err_;
            };
        } kl_core_Handle_Alloc_res;
nk_static_assert(sizeof(kl_core_Handle_Alloc_res) == 48, bad_kl_core_Handle_Alloc_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Alloc_res, base_) == 0, bad_kl_core_Handle_Alloc_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Alloc_res, handle) == 24, bad_kl_core_Handle_Alloc_res_handle_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Alloc_res, rc) == 40, bad_kl_core_Handle_Alloc_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_Alloc_res */
typedef struct __nk_packed kl_core_Handle_Free_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
        } kl_core_Handle_Free_req;
nk_static_assert(sizeof(kl_core_Handle_Free_req) == 40, bad_kl_core_Handle_Free_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Free_req, base_) == 0, bad_kl_core_Handle_Free_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Free_req, handle) == 24, bad_kl_core_Handle_Free_req_handle_offset);
#pragma pack(push, 8) /* kl_core_Handle_Free_res */
typedef struct kl_core_Handle_Free_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_Free_err;
nk_static_assert(sizeof(kl_core_Handle_Free_err) == 24, bad_kl_core_Handle_Free_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Free_err, base_) == 0, bad_kl_core_Handle_Free_err_base__offset);
typedef struct kl_core_Handle_Free_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_Free_err err_;
            };
        } kl_core_Handle_Free_res;
nk_static_assert(sizeof(kl_core_Handle_Free_res) == 32, bad_kl_core_Handle_Free_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Free_res, base_) == 0, bad_kl_core_Handle_Free_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Free_res, rc) == 24, bad_kl_core_Handle_Free_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_Free_res */
typedef struct __nk_packed kl_core_Handle_Copy_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t inHandle;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t copyBadge;
            __nk_alignas(4)
            nk_uint32_t newRightsMask;
        } kl_core_Handle_Copy_req;
nk_static_assert(sizeof(kl_core_Handle_Copy_req) == 64, bad_kl_core_Handle_Copy_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Copy_req, base_) == 0, bad_kl_core_Handle_Copy_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Copy_req, inHandle) == 24, bad_kl_core_Handle_Copy_req_inHandle_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Copy_req, copyBadge) == 40, bad_kl_core_Handle_Copy_req_copyBadge_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Copy_req, newRightsMask) == 56, bad_kl_core_Handle_Copy_req_newRightsMask_offset);
#pragma pack(push, 8) /* kl_core_Handle_Copy_res */
typedef struct kl_core_Handle_Copy_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_Copy_err;
nk_static_assert(sizeof(kl_core_Handle_Copy_err) == 24, bad_kl_core_Handle_Copy_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Copy_err, base_) == 0, bad_kl_core_Handle_Copy_err_base__offset);
typedef struct kl_core_Handle_Copy_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t outHandle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t outHandle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_Copy_err err_;
            };
        } kl_core_Handle_Copy_res;
nk_static_assert(sizeof(kl_core_Handle_Copy_res) == 48, bad_kl_core_Handle_Copy_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Copy_res, base_) == 0, bad_kl_core_Handle_Copy_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Copy_res, outHandle) == 24, bad_kl_core_Handle_Copy_res_outHandle_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Copy_res, rc) == 40, bad_kl_core_Handle_Copy_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_Copy_res */
typedef struct __nk_packed kl_core_Handle_Init_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
            __nk_alignas(4) nk_uint32_t type;
            __nk_alignas(4) nk_uint32_t rights;
        } kl_core_Handle_Init_req;
nk_static_assert(sizeof(kl_core_Handle_Init_req) == 48, bad_kl_core_Handle_Init_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Init_req, base_) == 0, bad_kl_core_Handle_Init_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Init_req, handle) == 24, bad_kl_core_Handle_Init_req_handle_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Init_req, type) == 40, bad_kl_core_Handle_Init_req_type_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Init_req, rights) == 44, bad_kl_core_Handle_Init_req_rights_offset);
#pragma pack(push, 8) /* kl_core_Handle_Init_res */
typedef struct kl_core_Handle_Init_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_Init_err;
nk_static_assert(sizeof(kl_core_Handle_Init_err) == 24, bad_kl_core_Handle_Init_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Init_err, base_) == 0, bad_kl_core_Handle_Init_err_base__offset);
typedef struct kl_core_Handle_Init_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_Init_err err_;
            };
        } kl_core_Handle_Init_res;
nk_static_assert(sizeof(kl_core_Handle_Init_res) == 32, bad_kl_core_Handle_Init_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Init_res, base_) == 0, bad_kl_core_Handle_Init_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Init_res, rc) == 24, bad_kl_core_Handle_Init_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_Init_res */
typedef struct __nk_packed kl_core_Handle_Fini_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
        } kl_core_Handle_Fini_req;
nk_static_assert(sizeof(kl_core_Handle_Fini_req) == 40, bad_kl_core_Handle_Fini_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Fini_req, base_) == 0, bad_kl_core_Handle_Fini_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Fini_req, handle) == 24, bad_kl_core_Handle_Fini_req_handle_offset);
#pragma pack(push, 8) /* kl_core_Handle_Fini_res */
typedef struct kl_core_Handle_Fini_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_Fini_err;
nk_static_assert(sizeof(kl_core_Handle_Fini_err) == 24, bad_kl_core_Handle_Fini_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Fini_err, base_) == 0, bad_kl_core_Handle_Fini_err_base__offset);
typedef struct kl_core_Handle_Fini_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_Fini_err err_;
            };
        } kl_core_Handle_Fini_res;
nk_static_assert(sizeof(kl_core_Handle_Fini_res) == 32, bad_kl_core_Handle_Fini_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Fini_res, base_) == 0, bad_kl_core_Handle_Fini_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Fini_res, rc) == 24, bad_kl_core_Handle_Fini_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_Fini_res */
typedef struct __nk_packed kl_core_Handle_CreateUserObject_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t ipcChannel;
            __nk_alignas(4) nk_uint32_t type;
            __nk_alignas(4) nk_uint32_t rights;
            __nk_alignas(8) nk_uint64_t context;
            __nk_alignas(2) nk_uint16_t riid;
        } kl_core_Handle_CreateUserObject_req;
nk_static_assert(sizeof(kl_core_Handle_CreateUserObject_req) == 64, bad_kl_core_Handle_CreateUserObject_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateUserObject_req, base_) == 0, bad_kl_core_Handle_CreateUserObject_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateUserObject_req, ipcChannel) == 24, bad_kl_core_Handle_CreateUserObject_req_ipcChannel_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateUserObject_req, type) == 40, bad_kl_core_Handle_CreateUserObject_req_type_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateUserObject_req, rights) == 44, bad_kl_core_Handle_CreateUserObject_req_rights_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateUserObject_req, context) == 48, bad_kl_core_Handle_CreateUserObject_req_context_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateUserObject_req, riid) == 56, bad_kl_core_Handle_CreateUserObject_req_riid_offset);
#pragma pack(push, 8) /* kl_core_Handle_CreateUserObject_res */
typedef struct kl_core_Handle_CreateUserObject_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_CreateUserObject_err;
nk_static_assert(sizeof(kl_core_Handle_CreateUserObject_err) == 24, bad_kl_core_Handle_CreateUserObject_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateUserObject_err, base_) == 0, bad_kl_core_Handle_CreateUserObject_err_base__offset);
typedef struct kl_core_Handle_CreateUserObject_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_CreateUserObject_err err_;
            };
        } kl_core_Handle_CreateUserObject_res;
nk_static_assert(sizeof(kl_core_Handle_CreateUserObject_res) == 48, bad_kl_core_Handle_CreateUserObject_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateUserObject_res, base_) == 0, bad_kl_core_Handle_CreateUserObject_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateUserObject_res, handle) == 24, bad_kl_core_Handle_CreateUserObject_res_handle_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateUserObject_res, rc) == 40, bad_kl_core_Handle_CreateUserObject_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_CreateUserObject_res */
typedef struct __nk_packed kl_core_Handle_Close_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
        } kl_core_Handle_Close_req;
nk_static_assert(sizeof(kl_core_Handle_Close_req) == 40, bad_kl_core_Handle_Close_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Close_req, base_) == 0, bad_kl_core_Handle_Close_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Close_req, handle) == 24, bad_kl_core_Handle_Close_req_handle_offset);
#pragma pack(push, 8) /* kl_core_Handle_Close_res */
typedef struct kl_core_Handle_Close_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_Close_err;
nk_static_assert(sizeof(kl_core_Handle_Close_err) == 24, bad_kl_core_Handle_Close_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Close_err, base_) == 0, bad_kl_core_Handle_Close_err_base__offset);
typedef struct kl_core_Handle_Close_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_Close_err err_;
            };
        } kl_core_Handle_Close_res;
nk_static_assert(sizeof(kl_core_Handle_Close_res) == 32, bad_kl_core_Handle_Close_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Close_res, base_) == 0, bad_kl_core_Handle_Close_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Close_res, rc) == 24, bad_kl_core_Handle_Close_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_Close_res */
typedef struct __nk_packed kl_core_Handle_Connect_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t server;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t client;
            __nk_alignas(4)
            nk_uint32_t srListener;
            __nk_alignas(1)
            nk_uint8_t createSrEndpoint;
        } kl_core_Handle_Connect_req;
nk_static_assert(sizeof(kl_core_Handle_Connect_req) == 64, bad_kl_core_Handle_Connect_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Connect_req, base_) == 0, bad_kl_core_Handle_Connect_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Connect_req, server) == 24, bad_kl_core_Handle_Connect_req_server_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Connect_req, client) == 40, bad_kl_core_Handle_Connect_req_client_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Connect_req, srListener) == 56, bad_kl_core_Handle_Connect_req_srListener_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Connect_req, createSrEndpoint) == 60, bad_kl_core_Handle_Connect_req_createSrEndpoint_offset);
#pragma pack(push, 8) /* kl_core_Handle_Connect_res */
typedef struct kl_core_Handle_Connect_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_Connect_err;
nk_static_assert(sizeof(kl_core_Handle_Connect_err) == 24, bad_kl_core_Handle_Connect_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Connect_err, base_) == 0, bad_kl_core_Handle_Connect_err_base__offset);
typedef struct kl_core_Handle_Connect_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t outSrListener;
                    __nk_alignas(4)
                    nk_uint32_t outSrEndpoint;
                    __nk_alignas(4)
                    nk_uint32_t outClEndpoint;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t outSrListener;
                    __nk_alignas(4)
                    nk_uint32_t outSrEndpoint;
                    __nk_alignas(4)
                    nk_uint32_t outClEndpoint;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_Connect_err err_;
            };
        } kl_core_Handle_Connect_res;
nk_static_assert(sizeof(kl_core_Handle_Connect_res) == 40, bad_kl_core_Handle_Connect_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Connect_res, base_) == 0, bad_kl_core_Handle_Connect_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Connect_res, outSrListener) == 24, bad_kl_core_Handle_Connect_res_outSrListener_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Connect_res, outSrEndpoint) == 28, bad_kl_core_Handle_Connect_res_outSrEndpoint_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Connect_res, outClEndpoint) == 32, bad_kl_core_Handle_Connect_res_outClEndpoint_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Connect_res, rc) == 36, bad_kl_core_Handle_Connect_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_Connect_res */
typedef struct __nk_packed kl_core_Handle_Disconnect_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t client;
        } kl_core_Handle_Disconnect_req;
nk_static_assert(sizeof(kl_core_Handle_Disconnect_req) == 40, bad_kl_core_Handle_Disconnect_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Disconnect_req, base_) == 0, bad_kl_core_Handle_Disconnect_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Disconnect_req, client) == 24, bad_kl_core_Handle_Disconnect_req_client_offset);
#pragma pack(push, 8) /* kl_core_Handle_Disconnect_res */
typedef struct kl_core_Handle_Disconnect_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_Disconnect_err;
nk_static_assert(sizeof(kl_core_Handle_Disconnect_err) == 24, bad_kl_core_Handle_Disconnect_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Disconnect_err, base_) == 0, bad_kl_core_Handle_Disconnect_err_base__offset);
typedef struct kl_core_Handle_Disconnect_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_Disconnect_err err_;
            };
        } kl_core_Handle_Disconnect_res;
nk_static_assert(sizeof(kl_core_Handle_Disconnect_res) == 32, bad_kl_core_Handle_Disconnect_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Disconnect_res, base_) == 0, bad_kl_core_Handle_Disconnect_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Disconnect_res, rc) == 24, bad_kl_core_Handle_Disconnect_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_Disconnect_res */
typedef struct __nk_packed kl_core_Handle_SecurityConnect_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_SecurityConnect_req;
nk_static_assert(sizeof(kl_core_Handle_SecurityConnect_req) == 24, bad_kl_core_Handle_SecurityConnect_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_SecurityConnect_req, base_) == 0, bad_kl_core_Handle_SecurityConnect_req_base__offset);
#pragma pack(push, 8) /* kl_core_Handle_SecurityConnect_res */
typedef struct kl_core_Handle_SecurityConnect_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_SecurityConnect_err;
nk_static_assert(sizeof(kl_core_Handle_SecurityConnect_err) == 24, bad_kl_core_Handle_SecurityConnect_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_SecurityConnect_err, base_) == 0, bad_kl_core_Handle_SecurityConnect_err_base__offset);
typedef struct kl_core_Handle_SecurityConnect_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t client;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t client;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_SecurityConnect_err err_;
            };
        } kl_core_Handle_SecurityConnect_res;
nk_static_assert(sizeof(kl_core_Handle_SecurityConnect_res) == 48, bad_kl_core_Handle_SecurityConnect_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_SecurityConnect_res, base_) == 0, bad_kl_core_Handle_SecurityConnect_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_SecurityConnect_res, client) == 24, bad_kl_core_Handle_SecurityConnect_res_client_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_SecurityConnect_res, rc) == 40, bad_kl_core_Handle_SecurityConnect_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_SecurityConnect_res */
typedef struct __nk_packed kl_core_Handle_UidAlloc_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_UidAlloc_req;
nk_static_assert(sizeof(kl_core_Handle_UidAlloc_req) == 24, bad_kl_core_Handle_UidAlloc_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_UidAlloc_req, base_) == 0, bad_kl_core_Handle_UidAlloc_req_base__offset);
#pragma pack(push, 8) /* kl_core_Handle_UidAlloc_res */
typedef struct kl_core_Handle_UidAlloc_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_UidAlloc_err;
nk_static_assert(sizeof(kl_core_Handle_UidAlloc_err) == 24, bad_kl_core_Handle_UidAlloc_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_UidAlloc_err, base_) == 0, bad_kl_core_Handle_UidAlloc_err_base__offset);
typedef struct kl_core_Handle_UidAlloc_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t uid;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t uid;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_UidAlloc_err err_;
            };
        } kl_core_Handle_UidAlloc_res;
nk_static_assert(sizeof(kl_core_Handle_UidAlloc_res) == 32, bad_kl_core_Handle_UidAlloc_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_UidAlloc_res, base_) == 0, bad_kl_core_Handle_UidAlloc_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_UidAlloc_res, uid) == 24, bad_kl_core_Handle_UidAlloc_res_uid_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_UidAlloc_res, rc) == 28, bad_kl_core_Handle_UidAlloc_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_UidAlloc_res */
typedef struct __nk_packed kl_core_Handle_UidFree_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t uid;
        } kl_core_Handle_UidFree_req;
nk_static_assert(sizeof(kl_core_Handle_UidFree_req) == 32, bad_kl_core_Handle_UidFree_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_UidFree_req, base_) == 0, bad_kl_core_Handle_UidFree_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_UidFree_req, uid) == 24, bad_kl_core_Handle_UidFree_req_uid_offset);
#pragma pack(push, 8) /* kl_core_Handle_UidFree_res */
typedef struct kl_core_Handle_UidFree_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_UidFree_err;
nk_static_assert(sizeof(kl_core_Handle_UidFree_err) == 24, bad_kl_core_Handle_UidFree_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_UidFree_err, base_) == 0, bad_kl_core_Handle_UidFree_err_base__offset);
typedef struct kl_core_Handle_UidFree_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_UidFree_err err_;
            };
        } kl_core_Handle_UidFree_res;
nk_static_assert(sizeof(kl_core_Handle_UidFree_res) == 32, bad_kl_core_Handle_UidFree_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_UidFree_res, base_) == 0, bad_kl_core_Handle_UidFree_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_UidFree_res, rc) == 24, bad_kl_core_Handle_UidFree_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_UidFree_res */
typedef struct __nk_packed kl_core_Handle_GetSidByHandle_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
        } kl_core_Handle_GetSidByHandle_req;
nk_static_assert(sizeof(kl_core_Handle_GetSidByHandle_req) == 40, bad_kl_core_Handle_GetSidByHandle_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_GetSidByHandle_req, base_) == 0, bad_kl_core_Handle_GetSidByHandle_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_GetSidByHandle_req, handle) == 24, bad_kl_core_Handle_GetSidByHandle_req_handle_offset);
#pragma pack(push, 8) /* kl_core_Handle_GetSidByHandle_res */
typedef struct kl_core_Handle_GetSidByHandle_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_GetSidByHandle_err;
nk_static_assert(sizeof(kl_core_Handle_GetSidByHandle_err) == 24, bad_kl_core_Handle_GetSidByHandle_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_GetSidByHandle_err, base_) == 0, bad_kl_core_Handle_GetSidByHandle_err_base__offset);
typedef struct kl_core_Handle_GetSidByHandle_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t sid;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t sid;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_GetSidByHandle_err err_;
            };
        } kl_core_Handle_GetSidByHandle_res;
nk_static_assert(sizeof(kl_core_Handle_GetSidByHandle_res) == 32, bad_kl_core_Handle_GetSidByHandle_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_GetSidByHandle_res, base_) == 0, bad_kl_core_Handle_GetSidByHandle_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_GetSidByHandle_res, sid) == 24, bad_kl_core_Handle_GetSidByHandle_res_sid_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_GetSidByHandle_res, rc) == 28, bad_kl_core_Handle_GetSidByHandle_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_GetSidByHandle_res */
typedef struct __nk_packed kl_core_Handle_Revoke_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
        } kl_core_Handle_Revoke_req;
nk_static_assert(sizeof(kl_core_Handle_Revoke_req) == 40, bad_kl_core_Handle_Revoke_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Revoke_req, base_) == 0, bad_kl_core_Handle_Revoke_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Revoke_req, handle) == 24, bad_kl_core_Handle_Revoke_req_handle_offset);
#pragma pack(push, 8) /* kl_core_Handle_Revoke_res */
typedef struct kl_core_Handle_Revoke_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_Revoke_err;
nk_static_assert(sizeof(kl_core_Handle_Revoke_err) == 24, bad_kl_core_Handle_Revoke_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Revoke_err, base_) == 0, bad_kl_core_Handle_Revoke_err_base__offset);
typedef struct kl_core_Handle_Revoke_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_Revoke_err err_;
            };
        } kl_core_Handle_Revoke_res;
nk_static_assert(sizeof(kl_core_Handle_Revoke_res) == 32, bad_kl_core_Handle_Revoke_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_Revoke_res, base_) == 0, bad_kl_core_Handle_Revoke_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_Revoke_res, rc) == 24, bad_kl_core_Handle_Revoke_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_Revoke_res */
typedef struct __nk_packed kl_core_Handle_RevokeSubtree_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t badge;
        } kl_core_Handle_RevokeSubtree_req;
nk_static_assert(sizeof(kl_core_Handle_RevokeSubtree_req) == 56, bad_kl_core_Handle_RevokeSubtree_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_RevokeSubtree_req, base_) == 0, bad_kl_core_Handle_RevokeSubtree_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_RevokeSubtree_req, handle) == 24, bad_kl_core_Handle_RevokeSubtree_req_handle_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_RevokeSubtree_req, badge) == 40, bad_kl_core_Handle_RevokeSubtree_req_badge_offset);
#pragma pack(push, 8) /* kl_core_Handle_RevokeSubtree_res */
typedef struct kl_core_Handle_RevokeSubtree_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_RevokeSubtree_err;
nk_static_assert(sizeof(kl_core_Handle_RevokeSubtree_err) == 24, bad_kl_core_Handle_RevokeSubtree_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_RevokeSubtree_err, base_) == 0, bad_kl_core_Handle_RevokeSubtree_err_base__offset);
typedef struct kl_core_Handle_RevokeSubtree_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_RevokeSubtree_err err_;
            };
        } kl_core_Handle_RevokeSubtree_res;
nk_static_assert(sizeof(kl_core_Handle_RevokeSubtree_res) == 32, bad_kl_core_Handle_RevokeSubtree_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_RevokeSubtree_res, base_) == 0, bad_kl_core_Handle_RevokeSubtree_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_RevokeSubtree_res, rc) == 24, bad_kl_core_Handle_RevokeSubtree_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_RevokeSubtree_res */
typedef struct __nk_packed kl_core_Handle_CreateBadge_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t notify;
            __nk_alignas(8)
            nk_uint64_t notifyContext;
            __nk_alignas(8)
            nk_uint64_t badgeContext;
        } kl_core_Handle_CreateBadge_req;
nk_static_assert(sizeof(kl_core_Handle_CreateBadge_req) == 56, bad_kl_core_Handle_CreateBadge_req_size);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateBadge_req, base_) == 0, bad_kl_core_Handle_CreateBadge_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateBadge_req, notify) == 24, bad_kl_core_Handle_CreateBadge_req_notify_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateBadge_req, notifyContext) == 40, bad_kl_core_Handle_CreateBadge_req_notifyContext_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateBadge_req, badgeContext) == 48, bad_kl_core_Handle_CreateBadge_req_badgeContext_offset);
#pragma pack(push, 8) /* kl_core_Handle_CreateBadge_res */
typedef struct kl_core_Handle_CreateBadge_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Handle_CreateBadge_err;
nk_static_assert(sizeof(kl_core_Handle_CreateBadge_err) == 24, bad_kl_core_Handle_CreateBadge_err_size);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateBadge_err, base_) == 0, bad_kl_core_Handle_CreateBadge_err_base__offset);
typedef struct kl_core_Handle_CreateBadge_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t badge;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t badge;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Handle_CreateBadge_err err_;
            };
        } kl_core_Handle_CreateBadge_res;
nk_static_assert(sizeof(kl_core_Handle_CreateBadge_res) == 48, bad_kl_core_Handle_CreateBadge_res_size);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateBadge_res, base_) == 0, bad_kl_core_Handle_CreateBadge_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateBadge_res, badge) == 24, bad_kl_core_Handle_CreateBadge_res_badge_offset);
nk_static_assert(nk_offsetof(kl_core_Handle_CreateBadge_res, rc) == 40, bad_kl_core_Handle_CreateBadge_res_rc_offset);
#pragma pack(pop) /* kl_core_Handle_CreateBadge_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Handle_Alloc_mid kl_core_Handle_Alloc_mid
#define Handle_Free_mid kl_core_Handle_Free_mid
#define Handle_Copy_mid kl_core_Handle_Copy_mid
#define Handle_Init_mid kl_core_Handle_Init_mid
#define Handle_Fini_mid kl_core_Handle_Fini_mid
#define Handle_CreateUserObject_mid kl_core_Handle_CreateUserObject_mid
#define Handle_Close_mid kl_core_Handle_Close_mid
#define Handle_Connect_mid kl_core_Handle_Connect_mid
#define Handle_Disconnect_mid kl_core_Handle_Disconnect_mid
#define Handle_SecurityConnect_mid kl_core_Handle_SecurityConnect_mid
#define Handle_UidAlloc_mid kl_core_Handle_UidAlloc_mid
#define Handle_UidFree_mid kl_core_Handle_UidFree_mid
#define Handle_GetSidByHandle_mid kl_core_Handle_GetSidByHandle_mid
#define Handle_Revoke_mid kl_core_Handle_Revoke_mid
#define Handle_RevokeSubtree_mid kl_core_Handle_RevokeSubtree_mid
#define Handle_CreateBadge_mid kl_core_Handle_CreateBadge_mid
#define Handle_mid_max kl_core_Handle_mid_max
#define Handle_Alloc_req_arena_size kl_core_Handle_Alloc_req_arena_size
#define Handle_Alloc_res_arena_size kl_core_Handle_Alloc_res_arena_size
#define Handle_Alloc_req_handles kl_core_Handle_Alloc_req_handles
#define Handle_Alloc_res_handles kl_core_Handle_Alloc_res_handles
#define Handle_Alloc_err_handles kl_core_Handle_Alloc_err_handles
#define Handle_Free_req_arena_size kl_core_Handle_Free_req_arena_size
#define Handle_Free_res_arena_size kl_core_Handle_Free_res_arena_size
#define Handle_Free_req_handles kl_core_Handle_Free_req_handles
#define Handle_Free_res_handles kl_core_Handle_Free_res_handles
#define Handle_Free_err_handles kl_core_Handle_Free_err_handles
#define Handle_Copy_req_arena_size kl_core_Handle_Copy_req_arena_size
#define Handle_Copy_res_arena_size kl_core_Handle_Copy_res_arena_size
#define Handle_Copy_req_handles kl_core_Handle_Copy_req_handles
#define Handle_Copy_res_handles kl_core_Handle_Copy_res_handles
#define Handle_Copy_err_handles kl_core_Handle_Copy_err_handles
#define Handle_Init_req_arena_size kl_core_Handle_Init_req_arena_size
#define Handle_Init_res_arena_size kl_core_Handle_Init_res_arena_size
#define Handle_Init_req_handles kl_core_Handle_Init_req_handles
#define Handle_Init_res_handles kl_core_Handle_Init_res_handles
#define Handle_Init_err_handles kl_core_Handle_Init_err_handles
#define Handle_Fini_req_arena_size kl_core_Handle_Fini_req_arena_size
#define Handle_Fini_res_arena_size kl_core_Handle_Fini_res_arena_size
#define Handle_Fini_req_handles kl_core_Handle_Fini_req_handles
#define Handle_Fini_res_handles kl_core_Handle_Fini_res_handles
#define Handle_Fini_err_handles kl_core_Handle_Fini_err_handles
#define Handle_CreateUserObject_req_arena_size kl_core_Handle_CreateUserObject_req_arena_size
#define Handle_CreateUserObject_res_arena_size kl_core_Handle_CreateUserObject_res_arena_size
#define Handle_CreateUserObject_req_handles kl_core_Handle_CreateUserObject_req_handles
#define Handle_CreateUserObject_res_handles kl_core_Handle_CreateUserObject_res_handles
#define Handle_CreateUserObject_err_handles kl_core_Handle_CreateUserObject_err_handles
#define Handle_Close_req_arena_size kl_core_Handle_Close_req_arena_size
#define Handle_Close_res_arena_size kl_core_Handle_Close_res_arena_size
#define Handle_Close_req_handles kl_core_Handle_Close_req_handles
#define Handle_Close_res_handles kl_core_Handle_Close_res_handles
#define Handle_Close_err_handles kl_core_Handle_Close_err_handles
#define Handle_Connect_req_arena_size kl_core_Handle_Connect_req_arena_size
#define Handle_Connect_res_arena_size kl_core_Handle_Connect_res_arena_size
#define Handle_Connect_req_handles kl_core_Handle_Connect_req_handles
#define Handle_Connect_res_handles kl_core_Handle_Connect_res_handles
#define Handle_Connect_err_handles kl_core_Handle_Connect_err_handles
#define Handle_Disconnect_req_arena_size kl_core_Handle_Disconnect_req_arena_size
#define Handle_Disconnect_res_arena_size kl_core_Handle_Disconnect_res_arena_size
#define Handle_Disconnect_req_handles kl_core_Handle_Disconnect_req_handles
#define Handle_Disconnect_res_handles kl_core_Handle_Disconnect_res_handles
#define Handle_Disconnect_err_handles kl_core_Handle_Disconnect_err_handles
#define Handle_SecurityConnect_req_arena_size kl_core_Handle_SecurityConnect_req_arena_size
#define Handle_SecurityConnect_res_arena_size kl_core_Handle_SecurityConnect_res_arena_size
#define Handle_SecurityConnect_req_handles kl_core_Handle_SecurityConnect_req_handles
#define Handle_SecurityConnect_res_handles kl_core_Handle_SecurityConnect_res_handles
#define Handle_SecurityConnect_err_handles kl_core_Handle_SecurityConnect_err_handles
#define Handle_UidAlloc_req_arena_size kl_core_Handle_UidAlloc_req_arena_size
#define Handle_UidAlloc_res_arena_size kl_core_Handle_UidAlloc_res_arena_size
#define Handle_UidAlloc_req_handles kl_core_Handle_UidAlloc_req_handles
#define Handle_UidAlloc_res_handles kl_core_Handle_UidAlloc_res_handles
#define Handle_UidAlloc_err_handles kl_core_Handle_UidAlloc_err_handles
#define Handle_UidFree_req_arena_size kl_core_Handle_UidFree_req_arena_size
#define Handle_UidFree_res_arena_size kl_core_Handle_UidFree_res_arena_size
#define Handle_UidFree_req_handles kl_core_Handle_UidFree_req_handles
#define Handle_UidFree_res_handles kl_core_Handle_UidFree_res_handles
#define Handle_UidFree_err_handles kl_core_Handle_UidFree_err_handles
#define Handle_GetSidByHandle_req_arena_size kl_core_Handle_GetSidByHandle_req_arena_size
#define Handle_GetSidByHandle_res_arena_size kl_core_Handle_GetSidByHandle_res_arena_size
#define Handle_GetSidByHandle_req_handles kl_core_Handle_GetSidByHandle_req_handles
#define Handle_GetSidByHandle_res_handles kl_core_Handle_GetSidByHandle_res_handles
#define Handle_GetSidByHandle_err_handles kl_core_Handle_GetSidByHandle_err_handles
#define Handle_Revoke_req_arena_size kl_core_Handle_Revoke_req_arena_size
#define Handle_Revoke_res_arena_size kl_core_Handle_Revoke_res_arena_size
#define Handle_Revoke_req_handles kl_core_Handle_Revoke_req_handles
#define Handle_Revoke_res_handles kl_core_Handle_Revoke_res_handles
#define Handle_Revoke_err_handles kl_core_Handle_Revoke_err_handles
#define Handle_RevokeSubtree_req_arena_size kl_core_Handle_RevokeSubtree_req_arena_size
#define Handle_RevokeSubtree_res_arena_size kl_core_Handle_RevokeSubtree_res_arena_size
#define Handle_RevokeSubtree_req_handles kl_core_Handle_RevokeSubtree_req_handles
#define Handle_RevokeSubtree_res_handles kl_core_Handle_RevokeSubtree_res_handles
#define Handle_RevokeSubtree_err_handles kl_core_Handle_RevokeSubtree_err_handles
#define Handle_CreateBadge_req_arena_size kl_core_Handle_CreateBadge_req_arena_size
#define Handle_CreateBadge_res_arena_size kl_core_Handle_CreateBadge_res_arena_size
#define Handle_CreateBadge_req_handles kl_core_Handle_CreateBadge_req_handles
#define Handle_CreateBadge_res_handles kl_core_Handle_CreateBadge_res_handles
#define Handle_CreateBadge_err_handles kl_core_Handle_CreateBadge_err_handles
#define Handle_req_arena_size kl_core_Handle_req_arena_size
#define Handle_res_arena_size kl_core_Handle_res_arena_size
#define Handle_req_handles kl_core_Handle_req_handles
#define Handle_res_handles kl_core_Handle_res_handles
#define Handle_err_handles kl_core_Handle_err_handles
#define Handle_Alloc_req kl_core_Handle_Alloc_req
#define Handle_Alloc_res kl_core_Handle_Alloc_res
#define Handle_Free_req kl_core_Handle_Free_req
#define Handle_Free_res kl_core_Handle_Free_res
#define Handle_Copy_req kl_core_Handle_Copy_req
#define Handle_Copy_res kl_core_Handle_Copy_res
#define Handle_Init_req kl_core_Handle_Init_req
#define Handle_Init_res kl_core_Handle_Init_res
#define Handle_Fini_req kl_core_Handle_Fini_req
#define Handle_Fini_res kl_core_Handle_Fini_res
#define Handle_CreateUserObject_req kl_core_Handle_CreateUserObject_req
#define Handle_CreateUserObject_res kl_core_Handle_CreateUserObject_res
#define Handle_Close_req kl_core_Handle_Close_req
#define Handle_Close_res kl_core_Handle_Close_res
#define Handle_Connect_req kl_core_Handle_Connect_req
#define Handle_Connect_res kl_core_Handle_Connect_res
#define Handle_Disconnect_req kl_core_Handle_Disconnect_req
#define Handle_Disconnect_res kl_core_Handle_Disconnect_res
#define Handle_SecurityConnect_req kl_core_Handle_SecurityConnect_req
#define Handle_SecurityConnect_res kl_core_Handle_SecurityConnect_res
#define Handle_UidAlloc_req kl_core_Handle_UidAlloc_req
#define Handle_UidAlloc_res kl_core_Handle_UidAlloc_res
#define Handle_UidFree_req kl_core_Handle_UidFree_req
#define Handle_UidFree_res kl_core_Handle_UidFree_res
#define Handle_GetSidByHandle_req kl_core_Handle_GetSidByHandle_req
#define Handle_GetSidByHandle_res kl_core_Handle_GetSidByHandle_res
#define Handle_Revoke_req kl_core_Handle_Revoke_req
#define Handle_Revoke_res kl_core_Handle_Revoke_res
#define Handle_RevokeSubtree_req kl_core_Handle_RevokeSubtree_req
#define Handle_RevokeSubtree_res kl_core_Handle_RevokeSubtree_res
#define Handle_CreateBadge_req kl_core_Handle_CreateBadge_req
#define Handle_CreateBadge_res kl_core_Handle_CreateBadge_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Handle__INTERFACE__ */

#ifndef __kl_core__IOMMU__INTERFACE__
#define __kl_core__IOMMU__INTERFACE__
enum {
    kl_core_IOMMU_Attach_mid,
    kl_core_IOMMU_Detach_mid,
    kl_core_IOMMU_CreateDomain_mid,
    kl_core_IOMMU_AttachToDomain_mid,
    kl_core_IOMMU_DetachFromDomain_mid,
    kl_core_IOMMU_mid_max,
};
enum {
    kl_core_IOMMU_Attach_req_arena_size = 0,
    kl_core_IOMMU_Attach_res_arena_size = 0,
    kl_core_IOMMU_Attach_req_handles = 0,
    kl_core_IOMMU_Attach_res_handles = 0,
    kl_core_IOMMU_Attach_err_handles = 0,
    kl_core_IOMMU_Detach_req_arena_size = 0,
    kl_core_IOMMU_Detach_res_arena_size = 0,
    kl_core_IOMMU_Detach_req_handles = 0,
    kl_core_IOMMU_Detach_res_handles = 0,
    kl_core_IOMMU_Detach_err_handles = 0,
    kl_core_IOMMU_CreateDomain_req_arena_size = 0,
    kl_core_IOMMU_CreateDomain_res_arena_size = 0,
    kl_core_IOMMU_CreateDomain_req_handles = 0,
    kl_core_IOMMU_CreateDomain_res_handles = 1,
    kl_core_IOMMU_CreateDomain_err_handles = 0,
    kl_core_IOMMU_AttachToDomain_req_arena_size =
    0,
    kl_core_IOMMU_AttachToDomain_res_arena_size =
    0,
    kl_core_IOMMU_AttachToDomain_req_handles = 1,
    kl_core_IOMMU_AttachToDomain_res_handles = 0,
    kl_core_IOMMU_AttachToDomain_err_handles = 0,
    kl_core_IOMMU_DetachFromDomain_req_arena_size =
    0,
    kl_core_IOMMU_DetachFromDomain_res_arena_size =
    0,
    kl_core_IOMMU_DetachFromDomain_req_handles =
    1,
    kl_core_IOMMU_DetachFromDomain_res_handles =
    0,
    kl_core_IOMMU_DetachFromDomain_err_handles =
    0,
    kl_core_IOMMU_req_arena_size = 0,
    kl_core_IOMMU_res_arena_size = 0,
    kl_core_IOMMU_req_handles = 1,
    kl_core_IOMMU_res_handles = 1,
    kl_core_IOMMU_err_handles = 0,
};
typedef struct __nk_packed kl_core_IOMMU_Attach_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(2) nk_uint16_t bdf;
        } kl_core_IOMMU_Attach_req;
nk_static_assert(sizeof(kl_core_IOMMU_Attach_req) == 32, bad_kl_core_IOMMU_Attach_req_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_Attach_req, base_) == 0, bad_kl_core_IOMMU_Attach_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IOMMU_Attach_req, bdf) == 24, bad_kl_core_IOMMU_Attach_req_bdf_offset);
#pragma pack(push, 8) /* kl_core_IOMMU_Attach_res */
typedef struct kl_core_IOMMU_Attach_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IOMMU_Attach_err;
nk_static_assert(sizeof(kl_core_IOMMU_Attach_err) == 24, bad_kl_core_IOMMU_Attach_err_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_Attach_err, base_) == 0, bad_kl_core_IOMMU_Attach_err_base__offset);
typedef struct kl_core_IOMMU_Attach_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IOMMU_Attach_err err_;
            };
        } kl_core_IOMMU_Attach_res;
nk_static_assert(sizeof(kl_core_IOMMU_Attach_res) == 32, bad_kl_core_IOMMU_Attach_res_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_Attach_res, base_) == 0, bad_kl_core_IOMMU_Attach_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IOMMU_Attach_res, rc) == 24, bad_kl_core_IOMMU_Attach_res_rc_offset);
#pragma pack(pop) /* kl_core_IOMMU_Attach_res */
typedef struct __nk_packed kl_core_IOMMU_Detach_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(2) nk_uint16_t bdf;
        } kl_core_IOMMU_Detach_req;
nk_static_assert(sizeof(kl_core_IOMMU_Detach_req) == 32, bad_kl_core_IOMMU_Detach_req_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_Detach_req, base_) == 0, bad_kl_core_IOMMU_Detach_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IOMMU_Detach_req, bdf) == 24, bad_kl_core_IOMMU_Detach_req_bdf_offset);
#pragma pack(push, 8) /* kl_core_IOMMU_Detach_res */
typedef struct kl_core_IOMMU_Detach_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IOMMU_Detach_err;
nk_static_assert(sizeof(kl_core_IOMMU_Detach_err) == 24, bad_kl_core_IOMMU_Detach_err_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_Detach_err, base_) == 0, bad_kl_core_IOMMU_Detach_err_base__offset);
typedef struct kl_core_IOMMU_Detach_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IOMMU_Detach_err err_;
            };
        } kl_core_IOMMU_Detach_res;
nk_static_assert(sizeof(kl_core_IOMMU_Detach_res) == 32, bad_kl_core_IOMMU_Detach_res_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_Detach_res, base_) == 0, bad_kl_core_IOMMU_Detach_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IOMMU_Detach_res, rc) == 24, bad_kl_core_IOMMU_Detach_res_rc_offset);
#pragma pack(pop) /* kl_core_IOMMU_Detach_res */
typedef struct __nk_packed kl_core_IOMMU_CreateDomain_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IOMMU_CreateDomain_req;
nk_static_assert(sizeof(kl_core_IOMMU_CreateDomain_req) == 24, bad_kl_core_IOMMU_CreateDomain_req_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_CreateDomain_req, base_) == 0, bad_kl_core_IOMMU_CreateDomain_req_base__offset);
#pragma pack(push, 8) /* kl_core_IOMMU_CreateDomain_res */
typedef struct kl_core_IOMMU_CreateDomain_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IOMMU_CreateDomain_err;
nk_static_assert(sizeof(kl_core_IOMMU_CreateDomain_err) == 24, bad_kl_core_IOMMU_CreateDomain_err_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_CreateDomain_err, base_) == 0, bad_kl_core_IOMMU_CreateDomain_err_base__offset);
typedef struct kl_core_IOMMU_CreateDomain_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t domain;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t domain;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IOMMU_CreateDomain_err err_;
            };
        } kl_core_IOMMU_CreateDomain_res;
nk_static_assert(sizeof(kl_core_IOMMU_CreateDomain_res) == 48, bad_kl_core_IOMMU_CreateDomain_res_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_CreateDomain_res, base_) == 0, bad_kl_core_IOMMU_CreateDomain_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IOMMU_CreateDomain_res, domain) == 24, bad_kl_core_IOMMU_CreateDomain_res_domain_offset);
nk_static_assert(nk_offsetof(kl_core_IOMMU_CreateDomain_res, rc) == 40, bad_kl_core_IOMMU_CreateDomain_res_rc_offset);
#pragma pack(pop) /* kl_core_IOMMU_CreateDomain_res */
typedef struct __nk_packed kl_core_IOMMU_AttachToDomain_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t domain;
            __nk_alignas(2) nk_uint16_t bdf;
        } kl_core_IOMMU_AttachToDomain_req;
nk_static_assert(sizeof(kl_core_IOMMU_AttachToDomain_req) == 48, bad_kl_core_IOMMU_AttachToDomain_req_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_AttachToDomain_req, base_) == 0, bad_kl_core_IOMMU_AttachToDomain_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IOMMU_AttachToDomain_req, domain) == 24, bad_kl_core_IOMMU_AttachToDomain_req_domain_offset);
nk_static_assert(nk_offsetof(kl_core_IOMMU_AttachToDomain_req, bdf) == 40, bad_kl_core_IOMMU_AttachToDomain_req_bdf_offset);
#pragma pack(push, 8) /* kl_core_IOMMU_AttachToDomain_res */
typedef struct kl_core_IOMMU_AttachToDomain_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IOMMU_AttachToDomain_err;
nk_static_assert(sizeof(kl_core_IOMMU_AttachToDomain_err) == 24, bad_kl_core_IOMMU_AttachToDomain_err_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_AttachToDomain_err, base_) == 0, bad_kl_core_IOMMU_AttachToDomain_err_base__offset);
typedef struct kl_core_IOMMU_AttachToDomain_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IOMMU_AttachToDomain_err err_;
            };
        } kl_core_IOMMU_AttachToDomain_res;
nk_static_assert(sizeof(kl_core_IOMMU_AttachToDomain_res) == 32, bad_kl_core_IOMMU_AttachToDomain_res_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_AttachToDomain_res, base_) == 0, bad_kl_core_IOMMU_AttachToDomain_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IOMMU_AttachToDomain_res, rc) == 24, bad_kl_core_IOMMU_AttachToDomain_res_rc_offset);
#pragma pack(pop) /* kl_core_IOMMU_AttachToDomain_res */
typedef struct __nk_packed kl_core_IOMMU_DetachFromDomain_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t domain;
            __nk_alignas(2) nk_uint16_t bdf;
        } kl_core_IOMMU_DetachFromDomain_req;
nk_static_assert(sizeof(kl_core_IOMMU_DetachFromDomain_req) == 48, bad_kl_core_IOMMU_DetachFromDomain_req_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_DetachFromDomain_req, base_) == 0, bad_kl_core_IOMMU_DetachFromDomain_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IOMMU_DetachFromDomain_req, domain) == 24, bad_kl_core_IOMMU_DetachFromDomain_req_domain_offset);
nk_static_assert(nk_offsetof(kl_core_IOMMU_DetachFromDomain_req, bdf) == 40, bad_kl_core_IOMMU_DetachFromDomain_req_bdf_offset);
#pragma pack(push, 8) /* kl_core_IOMMU_DetachFromDomain_res */
typedef struct kl_core_IOMMU_DetachFromDomain_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IOMMU_DetachFromDomain_err;
nk_static_assert(sizeof(kl_core_IOMMU_DetachFromDomain_err) == 24, bad_kl_core_IOMMU_DetachFromDomain_err_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_DetachFromDomain_err, base_) == 0, bad_kl_core_IOMMU_DetachFromDomain_err_base__offset);
typedef struct kl_core_IOMMU_DetachFromDomain_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IOMMU_DetachFromDomain_err err_;
            };
        } kl_core_IOMMU_DetachFromDomain_res;
nk_static_assert(sizeof(kl_core_IOMMU_DetachFromDomain_res) == 32, bad_kl_core_IOMMU_DetachFromDomain_res_size);
nk_static_assert(nk_offsetof(kl_core_IOMMU_DetachFromDomain_res, base_) == 0, bad_kl_core_IOMMU_DetachFromDomain_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IOMMU_DetachFromDomain_res, rc) == 24, bad_kl_core_IOMMU_DetachFromDomain_res_rc_offset);
#pragma pack(pop) /* kl_core_IOMMU_DetachFromDomain_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define IOMMU_Attach_mid kl_core_IOMMU_Attach_mid
#define IOMMU_Detach_mid kl_core_IOMMU_Detach_mid
#define IOMMU_CreateDomain_mid kl_core_IOMMU_CreateDomain_mid
#define IOMMU_AttachToDomain_mid kl_core_IOMMU_AttachToDomain_mid
#define IOMMU_DetachFromDomain_mid kl_core_IOMMU_DetachFromDomain_mid
#define IOMMU_mid_max kl_core_IOMMU_mid_max
#define IOMMU_Attach_req_arena_size kl_core_IOMMU_Attach_req_arena_size
#define IOMMU_Attach_res_arena_size kl_core_IOMMU_Attach_res_arena_size
#define IOMMU_Attach_req_handles kl_core_IOMMU_Attach_req_handles
#define IOMMU_Attach_res_handles kl_core_IOMMU_Attach_res_handles
#define IOMMU_Attach_err_handles kl_core_IOMMU_Attach_err_handles
#define IOMMU_Detach_req_arena_size kl_core_IOMMU_Detach_req_arena_size
#define IOMMU_Detach_res_arena_size kl_core_IOMMU_Detach_res_arena_size
#define IOMMU_Detach_req_handles kl_core_IOMMU_Detach_req_handles
#define IOMMU_Detach_res_handles kl_core_IOMMU_Detach_res_handles
#define IOMMU_Detach_err_handles kl_core_IOMMU_Detach_err_handles
#define IOMMU_CreateDomain_req_arena_size kl_core_IOMMU_CreateDomain_req_arena_size
#define IOMMU_CreateDomain_res_arena_size kl_core_IOMMU_CreateDomain_res_arena_size
#define IOMMU_CreateDomain_req_handles kl_core_IOMMU_CreateDomain_req_handles
#define IOMMU_CreateDomain_res_handles kl_core_IOMMU_CreateDomain_res_handles
#define IOMMU_CreateDomain_err_handles kl_core_IOMMU_CreateDomain_err_handles
#define IOMMU_AttachToDomain_req_arena_size kl_core_IOMMU_AttachToDomain_req_arena_size
#define IOMMU_AttachToDomain_res_arena_size kl_core_IOMMU_AttachToDomain_res_arena_size
#define IOMMU_AttachToDomain_req_handles kl_core_IOMMU_AttachToDomain_req_handles
#define IOMMU_AttachToDomain_res_handles kl_core_IOMMU_AttachToDomain_res_handles
#define IOMMU_AttachToDomain_err_handles kl_core_IOMMU_AttachToDomain_err_handles
#define IOMMU_DetachFromDomain_req_arena_size kl_core_IOMMU_DetachFromDomain_req_arena_size
#define IOMMU_DetachFromDomain_res_arena_size kl_core_IOMMU_DetachFromDomain_res_arena_size
#define IOMMU_DetachFromDomain_req_handles kl_core_IOMMU_DetachFromDomain_req_handles
#define IOMMU_DetachFromDomain_res_handles kl_core_IOMMU_DetachFromDomain_res_handles
#define IOMMU_DetachFromDomain_err_handles kl_core_IOMMU_DetachFromDomain_err_handles
#define IOMMU_req_arena_size kl_core_IOMMU_req_arena_size
#define IOMMU_res_arena_size kl_core_IOMMU_res_arena_size
#define IOMMU_req_handles kl_core_IOMMU_req_handles
#define IOMMU_res_handles kl_core_IOMMU_res_handles
#define IOMMU_err_handles kl_core_IOMMU_err_handles
#define IOMMU_Attach_req kl_core_IOMMU_Attach_req
#define IOMMU_Attach_res kl_core_IOMMU_Attach_res
#define IOMMU_Detach_req kl_core_IOMMU_Detach_req
#define IOMMU_Detach_res kl_core_IOMMU_Detach_res
#define IOMMU_CreateDomain_req kl_core_IOMMU_CreateDomain_req
#define IOMMU_CreateDomain_res kl_core_IOMMU_CreateDomain_res
#define IOMMU_AttachToDomain_req kl_core_IOMMU_AttachToDomain_req
#define IOMMU_AttachToDomain_res kl_core_IOMMU_AttachToDomain_res
#define IOMMU_DetachFromDomain_req kl_core_IOMMU_DetachFromDomain_req
#define IOMMU_DetachFromDomain_res kl_core_IOMMU_DetachFromDomain_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__IOMMU__INTERFACE__ */

#ifndef __kl_core__IO__INTERFACE__
#define __kl_core__IO__INTERFACE__
enum {
    kl_core_IO_RegisterPort_mid,
    kl_core_IO_RegisterMmio_mid,
    kl_core_IO_RegisterDma_mid,
    kl_core_IO_RegisterIrq_mid,
    kl_core_IO_RevokeResource_mid,
    kl_core_IO_MapMem_mid,
    kl_core_IO_PermitPort_mid,
    kl_core_IO_AttachIrq_mid,
    kl_core_IO_DetachIrq_mid,
    kl_core_IO_EnableIrq_mid,
    kl_core_IO_DisableIrq_mid,
    kl_core_IO_ModifyDma_mid,
    kl_core_IO_MapDma_mid,
    kl_core_IO_DmaGetInfo_mid,
    kl_core_IO_DmaGetPhysInfo_mid,
    kl_core_IO_BeginDma_mid,
    kl_core_IO_mid_max,
};
enum {
    kl_core_IO_RegisterPort_req_arena_size = 0,
    kl_core_IO_RegisterPort_res_arena_size = 0,
    kl_core_IO_RegisterPort_req_handles = 0,
    kl_core_IO_RegisterPort_res_handles = 1,
    kl_core_IO_RegisterPort_err_handles = 0,
    kl_core_IO_RegisterMmio_req_arena_size = 0,
    kl_core_IO_RegisterMmio_res_arena_size = 0,
    kl_core_IO_RegisterMmio_req_handles = 0,
    kl_core_IO_RegisterMmio_res_handles = 1,
    kl_core_IO_RegisterMmio_err_handles = 0,
    kl_core_IO_RegisterDma_req_arena_size = 0,
    kl_core_IO_RegisterDma_res_arena_size = 0,
    kl_core_IO_RegisterDma_req_handles = 0,
    kl_core_IO_RegisterDma_res_handles = 1,
    kl_core_IO_RegisterDma_err_handles = 0,
    kl_core_IO_RegisterIrq_req_arena_size = 0,
    kl_core_IO_RegisterIrq_res_arena_size = 0,
    kl_core_IO_RegisterIrq_req_handles = 0,
    kl_core_IO_RegisterIrq_res_handles = 1,
    kl_core_IO_RegisterIrq_err_handles = 0,
    kl_core_IO_RevokeResource_req_arena_size = 0,
    kl_core_IO_RevokeResource_res_arena_size = 0,
    kl_core_IO_RevokeResource_req_handles = 1,
    kl_core_IO_RevokeResource_res_handles = 0,
    kl_core_IO_RevokeResource_err_handles = 0,
    kl_core_IO_MapMem_req_arena_size = 0,
    kl_core_IO_MapMem_res_arena_size = 0,
    kl_core_IO_MapMem_req_handles = 1,
    kl_core_IO_MapMem_res_handles = 1,
    kl_core_IO_MapMem_err_handles = 0,
    kl_core_IO_PermitPort_req_arena_size = 0,
    kl_core_IO_PermitPort_res_arena_size = 0,
    kl_core_IO_PermitPort_req_handles = 1,
    kl_core_IO_PermitPort_res_handles = 1,
    kl_core_IO_PermitPort_err_handles = 0,
    kl_core_IO_AttachIrq_req_arena_size = 0,
    kl_core_IO_AttachIrq_res_arena_size = 0,
    kl_core_IO_AttachIrq_req_handles = 1,
    kl_core_IO_AttachIrq_res_handles = 1,
    kl_core_IO_AttachIrq_err_handles = 0,
    kl_core_IO_DetachIrq_req_arena_size = 0,
    kl_core_IO_DetachIrq_res_arena_size = 0,
    kl_core_IO_DetachIrq_req_handles = 1,
    kl_core_IO_DetachIrq_res_handles = 0,
    kl_core_IO_DetachIrq_err_handles = 0,
    kl_core_IO_EnableIrq_req_arena_size = 0,
    kl_core_IO_EnableIrq_res_arena_size = 0,
    kl_core_IO_EnableIrq_req_handles = 1,
    kl_core_IO_EnableIrq_res_handles = 0,
    kl_core_IO_EnableIrq_err_handles = 0,
    kl_core_IO_DisableIrq_req_arena_size = 0,
    kl_core_IO_DisableIrq_res_arena_size = 0,
    kl_core_IO_DisableIrq_req_handles = 1,
    kl_core_IO_DisableIrq_res_handles = 0,
    kl_core_IO_DisableIrq_err_handles = 0,
    kl_core_IO_ModifyDma_req_arena_size = 0,
    kl_core_IO_ModifyDma_res_arena_size = 0,
    kl_core_IO_ModifyDma_req_handles = 1,
    kl_core_IO_ModifyDma_res_handles = 0,
    kl_core_IO_ModifyDma_err_handles = 0,
    kl_core_IO_MapDma_req_arena_size = 0,
    kl_core_IO_MapDma_res_arena_size = 0,
    kl_core_IO_MapDma_req_handles = 1,
    kl_core_IO_MapDma_res_handles = 1,
    kl_core_IO_MapDma_err_handles = 0,
    kl_core_IO_DmaGetInfo_res_frames_size = 32,
    kl_core_IO_DmaGetInfo_req_arena_size = 0,
    kl_core_IO_DmaGetInfo_res_arena_size = 512,
    kl_core_IO_DmaGetInfo_req_handles = 1,
    kl_core_IO_DmaGetInfo_res_handles = 0,
    kl_core_IO_DmaGetInfo_err_handles = 0,
    kl_core_IO_DmaGetPhysInfo_res_frames_size =
    32,
    kl_core_IO_DmaGetPhysInfo_req_arena_size = 0,
    kl_core_IO_DmaGetPhysInfo_res_arena_size =
    512,
    kl_core_IO_DmaGetPhysInfo_req_handles = 1,
    kl_core_IO_DmaGetPhysInfo_res_handles = 0,
    kl_core_IO_DmaGetPhysInfo_err_handles = 0,
    kl_core_IO_BeginDma_req_arena_size = 0,
    kl_core_IO_BeginDma_res_arena_size = 0,
    kl_core_IO_BeginDma_req_handles = 2,
    kl_core_IO_BeginDma_res_handles = 1,
    kl_core_IO_BeginDma_err_handles = 0,
    kl_core_IO_req_arena_size = 0,
    kl_core_IO_res_arena_size = 512,
    kl_core_IO_req_handles = 2,
    kl_core_IO_res_handles = 1,
    kl_core_IO_err_handles = 0,
};
typedef struct __nk_packed kl_core_IO_RegisterPort_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(2) nk_uint16_t base;
            __nk_alignas(4) nk_uint32_t size;
        } kl_core_IO_RegisterPort_req;
nk_static_assert(sizeof(kl_core_IO_RegisterPort_req) == 32, bad_kl_core_IO_RegisterPort_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterPort_req, base_) == 0, bad_kl_core_IO_RegisterPort_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterPort_req, base) == 24, bad_kl_core_IO_RegisterPort_req_base_offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterPort_req, size) == 28, bad_kl_core_IO_RegisterPort_req_size_offset);
#pragma pack(push, 8) /* kl_core_IO_RegisterPort_res */
typedef struct kl_core_IO_RegisterPort_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_RegisterPort_err;
nk_static_assert(sizeof(kl_core_IO_RegisterPort_err) == 24, bad_kl_core_IO_RegisterPort_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterPort_err, base_) == 0, bad_kl_core_IO_RegisterPort_err_base__offset);
typedef struct kl_core_IO_RegisterPort_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_RegisterPort_err err_;
            };
        } kl_core_IO_RegisterPort_res;
nk_static_assert(sizeof(kl_core_IO_RegisterPort_res) == 48, bad_kl_core_IO_RegisterPort_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterPort_res, base_) == 0, bad_kl_core_IO_RegisterPort_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterPort_res, resource) == 24, bad_kl_core_IO_RegisterPort_res_resource_offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterPort_res, rc) == 40, bad_kl_core_IO_RegisterPort_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_RegisterPort_res */
typedef struct __nk_packed kl_core_IO_RegisterMmio_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t base;
            __nk_alignas(8) nk_uint64_t size;
        } kl_core_IO_RegisterMmio_req;
nk_static_assert(sizeof(kl_core_IO_RegisterMmio_req) == 40, bad_kl_core_IO_RegisterMmio_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterMmio_req, base_) == 0, bad_kl_core_IO_RegisterMmio_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterMmio_req, base) == 24, bad_kl_core_IO_RegisterMmio_req_base_offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterMmio_req, size) == 32, bad_kl_core_IO_RegisterMmio_req_size_offset);
#pragma pack(push, 8) /* kl_core_IO_RegisterMmio_res */
typedef struct kl_core_IO_RegisterMmio_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_RegisterMmio_err;
nk_static_assert(sizeof(kl_core_IO_RegisterMmio_err) == 24, bad_kl_core_IO_RegisterMmio_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterMmio_err, base_) == 0, bad_kl_core_IO_RegisterMmio_err_base__offset);
typedef struct kl_core_IO_RegisterMmio_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_RegisterMmio_err err_;
            };
        } kl_core_IO_RegisterMmio_res;
nk_static_assert(sizeof(kl_core_IO_RegisterMmio_res) == 48, bad_kl_core_IO_RegisterMmio_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterMmio_res, base_) == 0, bad_kl_core_IO_RegisterMmio_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterMmio_res, resource) == 24, bad_kl_core_IO_RegisterMmio_res_resource_offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterMmio_res, rc) == 40, bad_kl_core_IO_RegisterMmio_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_RegisterMmio_res */
typedef struct __nk_packed kl_core_IO_RegisterDma_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t size;
            __nk_alignas(4) nk_uint32_t flags;
            __nk_alignas(8) nk_uint64_t order;
        } kl_core_IO_RegisterDma_req;
nk_static_assert(sizeof(kl_core_IO_RegisterDma_req) == 48, bad_kl_core_IO_RegisterDma_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterDma_req, base_) == 0, bad_kl_core_IO_RegisterDma_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterDma_req, size) == 24, bad_kl_core_IO_RegisterDma_req_size_offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterDma_req, flags) == 32, bad_kl_core_IO_RegisterDma_req_flags_offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterDma_req, order) == 40, bad_kl_core_IO_RegisterDma_req_order_offset);
#pragma pack(push, 8) /* kl_core_IO_RegisterDma_res */
typedef struct kl_core_IO_RegisterDma_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_RegisterDma_err;
nk_static_assert(sizeof(kl_core_IO_RegisterDma_err) == 24, bad_kl_core_IO_RegisterDma_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterDma_err, base_) == 0, bad_kl_core_IO_RegisterDma_err_base__offset);
typedef struct kl_core_IO_RegisterDma_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_RegisterDma_err err_;
            };
        } kl_core_IO_RegisterDma_res;
nk_static_assert(sizeof(kl_core_IO_RegisterDma_res) == 48, bad_kl_core_IO_RegisterDma_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterDma_res, base_) == 0, bad_kl_core_IO_RegisterDma_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterDma_res, resource) == 24, bad_kl_core_IO_RegisterDma_res_resource_offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterDma_res, rc) == 40, bad_kl_core_IO_RegisterDma_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_RegisterDma_res */
typedef struct __nk_packed kl_core_IO_RegisterIrq_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t irq;
        } kl_core_IO_RegisterIrq_req;
nk_static_assert(sizeof(kl_core_IO_RegisterIrq_req) == 32, bad_kl_core_IO_RegisterIrq_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterIrq_req, base_) == 0, bad_kl_core_IO_RegisterIrq_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterIrq_req, irq) == 24, bad_kl_core_IO_RegisterIrq_req_irq_offset);
#pragma pack(push, 8) /* kl_core_IO_RegisterIrq_res */
typedef struct kl_core_IO_RegisterIrq_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_RegisterIrq_err;
nk_static_assert(sizeof(kl_core_IO_RegisterIrq_err) == 24, bad_kl_core_IO_RegisterIrq_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterIrq_err, base_) == 0, bad_kl_core_IO_RegisterIrq_err_base__offset);
typedef struct kl_core_IO_RegisterIrq_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_RegisterIrq_err err_;
            };
        } kl_core_IO_RegisterIrq_res;
nk_static_assert(sizeof(kl_core_IO_RegisterIrq_res) == 48, bad_kl_core_IO_RegisterIrq_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterIrq_res, base_) == 0, bad_kl_core_IO_RegisterIrq_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterIrq_res, resource) == 24, bad_kl_core_IO_RegisterIrq_res_resource_offset);
nk_static_assert(nk_offsetof(kl_core_IO_RegisterIrq_res, rc) == 40, bad_kl_core_IO_RegisterIrq_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_RegisterIrq_res */
typedef struct __nk_packed kl_core_IO_RevokeResource_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
        } kl_core_IO_RevokeResource_req;
nk_static_assert(sizeof(kl_core_IO_RevokeResource_req) == 40, bad_kl_core_IO_RevokeResource_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_RevokeResource_req, base_) == 0, bad_kl_core_IO_RevokeResource_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_RevokeResource_req, resource) == 24, bad_kl_core_IO_RevokeResource_req_resource_offset);
#pragma pack(push, 8) /* kl_core_IO_RevokeResource_res */
typedef struct kl_core_IO_RevokeResource_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_RevokeResource_err;
nk_static_assert(sizeof(kl_core_IO_RevokeResource_err) == 24, bad_kl_core_IO_RevokeResource_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_RevokeResource_err, base_) == 0, bad_kl_core_IO_RevokeResource_err_base__offset);
typedef struct kl_core_IO_RevokeResource_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_RevokeResource_err err_;
            };
        } kl_core_IO_RevokeResource_res;
nk_static_assert(sizeof(kl_core_IO_RevokeResource_res) == 32, bad_kl_core_IO_RevokeResource_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_RevokeResource_res, base_) == 0, bad_kl_core_IO_RevokeResource_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_RevokeResource_res, rc) == 24, bad_kl_core_IO_RevokeResource_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_RevokeResource_res */
typedef struct __nk_packed kl_core_IO_MapMem_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
            __nk_alignas(4) nk_uint32_t prot;
            __nk_alignas(4) nk_uint32_t attr;
        } kl_core_IO_MapMem_req;
nk_static_assert(sizeof(kl_core_IO_MapMem_req) == 48, bad_kl_core_IO_MapMem_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_MapMem_req, base_) == 0, bad_kl_core_IO_MapMem_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapMem_req, resource) == 24, bad_kl_core_IO_MapMem_req_resource_offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapMem_req, prot) == 40, bad_kl_core_IO_MapMem_req_prot_offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapMem_req, attr) == 44, bad_kl_core_IO_MapMem_req_attr_offset);
#pragma pack(push, 8) /* kl_core_IO_MapMem_res */
typedef struct kl_core_IO_MapMem_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_MapMem_err;
nk_static_assert(sizeof(kl_core_IO_MapMem_err) == 24, bad_kl_core_IO_MapMem_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_MapMem_err, base_) == 0, bad_kl_core_IO_MapMem_err_base__offset);
typedef struct kl_core_IO_MapMem_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t mapping;
                    __nk_alignas(8)
                    nk_uint64_t address;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t mapping;
                    __nk_alignas(8)
                    nk_uint64_t address;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_MapMem_err err_;
            };
        } kl_core_IO_MapMem_res;
nk_static_assert(sizeof(kl_core_IO_MapMem_res) == 56, bad_kl_core_IO_MapMem_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_MapMem_res, base_) == 0, bad_kl_core_IO_MapMem_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapMem_res, mapping) == 24, bad_kl_core_IO_MapMem_res_mapping_offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapMem_res, address) == 40, bad_kl_core_IO_MapMem_res_address_offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapMem_res, rc) == 48, bad_kl_core_IO_MapMem_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_MapMem_res */
typedef struct __nk_packed kl_core_IO_PermitPort_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
        } kl_core_IO_PermitPort_req;
nk_static_assert(sizeof(kl_core_IO_PermitPort_req) == 40, bad_kl_core_IO_PermitPort_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_PermitPort_req, base_) == 0, bad_kl_core_IO_PermitPort_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_PermitPort_req, resource) == 24, bad_kl_core_IO_PermitPort_req_resource_offset);
#pragma pack(push, 8) /* kl_core_IO_PermitPort_res */
typedef struct kl_core_IO_PermitPort_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_PermitPort_err;
nk_static_assert(sizeof(kl_core_IO_PermitPort_err) == 24, bad_kl_core_IO_PermitPort_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_PermitPort_err, base_) == 0, bad_kl_core_IO_PermitPort_err_base__offset);
typedef struct kl_core_IO_PermitPort_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t access;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t access;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_PermitPort_err err_;
            };
        } kl_core_IO_PermitPort_res;
nk_static_assert(sizeof(kl_core_IO_PermitPort_res) == 48, bad_kl_core_IO_PermitPort_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_PermitPort_res, base_) == 0, bad_kl_core_IO_PermitPort_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_PermitPort_res, access) == 24, bad_kl_core_IO_PermitPort_res_access_offset);
nk_static_assert(nk_offsetof(kl_core_IO_PermitPort_res, rc) == 40, bad_kl_core_IO_PermitPort_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_PermitPort_res */
typedef struct __nk_packed kl_core_IO_AttachIrq_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
            __nk_alignas(4) nk_uint32_t flags;
        } kl_core_IO_AttachIrq_req;
nk_static_assert(sizeof(kl_core_IO_AttachIrq_req) == 48, bad_kl_core_IO_AttachIrq_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_AttachIrq_req, base_) == 0, bad_kl_core_IO_AttachIrq_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_AttachIrq_req, resource) == 24, bad_kl_core_IO_AttachIrq_req_resource_offset);
nk_static_assert(nk_offsetof(kl_core_IO_AttachIrq_req, flags) == 40, bad_kl_core_IO_AttachIrq_req_flags_offset);
#pragma pack(push, 8) /* kl_core_IO_AttachIrq_res */
typedef struct kl_core_IO_AttachIrq_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_AttachIrq_err;
nk_static_assert(sizeof(kl_core_IO_AttachIrq_err) == 24, bad_kl_core_IO_AttachIrq_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_AttachIrq_err, base_) == 0, bad_kl_core_IO_AttachIrq_err_base__offset);
typedef struct kl_core_IO_AttachIrq_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t delivery;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t delivery;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_AttachIrq_err err_;
            };
        } kl_core_IO_AttachIrq_res;
nk_static_assert(sizeof(kl_core_IO_AttachIrq_res) == 48, bad_kl_core_IO_AttachIrq_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_AttachIrq_res, base_) == 0, bad_kl_core_IO_AttachIrq_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_AttachIrq_res, delivery) == 24, bad_kl_core_IO_AttachIrq_res_delivery_offset);
nk_static_assert(nk_offsetof(kl_core_IO_AttachIrq_res, rc) == 40, bad_kl_core_IO_AttachIrq_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_AttachIrq_res */
typedef struct __nk_packed kl_core_IO_DetachIrq_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
        } kl_core_IO_DetachIrq_req;
nk_static_assert(sizeof(kl_core_IO_DetachIrq_req) == 40, bad_kl_core_IO_DetachIrq_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_DetachIrq_req, base_) == 0, bad_kl_core_IO_DetachIrq_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_DetachIrq_req, resource) == 24, bad_kl_core_IO_DetachIrq_req_resource_offset);
#pragma pack(push, 8) /* kl_core_IO_DetachIrq_res */
typedef struct kl_core_IO_DetachIrq_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_DetachIrq_err;
nk_static_assert(sizeof(kl_core_IO_DetachIrq_err) == 24, bad_kl_core_IO_DetachIrq_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_DetachIrq_err, base_) == 0, bad_kl_core_IO_DetachIrq_err_base__offset);
typedef struct kl_core_IO_DetachIrq_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_DetachIrq_err err_;
            };
        } kl_core_IO_DetachIrq_res;
nk_static_assert(sizeof(kl_core_IO_DetachIrq_res) == 32, bad_kl_core_IO_DetachIrq_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_DetachIrq_res, base_) == 0, bad_kl_core_IO_DetachIrq_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_DetachIrq_res, rc) == 24, bad_kl_core_IO_DetachIrq_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_DetachIrq_res */
typedef struct __nk_packed kl_core_IO_EnableIrq_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
        } kl_core_IO_EnableIrq_req;
nk_static_assert(sizeof(kl_core_IO_EnableIrq_req) == 40, bad_kl_core_IO_EnableIrq_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_EnableIrq_req, base_) == 0, bad_kl_core_IO_EnableIrq_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_EnableIrq_req, resource) == 24, bad_kl_core_IO_EnableIrq_req_resource_offset);
#pragma pack(push, 8) /* kl_core_IO_EnableIrq_res */
typedef struct kl_core_IO_EnableIrq_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_EnableIrq_err;
nk_static_assert(sizeof(kl_core_IO_EnableIrq_err) == 24, bad_kl_core_IO_EnableIrq_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_EnableIrq_err, base_) == 0, bad_kl_core_IO_EnableIrq_err_base__offset);
typedef struct kl_core_IO_EnableIrq_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_EnableIrq_err err_;
            };
        } kl_core_IO_EnableIrq_res;
nk_static_assert(sizeof(kl_core_IO_EnableIrq_res) == 32, bad_kl_core_IO_EnableIrq_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_EnableIrq_res, base_) == 0, bad_kl_core_IO_EnableIrq_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_EnableIrq_res, rc) == 24, bad_kl_core_IO_EnableIrq_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_EnableIrq_res */
typedef struct __nk_packed kl_core_IO_DisableIrq_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
        } kl_core_IO_DisableIrq_req;
nk_static_assert(sizeof(kl_core_IO_DisableIrq_req) == 40, bad_kl_core_IO_DisableIrq_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_DisableIrq_req, base_) == 0, bad_kl_core_IO_DisableIrq_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_DisableIrq_req, resource) == 24, bad_kl_core_IO_DisableIrq_req_resource_offset);
#pragma pack(push, 8) /* kl_core_IO_DisableIrq_res */
typedef struct kl_core_IO_DisableIrq_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_DisableIrq_err;
nk_static_assert(sizeof(kl_core_IO_DisableIrq_err) == 24, bad_kl_core_IO_DisableIrq_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_DisableIrq_err, base_) == 0, bad_kl_core_IO_DisableIrq_err_base__offset);
typedef struct kl_core_IO_DisableIrq_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_DisableIrq_err err_;
            };
        } kl_core_IO_DisableIrq_res;
nk_static_assert(sizeof(kl_core_IO_DisableIrq_res) == 32, bad_kl_core_IO_DisableIrq_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_DisableIrq_res, base_) == 0, bad_kl_core_IO_DisableIrq_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_DisableIrq_res, rc) == 24, bad_kl_core_IO_DisableIrq_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_DisableIrq_res */
typedef struct __nk_packed kl_core_IO_ModifyDma_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
            __nk_alignas(4) nk_uint32_t flags;
        } kl_core_IO_ModifyDma_req;
nk_static_assert(sizeof(kl_core_IO_ModifyDma_req) == 48, bad_kl_core_IO_ModifyDma_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_ModifyDma_req, base_) == 0, bad_kl_core_IO_ModifyDma_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_ModifyDma_req, resource) == 24, bad_kl_core_IO_ModifyDma_req_resource_offset);
nk_static_assert(nk_offsetof(kl_core_IO_ModifyDma_req, flags) == 40, bad_kl_core_IO_ModifyDma_req_flags_offset);
#pragma pack(push, 8) /* kl_core_IO_ModifyDma_res */
typedef struct kl_core_IO_ModifyDma_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_ModifyDma_err;
nk_static_assert(sizeof(kl_core_IO_ModifyDma_err) == 24, bad_kl_core_IO_ModifyDma_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_ModifyDma_err, base_) == 0, bad_kl_core_IO_ModifyDma_err_base__offset);
typedef struct kl_core_IO_ModifyDma_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_ModifyDma_err err_;
            };
        } kl_core_IO_ModifyDma_res;
nk_static_assert(sizeof(kl_core_IO_ModifyDma_res) == 32, bad_kl_core_IO_ModifyDma_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_ModifyDma_res, base_) == 0, bad_kl_core_IO_ModifyDma_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_ModifyDma_res, rc) == 24, bad_kl_core_IO_ModifyDma_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_ModifyDma_res */
typedef struct __nk_packed kl_core_IO_MapDma_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
            __nk_alignas(8) nk_uint64_t offset;
            __nk_alignas(8) nk_uint64_t length;
            __nk_alignas(8) nk_uint64_t hint;
            __nk_alignas(4) nk_uint32_t prot;
        } kl_core_IO_MapDma_req;
nk_static_assert(sizeof(kl_core_IO_MapDma_req) == 72, bad_kl_core_IO_MapDma_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_MapDma_req, base_) == 0, bad_kl_core_IO_MapDma_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapDma_req, resource) == 24, bad_kl_core_IO_MapDma_req_resource_offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapDma_req, offset) == 40, bad_kl_core_IO_MapDma_req_offset_offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapDma_req, length) == 48, bad_kl_core_IO_MapDma_req_length_offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapDma_req, hint) == 56, bad_kl_core_IO_MapDma_req_hint_offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapDma_req, prot) == 64, bad_kl_core_IO_MapDma_req_prot_offset);
#pragma pack(push, 8) /* kl_core_IO_MapDma_res */
typedef struct kl_core_IO_MapDma_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_MapDma_err;
nk_static_assert(sizeof(kl_core_IO_MapDma_err) == 24, bad_kl_core_IO_MapDma_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_MapDma_err, base_) == 0, bad_kl_core_IO_MapDma_err_base__offset);
typedef struct kl_core_IO_MapDma_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t mapping;
                    __nk_alignas(8)
                    nk_uint64_t address;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t mapping;
                    __nk_alignas(8)
                    nk_uint64_t address;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_MapDma_err err_;
            };
        } kl_core_IO_MapDma_res;
nk_static_assert(sizeof(kl_core_IO_MapDma_res) == 56, bad_kl_core_IO_MapDma_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_MapDma_res, base_) == 0, bad_kl_core_IO_MapDma_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapDma_res, mapping) == 24, bad_kl_core_IO_MapDma_res_mapping_offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapDma_res, address) == 40, bad_kl_core_IO_MapDma_res_address_offset);
nk_static_assert(nk_offsetof(kl_core_IO_MapDma_res, rc) == 48, bad_kl_core_IO_MapDma_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_MapDma_res */
typedef struct __nk_packed kl_core_IO_DmaGetInfo_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
        } kl_core_IO_DmaGetInfo_req;
nk_static_assert(sizeof(kl_core_IO_DmaGetInfo_req) == 40, bad_kl_core_IO_DmaGetInfo_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetInfo_req, base_) == 0, bad_kl_core_IO_DmaGetInfo_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetInfo_req, resource) == 24, bad_kl_core_IO_DmaGetInfo_req_resource_offset);
#pragma pack(push, 8) /* kl_core_IO_DmaGetInfo_res */
typedef struct kl_core_IO_DmaGetInfo_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_DmaGetInfo_err;
nk_static_assert(sizeof(kl_core_IO_DmaGetInfo_err) == 24, bad_kl_core_IO_DmaGetInfo_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetInfo_err, base_) == 0, bad_kl_core_IO_DmaGetInfo_err_base__offset);
typedef struct kl_core_IO_DmaGetInfo_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t flags;
                    __nk_alignas(8)
                    nk_uint64_t order;
                    __nk_alignas(8)
                    nk_uint64_t size;
                    __nk_alignas(8)
                    nk_uint64_t count;
                    __nk_alignas(4)
                    nk_ptr_t frames;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t flags;
                    __nk_alignas(8)
                    nk_uint64_t order;
                    __nk_alignas(8)
                    nk_uint64_t size;
                    __nk_alignas(8)
                    nk_uint64_t count;
                    __nk_alignas(4)
                    nk_ptr_t frames;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_DmaGetInfo_err err_;
            };
        } kl_core_IO_DmaGetInfo_res;
nk_static_assert(sizeof(kl_core_IO_DmaGetInfo_res) == 72, bad_kl_core_IO_DmaGetInfo_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetInfo_res, base_) == 0, bad_kl_core_IO_DmaGetInfo_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetInfo_res, flags) == 24, bad_kl_core_IO_DmaGetInfo_res_flags_offset);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetInfo_res, order) == 32, bad_kl_core_IO_DmaGetInfo_res_order_offset);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetInfo_res, size) == 40, bad_kl_core_IO_DmaGetInfo_res_size_offset);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetInfo_res, count) == 48, bad_kl_core_IO_DmaGetInfo_res_count_offset);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetInfo_res, frames) == 56, bad_kl_core_IO_DmaGetInfo_res_frames_offset);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetInfo_res, rc) == 64, bad_kl_core_IO_DmaGetInfo_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_DmaGetInfo_res */
typedef struct __nk_packed kl_core_IO_DmaGetPhysInfo_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
        } kl_core_IO_DmaGetPhysInfo_req;
nk_static_assert(sizeof(kl_core_IO_DmaGetPhysInfo_req) == 40, bad_kl_core_IO_DmaGetPhysInfo_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetPhysInfo_req, base_) == 0, bad_kl_core_IO_DmaGetPhysInfo_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetPhysInfo_req, handle) == 24, bad_kl_core_IO_DmaGetPhysInfo_req_handle_offset);
#pragma pack(push, 8) /* kl_core_IO_DmaGetPhysInfo_res */
typedef struct kl_core_IO_DmaGetPhysInfo_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_DmaGetPhysInfo_err;
nk_static_assert(sizeof(kl_core_IO_DmaGetPhysInfo_err) == 24, bad_kl_core_IO_DmaGetPhysInfo_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetPhysInfo_err, base_) == 0, bad_kl_core_IO_DmaGetPhysInfo_err_base__offset);
typedef struct kl_core_IO_DmaGetPhysInfo_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t count;
                    __nk_alignas(4)
                    nk_ptr_t frames;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t count;
                    __nk_alignas(4)
                    nk_ptr_t frames;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_DmaGetPhysInfo_err err_;
            };
        } kl_core_IO_DmaGetPhysInfo_res;
nk_static_assert(sizeof(kl_core_IO_DmaGetPhysInfo_res) == 48, bad_kl_core_IO_DmaGetPhysInfo_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetPhysInfo_res, base_) == 0, bad_kl_core_IO_DmaGetPhysInfo_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetPhysInfo_res, count) == 24, bad_kl_core_IO_DmaGetPhysInfo_res_count_offset);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetPhysInfo_res, frames) == 32, bad_kl_core_IO_DmaGetPhysInfo_res_frames_offset);
nk_static_assert(nk_offsetof(kl_core_IO_DmaGetPhysInfo_res, rc) == 40, bad_kl_core_IO_DmaGetPhysInfo_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_DmaGetPhysInfo_res */
typedef struct __nk_packed kl_core_IO_BeginDma_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t resource;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t domain;
        } kl_core_IO_BeginDma_req;
nk_static_assert(sizeof(kl_core_IO_BeginDma_req) == 56, bad_kl_core_IO_BeginDma_req_size);
nk_static_assert(nk_offsetof(kl_core_IO_BeginDma_req, base_) == 0, bad_kl_core_IO_BeginDma_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_BeginDma_req, resource) == 24, bad_kl_core_IO_BeginDma_req_resource_offset);
nk_static_assert(nk_offsetof(kl_core_IO_BeginDma_req, domain) == 40, bad_kl_core_IO_BeginDma_req_domain_offset);
#pragma pack(push, 8) /* kl_core_IO_BeginDma_res */
typedef struct kl_core_IO_BeginDma_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IO_BeginDma_err;
nk_static_assert(sizeof(kl_core_IO_BeginDma_err) == 24, bad_kl_core_IO_BeginDma_err_size);
nk_static_assert(nk_offsetof(kl_core_IO_BeginDma_err, base_) == 0, bad_kl_core_IO_BeginDma_err_base__offset);
typedef struct kl_core_IO_BeginDma_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t iomapping;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t iomapping;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IO_BeginDma_err err_;
            };
        } kl_core_IO_BeginDma_res;
nk_static_assert(sizeof(kl_core_IO_BeginDma_res) == 48, bad_kl_core_IO_BeginDma_res_size);
nk_static_assert(nk_offsetof(kl_core_IO_BeginDma_res, base_) == 0, bad_kl_core_IO_BeginDma_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IO_BeginDma_res, iomapping) == 24, bad_kl_core_IO_BeginDma_res_iomapping_offset);
nk_static_assert(nk_offsetof(kl_core_IO_BeginDma_res, rc) == 40, bad_kl_core_IO_BeginDma_res_rc_offset);
#pragma pack(pop) /* kl_core_IO_BeginDma_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define IO_RegisterPort_mid kl_core_IO_RegisterPort_mid
#define IO_RegisterMmio_mid kl_core_IO_RegisterMmio_mid
#define IO_RegisterDma_mid kl_core_IO_RegisterDma_mid
#define IO_RegisterIrq_mid kl_core_IO_RegisterIrq_mid
#define IO_RevokeResource_mid kl_core_IO_RevokeResource_mid
#define IO_MapMem_mid kl_core_IO_MapMem_mid
#define IO_PermitPort_mid kl_core_IO_PermitPort_mid
#define IO_AttachIrq_mid kl_core_IO_AttachIrq_mid
#define IO_DetachIrq_mid kl_core_IO_DetachIrq_mid
#define IO_EnableIrq_mid kl_core_IO_EnableIrq_mid
#define IO_DisableIrq_mid kl_core_IO_DisableIrq_mid
#define IO_ModifyDma_mid kl_core_IO_ModifyDma_mid
#define IO_MapDma_mid kl_core_IO_MapDma_mid
#define IO_DmaGetInfo_mid kl_core_IO_DmaGetInfo_mid
#define IO_DmaGetPhysInfo_mid kl_core_IO_DmaGetPhysInfo_mid
#define IO_BeginDma_mid kl_core_IO_BeginDma_mid
#define IO_mid_max kl_core_IO_mid_max
#define IO_RegisterPort_req_arena_size kl_core_IO_RegisterPort_req_arena_size
#define IO_RegisterPort_res_arena_size kl_core_IO_RegisterPort_res_arena_size
#define IO_RegisterPort_req_handles kl_core_IO_RegisterPort_req_handles
#define IO_RegisterPort_res_handles kl_core_IO_RegisterPort_res_handles
#define IO_RegisterPort_err_handles kl_core_IO_RegisterPort_err_handles
#define IO_RegisterMmio_req_arena_size kl_core_IO_RegisterMmio_req_arena_size
#define IO_RegisterMmio_res_arena_size kl_core_IO_RegisterMmio_res_arena_size
#define IO_RegisterMmio_req_handles kl_core_IO_RegisterMmio_req_handles
#define IO_RegisterMmio_res_handles kl_core_IO_RegisterMmio_res_handles
#define IO_RegisterMmio_err_handles kl_core_IO_RegisterMmio_err_handles
#define IO_RegisterDma_req_arena_size kl_core_IO_RegisterDma_req_arena_size
#define IO_RegisterDma_res_arena_size kl_core_IO_RegisterDma_res_arena_size
#define IO_RegisterDma_req_handles kl_core_IO_RegisterDma_req_handles
#define IO_RegisterDma_res_handles kl_core_IO_RegisterDma_res_handles
#define IO_RegisterDma_err_handles kl_core_IO_RegisterDma_err_handles
#define IO_RegisterIrq_req_arena_size kl_core_IO_RegisterIrq_req_arena_size
#define IO_RegisterIrq_res_arena_size kl_core_IO_RegisterIrq_res_arena_size
#define IO_RegisterIrq_req_handles kl_core_IO_RegisterIrq_req_handles
#define IO_RegisterIrq_res_handles kl_core_IO_RegisterIrq_res_handles
#define IO_RegisterIrq_err_handles kl_core_IO_RegisterIrq_err_handles
#define IO_RevokeResource_req_arena_size kl_core_IO_RevokeResource_req_arena_size
#define IO_RevokeResource_res_arena_size kl_core_IO_RevokeResource_res_arena_size
#define IO_RevokeResource_req_handles kl_core_IO_RevokeResource_req_handles
#define IO_RevokeResource_res_handles kl_core_IO_RevokeResource_res_handles
#define IO_RevokeResource_err_handles kl_core_IO_RevokeResource_err_handles
#define IO_MapMem_req_arena_size kl_core_IO_MapMem_req_arena_size
#define IO_MapMem_res_arena_size kl_core_IO_MapMem_res_arena_size
#define IO_MapMem_req_handles kl_core_IO_MapMem_req_handles
#define IO_MapMem_res_handles kl_core_IO_MapMem_res_handles
#define IO_MapMem_err_handles kl_core_IO_MapMem_err_handles
#define IO_PermitPort_req_arena_size kl_core_IO_PermitPort_req_arena_size
#define IO_PermitPort_res_arena_size kl_core_IO_PermitPort_res_arena_size
#define IO_PermitPort_req_handles kl_core_IO_PermitPort_req_handles
#define IO_PermitPort_res_handles kl_core_IO_PermitPort_res_handles
#define IO_PermitPort_err_handles kl_core_IO_PermitPort_err_handles
#define IO_AttachIrq_req_arena_size kl_core_IO_AttachIrq_req_arena_size
#define IO_AttachIrq_res_arena_size kl_core_IO_AttachIrq_res_arena_size
#define IO_AttachIrq_req_handles kl_core_IO_AttachIrq_req_handles
#define IO_AttachIrq_res_handles kl_core_IO_AttachIrq_res_handles
#define IO_AttachIrq_err_handles kl_core_IO_AttachIrq_err_handles
#define IO_DetachIrq_req_arena_size kl_core_IO_DetachIrq_req_arena_size
#define IO_DetachIrq_res_arena_size kl_core_IO_DetachIrq_res_arena_size
#define IO_DetachIrq_req_handles kl_core_IO_DetachIrq_req_handles
#define IO_DetachIrq_res_handles kl_core_IO_DetachIrq_res_handles
#define IO_DetachIrq_err_handles kl_core_IO_DetachIrq_err_handles
#define IO_EnableIrq_req_arena_size kl_core_IO_EnableIrq_req_arena_size
#define IO_EnableIrq_res_arena_size kl_core_IO_EnableIrq_res_arena_size
#define IO_EnableIrq_req_handles kl_core_IO_EnableIrq_req_handles
#define IO_EnableIrq_res_handles kl_core_IO_EnableIrq_res_handles
#define IO_EnableIrq_err_handles kl_core_IO_EnableIrq_err_handles
#define IO_DisableIrq_req_arena_size kl_core_IO_DisableIrq_req_arena_size
#define IO_DisableIrq_res_arena_size kl_core_IO_DisableIrq_res_arena_size
#define IO_DisableIrq_req_handles kl_core_IO_DisableIrq_req_handles
#define IO_DisableIrq_res_handles kl_core_IO_DisableIrq_res_handles
#define IO_DisableIrq_err_handles kl_core_IO_DisableIrq_err_handles
#define IO_ModifyDma_req_arena_size kl_core_IO_ModifyDma_req_arena_size
#define IO_ModifyDma_res_arena_size kl_core_IO_ModifyDma_res_arena_size
#define IO_ModifyDma_req_handles kl_core_IO_ModifyDma_req_handles
#define IO_ModifyDma_res_handles kl_core_IO_ModifyDma_res_handles
#define IO_ModifyDma_err_handles kl_core_IO_ModifyDma_err_handles
#define IO_MapDma_req_arena_size kl_core_IO_MapDma_req_arena_size
#define IO_MapDma_res_arena_size kl_core_IO_MapDma_res_arena_size
#define IO_MapDma_req_handles kl_core_IO_MapDma_req_handles
#define IO_MapDma_res_handles kl_core_IO_MapDma_res_handles
#define IO_MapDma_err_handles kl_core_IO_MapDma_err_handles
#define IO_DmaGetInfo_res_frames_size kl_core_IO_DmaGetInfo_res_frames_size
#define IO_DmaGetInfo_req_arena_size kl_core_IO_DmaGetInfo_req_arena_size
#define IO_DmaGetInfo_res_arena_size kl_core_IO_DmaGetInfo_res_arena_size
#define IO_DmaGetInfo_req_handles kl_core_IO_DmaGetInfo_req_handles
#define IO_DmaGetInfo_res_handles kl_core_IO_DmaGetInfo_res_handles
#define IO_DmaGetInfo_err_handles kl_core_IO_DmaGetInfo_err_handles
#define IO_DmaGetPhysInfo_res_frames_size kl_core_IO_DmaGetPhysInfo_res_frames_size
#define IO_DmaGetPhysInfo_req_arena_size kl_core_IO_DmaGetPhysInfo_req_arena_size
#define IO_DmaGetPhysInfo_res_arena_size kl_core_IO_DmaGetPhysInfo_res_arena_size
#define IO_DmaGetPhysInfo_req_handles kl_core_IO_DmaGetPhysInfo_req_handles
#define IO_DmaGetPhysInfo_res_handles kl_core_IO_DmaGetPhysInfo_res_handles
#define IO_DmaGetPhysInfo_err_handles kl_core_IO_DmaGetPhysInfo_err_handles
#define IO_BeginDma_req_arena_size kl_core_IO_BeginDma_req_arena_size
#define IO_BeginDma_res_arena_size kl_core_IO_BeginDma_res_arena_size
#define IO_BeginDma_req_handles kl_core_IO_BeginDma_req_handles
#define IO_BeginDma_res_handles kl_core_IO_BeginDma_res_handles
#define IO_BeginDma_err_handles kl_core_IO_BeginDma_err_handles
#define IO_req_arena_size kl_core_IO_req_arena_size
#define IO_res_arena_size kl_core_IO_res_arena_size
#define IO_req_handles kl_core_IO_req_handles
#define IO_res_handles kl_core_IO_res_handles
#define IO_err_handles kl_core_IO_err_handles
#define IO_RegisterPort_req kl_core_IO_RegisterPort_req
#define IO_RegisterPort_res kl_core_IO_RegisterPort_res
#define IO_RegisterMmio_req kl_core_IO_RegisterMmio_req
#define IO_RegisterMmio_res kl_core_IO_RegisterMmio_res
#define IO_RegisterDma_req kl_core_IO_RegisterDma_req
#define IO_RegisterDma_res kl_core_IO_RegisterDma_res
#define IO_RegisterIrq_req kl_core_IO_RegisterIrq_req
#define IO_RegisterIrq_res kl_core_IO_RegisterIrq_res
#define IO_RevokeResource_req kl_core_IO_RevokeResource_req
#define IO_RevokeResource_res kl_core_IO_RevokeResource_res
#define IO_MapMem_req kl_core_IO_MapMem_req
#define IO_MapMem_res kl_core_IO_MapMem_res
#define IO_PermitPort_req kl_core_IO_PermitPort_req
#define IO_PermitPort_res kl_core_IO_PermitPort_res
#define IO_AttachIrq_req kl_core_IO_AttachIrq_req
#define IO_AttachIrq_res kl_core_IO_AttachIrq_res
#define IO_DetachIrq_req kl_core_IO_DetachIrq_req
#define IO_DetachIrq_res kl_core_IO_DetachIrq_res
#define IO_EnableIrq_req kl_core_IO_EnableIrq_req
#define IO_EnableIrq_res kl_core_IO_EnableIrq_res
#define IO_DisableIrq_req kl_core_IO_DisableIrq_req
#define IO_DisableIrq_res kl_core_IO_DisableIrq_res
#define IO_ModifyDma_req kl_core_IO_ModifyDma_req
#define IO_ModifyDma_res kl_core_IO_ModifyDma_res
#define IO_MapDma_req kl_core_IO_MapDma_req
#define IO_MapDma_res kl_core_IO_MapDma_res
#define IO_DmaGetInfo_req kl_core_IO_DmaGetInfo_req
#define IO_DmaGetInfo_res kl_core_IO_DmaGetInfo_res
#define IO_DmaGetPhysInfo_req kl_core_IO_DmaGetPhysInfo_req
#define IO_DmaGetPhysInfo_res kl_core_IO_DmaGetPhysInfo_res
#define IO_BeginDma_req kl_core_IO_BeginDma_req
#define IO_BeginDma_res kl_core_IO_BeginDma_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__IO__INTERFACE__ */

#ifndef __kl_core__IPC__INTERFACE__
#define __kl_core__IPC__INTERFACE__
enum {
    kl_core_IPC_CreateSyncObject_mid,
    kl_core_IPC_SetInterrupt_mid,
    kl_core_IPC_ClearInterrupt_mid,
    kl_core_IPC_mid_max,
};
enum {
    kl_core_IPC_CreateSyncObject_req_arena_size =
    0,
    kl_core_IPC_CreateSyncObject_res_arena_size =
    0,
    kl_core_IPC_CreateSyncObject_req_handles = 0,
    kl_core_IPC_CreateSyncObject_res_handles = 1,
    kl_core_IPC_CreateSyncObject_err_handles = 0,
    kl_core_IPC_SetInterrupt_req_arena_size = 0,
    kl_core_IPC_SetInterrupt_res_arena_size = 0,
    kl_core_IPC_SetInterrupt_req_handles = 1,
    kl_core_IPC_SetInterrupt_res_handles = 0,
    kl_core_IPC_SetInterrupt_err_handles = 0,
    kl_core_IPC_ClearInterrupt_req_arena_size = 0,
    kl_core_IPC_ClearInterrupt_res_arena_size = 0,
    kl_core_IPC_ClearInterrupt_req_handles = 1,
    kl_core_IPC_ClearInterrupt_res_handles = 0,
    kl_core_IPC_ClearInterrupt_err_handles = 0,
    kl_core_IPC_req_arena_size = 0,
    kl_core_IPC_res_arena_size = 0,
    kl_core_IPC_req_handles = 1,
    kl_core_IPC_res_handles = 1,
    kl_core_IPC_err_handles = 0,
};
typedef struct __nk_packed kl_core_IPC_CreateSyncObject_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IPC_CreateSyncObject_req;
nk_static_assert(sizeof(kl_core_IPC_CreateSyncObject_req) == 24, bad_kl_core_IPC_CreateSyncObject_req_size);
nk_static_assert(nk_offsetof(kl_core_IPC_CreateSyncObject_req, base_) == 0, bad_kl_core_IPC_CreateSyncObject_req_base__offset);
#pragma pack(push, 8) /* kl_core_IPC_CreateSyncObject_res */
typedef struct kl_core_IPC_CreateSyncObject_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IPC_CreateSyncObject_err;
nk_static_assert(sizeof(kl_core_IPC_CreateSyncObject_err) == 24, bad_kl_core_IPC_CreateSyncObject_err_size);
nk_static_assert(nk_offsetof(kl_core_IPC_CreateSyncObject_err, base_) == 0, bad_kl_core_IPC_CreateSyncObject_err_base__offset);
typedef struct kl_core_IPC_CreateSyncObject_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t syncHandle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t syncHandle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IPC_CreateSyncObject_err err_;
            };
        } kl_core_IPC_CreateSyncObject_res;
nk_static_assert(sizeof(kl_core_IPC_CreateSyncObject_res) == 48, bad_kl_core_IPC_CreateSyncObject_res_size);
nk_static_assert(nk_offsetof(kl_core_IPC_CreateSyncObject_res, base_) == 0, bad_kl_core_IPC_CreateSyncObject_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IPC_CreateSyncObject_res, syncHandle) == 24, bad_kl_core_IPC_CreateSyncObject_res_syncHandle_offset);
nk_static_assert(nk_offsetof(kl_core_IPC_CreateSyncObject_res, rc) == 40, bad_kl_core_IPC_CreateSyncObject_res_rc_offset);
#pragma pack(pop) /* kl_core_IPC_CreateSyncObject_res */
typedef struct __nk_packed kl_core_IPC_SetInterrupt_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t syncHandle;
        } kl_core_IPC_SetInterrupt_req;
nk_static_assert(sizeof(kl_core_IPC_SetInterrupt_req) == 40, bad_kl_core_IPC_SetInterrupt_req_size);
nk_static_assert(nk_offsetof(kl_core_IPC_SetInterrupt_req, base_) == 0, bad_kl_core_IPC_SetInterrupt_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IPC_SetInterrupt_req, syncHandle) == 24, bad_kl_core_IPC_SetInterrupt_req_syncHandle_offset);
#pragma pack(push, 8) /* kl_core_IPC_SetInterrupt_res */
typedef struct kl_core_IPC_SetInterrupt_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IPC_SetInterrupt_err;
nk_static_assert(sizeof(kl_core_IPC_SetInterrupt_err) == 24, bad_kl_core_IPC_SetInterrupt_err_size);
nk_static_assert(nk_offsetof(kl_core_IPC_SetInterrupt_err, base_) == 0, bad_kl_core_IPC_SetInterrupt_err_base__offset);
typedef struct kl_core_IPC_SetInterrupt_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IPC_SetInterrupt_err err_;
            };
        } kl_core_IPC_SetInterrupt_res;
nk_static_assert(sizeof(kl_core_IPC_SetInterrupt_res) == 32, bad_kl_core_IPC_SetInterrupt_res_size);
nk_static_assert(nk_offsetof(kl_core_IPC_SetInterrupt_res, base_) == 0, bad_kl_core_IPC_SetInterrupt_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IPC_SetInterrupt_res, rc) == 24, bad_kl_core_IPC_SetInterrupt_res_rc_offset);
#pragma pack(pop) /* kl_core_IPC_SetInterrupt_res */
typedef struct __nk_packed kl_core_IPC_ClearInterrupt_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t syncHandle;
        } kl_core_IPC_ClearInterrupt_req;
nk_static_assert(sizeof(kl_core_IPC_ClearInterrupt_req) == 40, bad_kl_core_IPC_ClearInterrupt_req_size);
nk_static_assert(nk_offsetof(kl_core_IPC_ClearInterrupt_req, base_) == 0, bad_kl_core_IPC_ClearInterrupt_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_IPC_ClearInterrupt_req, syncHandle) == 24, bad_kl_core_IPC_ClearInterrupt_req_syncHandle_offset);
#pragma pack(push, 8) /* kl_core_IPC_ClearInterrupt_res */
typedef struct kl_core_IPC_ClearInterrupt_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_IPC_ClearInterrupt_err;
nk_static_assert(sizeof(kl_core_IPC_ClearInterrupt_err) == 24, bad_kl_core_IPC_ClearInterrupt_err_size);
nk_static_assert(nk_offsetof(kl_core_IPC_ClearInterrupt_err, base_) == 0, bad_kl_core_IPC_ClearInterrupt_err_base__offset);
typedef struct kl_core_IPC_ClearInterrupt_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_IPC_ClearInterrupt_err err_;
            };
        } kl_core_IPC_ClearInterrupt_res;
nk_static_assert(sizeof(kl_core_IPC_ClearInterrupt_res) == 32, bad_kl_core_IPC_ClearInterrupt_res_size);
nk_static_assert(nk_offsetof(kl_core_IPC_ClearInterrupt_res, base_) == 0, bad_kl_core_IPC_ClearInterrupt_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_IPC_ClearInterrupt_res, rc) == 24, bad_kl_core_IPC_ClearInterrupt_res_rc_offset);
#pragma pack(pop) /* kl_core_IPC_ClearInterrupt_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define IPC_CreateSyncObject_mid kl_core_IPC_CreateSyncObject_mid
#define IPC_SetInterrupt_mid kl_core_IPC_SetInterrupt_mid
#define IPC_ClearInterrupt_mid kl_core_IPC_ClearInterrupt_mid
#define IPC_mid_max kl_core_IPC_mid_max
#define IPC_CreateSyncObject_req_arena_size kl_core_IPC_CreateSyncObject_req_arena_size
#define IPC_CreateSyncObject_res_arena_size kl_core_IPC_CreateSyncObject_res_arena_size
#define IPC_CreateSyncObject_req_handles kl_core_IPC_CreateSyncObject_req_handles
#define IPC_CreateSyncObject_res_handles kl_core_IPC_CreateSyncObject_res_handles
#define IPC_CreateSyncObject_err_handles kl_core_IPC_CreateSyncObject_err_handles
#define IPC_SetInterrupt_req_arena_size kl_core_IPC_SetInterrupt_req_arena_size
#define IPC_SetInterrupt_res_arena_size kl_core_IPC_SetInterrupt_res_arena_size
#define IPC_SetInterrupt_req_handles kl_core_IPC_SetInterrupt_req_handles
#define IPC_SetInterrupt_res_handles kl_core_IPC_SetInterrupt_res_handles
#define IPC_SetInterrupt_err_handles kl_core_IPC_SetInterrupt_err_handles
#define IPC_ClearInterrupt_req_arena_size kl_core_IPC_ClearInterrupt_req_arena_size
#define IPC_ClearInterrupt_res_arena_size kl_core_IPC_ClearInterrupt_res_arena_size
#define IPC_ClearInterrupt_req_handles kl_core_IPC_ClearInterrupt_req_handles
#define IPC_ClearInterrupt_res_handles kl_core_IPC_ClearInterrupt_res_handles
#define IPC_ClearInterrupt_err_handles kl_core_IPC_ClearInterrupt_err_handles
#define IPC_req_arena_size kl_core_IPC_req_arena_size
#define IPC_res_arena_size kl_core_IPC_res_arena_size
#define IPC_req_handles kl_core_IPC_req_handles
#define IPC_res_handles kl_core_IPC_res_handles
#define IPC_err_handles kl_core_IPC_err_handles
#define IPC_CreateSyncObject_req kl_core_IPC_CreateSyncObject_req
#define IPC_CreateSyncObject_res kl_core_IPC_CreateSyncObject_res
#define IPC_SetInterrupt_req kl_core_IPC_SetInterrupt_req
#define IPC_SetInterrupt_res kl_core_IPC_SetInterrupt_res
#define IPC_ClearInterrupt_req kl_core_IPC_ClearInterrupt_req
#define IPC_ClearInterrupt_res kl_core_IPC_ClearInterrupt_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__IPC__INTERFACE__ */

#ifndef __kl_core__Log__INTERFACE__
#define __kl_core__Log__INTERFACE__
enum {
    kl_core_Log_Handoff_mid,
    kl_core_Log_FetchMessages_mid,
    kl_core_Log_GetMessagesHandle_mid,
    kl_core_Log_mid_max,
};
enum {
    kl_core_Log_Handoff_req_arena_size = 0,
    kl_core_Log_Handoff_res_arena_size = 0,
    kl_core_Log_Handoff_req_handles = 0,
    kl_core_Log_Handoff_res_handles = 0,
    kl_core_Log_Handoff_err_handles = 0,
    kl_core_Log_FetchMessages_res_data_size =
    65536,
    kl_core_Log_FetchMessages_req_arena_size = 0,
    kl_core_Log_FetchMessages_res_arena_size =
    65536,
    kl_core_Log_FetchMessages_req_handles = 0,
    kl_core_Log_FetchMessages_res_handles = 0,
    kl_core_Log_FetchMessages_err_handles = 0,
    kl_core_Log_GetMessagesHandle_req_arena_size =
    0,
    kl_core_Log_GetMessagesHandle_res_arena_size =
    0,
    kl_core_Log_GetMessagesHandle_req_handles = 0,
    kl_core_Log_GetMessagesHandle_res_handles = 1,
    kl_core_Log_GetMessagesHandle_err_handles = 0,
    kl_core_Log_req_arena_size = 0,
    kl_core_Log_res_arena_size = 65536,
    kl_core_Log_req_handles = 0,
    kl_core_Log_res_handles = 1,
    kl_core_Log_err_handles = 0,
};
typedef struct __nk_packed kl_core_Log_Handoff_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Log_Handoff_req;
nk_static_assert(sizeof(kl_core_Log_Handoff_req) == 24, bad_kl_core_Log_Handoff_req_size);
nk_static_assert(nk_offsetof(kl_core_Log_Handoff_req, base_) == 0, bad_kl_core_Log_Handoff_req_base__offset);
#pragma pack(push, 8) /* kl_core_Log_Handoff_res */
typedef struct kl_core_Log_Handoff_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Log_Handoff_err;
nk_static_assert(sizeof(kl_core_Log_Handoff_err) == 24, bad_kl_core_Log_Handoff_err_size);
nk_static_assert(nk_offsetof(kl_core_Log_Handoff_err, base_) == 0, bad_kl_core_Log_Handoff_err_base__offset);
typedef struct kl_core_Log_Handoff_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t bufSize;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t bufSize;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Log_Handoff_err err_;
            };
        } kl_core_Log_Handoff_res;
nk_static_assert(sizeof(kl_core_Log_Handoff_res) == 32, bad_kl_core_Log_Handoff_res_size);
nk_static_assert(nk_offsetof(kl_core_Log_Handoff_res, base_) == 0, bad_kl_core_Log_Handoff_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Log_Handoff_res, bufSize) == 24, bad_kl_core_Log_Handoff_res_bufSize_offset);
nk_static_assert(nk_offsetof(kl_core_Log_Handoff_res, rc) == 28, bad_kl_core_Log_Handoff_res_rc_offset);
#pragma pack(pop) /* kl_core_Log_Handoff_res */
typedef struct __nk_packed kl_core_Log_FetchMessages_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t size;
        } kl_core_Log_FetchMessages_req;
nk_static_assert(sizeof(kl_core_Log_FetchMessages_req) == 32, bad_kl_core_Log_FetchMessages_req_size);
nk_static_assert(nk_offsetof(kl_core_Log_FetchMessages_req, base_) == 0, bad_kl_core_Log_FetchMessages_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Log_FetchMessages_req, size) == 24, bad_kl_core_Log_FetchMessages_req_size_offset);
#pragma pack(push, 8) /* kl_core_Log_FetchMessages_res */
typedef struct kl_core_Log_FetchMessages_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Log_FetchMessages_err;
nk_static_assert(sizeof(kl_core_Log_FetchMessages_err) == 24, bad_kl_core_Log_FetchMessages_err_size);
nk_static_assert(nk_offsetof(kl_core_Log_FetchMessages_err, base_) == 0, bad_kl_core_Log_FetchMessages_err_base__offset);
typedef struct kl_core_Log_FetchMessages_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t data;
                    __nk_alignas(4)
                    nk_uint32_t writtenCount;
                    __nk_alignas(4)
                    nk_uint32_t droppedCount;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t data;
                    __nk_alignas(4)
                    nk_uint32_t writtenCount;
                    __nk_alignas(4)
                    nk_uint32_t droppedCount;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Log_FetchMessages_err err_;
            };
        } kl_core_Log_FetchMessages_res;
nk_static_assert(sizeof(kl_core_Log_FetchMessages_res) == 48, bad_kl_core_Log_FetchMessages_res_size);
nk_static_assert(nk_offsetof(kl_core_Log_FetchMessages_res, base_) == 0, bad_kl_core_Log_FetchMessages_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Log_FetchMessages_res, data) == 24, bad_kl_core_Log_FetchMessages_res_data_offset);
nk_static_assert(nk_offsetof(kl_core_Log_FetchMessages_res, writtenCount) == 32, bad_kl_core_Log_FetchMessages_res_writtenCount_offset);
nk_static_assert(nk_offsetof(kl_core_Log_FetchMessages_res, droppedCount) == 36, bad_kl_core_Log_FetchMessages_res_droppedCount_offset);
nk_static_assert(nk_offsetof(kl_core_Log_FetchMessages_res, rc) == 40, bad_kl_core_Log_FetchMessages_res_rc_offset);
#pragma pack(pop) /* kl_core_Log_FetchMessages_res */
typedef struct __nk_packed kl_core_Log_GetMessagesHandle_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t count;
            __nk_alignas(4) nk_uint32_t mdelay;
        } kl_core_Log_GetMessagesHandle_req;
nk_static_assert(sizeof(kl_core_Log_GetMessagesHandle_req) == 32, bad_kl_core_Log_GetMessagesHandle_req_size);
nk_static_assert(nk_offsetof(kl_core_Log_GetMessagesHandle_req, base_) == 0, bad_kl_core_Log_GetMessagesHandle_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Log_GetMessagesHandle_req, count) == 24, bad_kl_core_Log_GetMessagesHandle_req_count_offset);
nk_static_assert(nk_offsetof(kl_core_Log_GetMessagesHandle_req, mdelay) == 28, bad_kl_core_Log_GetMessagesHandle_req_mdelay_offset);
#pragma pack(push, 8) /* kl_core_Log_GetMessagesHandle_res */
typedef struct kl_core_Log_GetMessagesHandle_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Log_GetMessagesHandle_err;
nk_static_assert(sizeof(kl_core_Log_GetMessagesHandle_err) == 24, bad_kl_core_Log_GetMessagesHandle_err_size);
nk_static_assert(nk_offsetof(kl_core_Log_GetMessagesHandle_err, base_) == 0, bad_kl_core_Log_GetMessagesHandle_err_base__offset);
typedef struct kl_core_Log_GetMessagesHandle_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Log_GetMessagesHandle_err err_;
            };
        } kl_core_Log_GetMessagesHandle_res;
nk_static_assert(sizeof(kl_core_Log_GetMessagesHandle_res) == 48, bad_kl_core_Log_GetMessagesHandle_res_size);
nk_static_assert(nk_offsetof(kl_core_Log_GetMessagesHandle_res, base_) == 0, bad_kl_core_Log_GetMessagesHandle_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Log_GetMessagesHandle_res, handle) == 24, bad_kl_core_Log_GetMessagesHandle_res_handle_offset);
nk_static_assert(nk_offsetof(kl_core_Log_GetMessagesHandle_res, rc) == 40, bad_kl_core_Log_GetMessagesHandle_res_rc_offset);
#pragma pack(pop) /* kl_core_Log_GetMessagesHandle_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Log_Handoff_mid kl_core_Log_Handoff_mid
#define Log_FetchMessages_mid kl_core_Log_FetchMessages_mid
#define Log_GetMessagesHandle_mid kl_core_Log_GetMessagesHandle_mid
#define Log_mid_max kl_core_Log_mid_max
#define Log_Handoff_req_arena_size kl_core_Log_Handoff_req_arena_size
#define Log_Handoff_res_arena_size kl_core_Log_Handoff_res_arena_size
#define Log_Handoff_req_handles kl_core_Log_Handoff_req_handles
#define Log_Handoff_res_handles kl_core_Log_Handoff_res_handles
#define Log_Handoff_err_handles kl_core_Log_Handoff_err_handles
#define Log_FetchMessages_res_data_size kl_core_Log_FetchMessages_res_data_size
#define Log_FetchMessages_req_arena_size kl_core_Log_FetchMessages_req_arena_size
#define Log_FetchMessages_res_arena_size kl_core_Log_FetchMessages_res_arena_size
#define Log_FetchMessages_req_handles kl_core_Log_FetchMessages_req_handles
#define Log_FetchMessages_res_handles kl_core_Log_FetchMessages_res_handles
#define Log_FetchMessages_err_handles kl_core_Log_FetchMessages_err_handles
#define Log_GetMessagesHandle_req_arena_size kl_core_Log_GetMessagesHandle_req_arena_size
#define Log_GetMessagesHandle_res_arena_size kl_core_Log_GetMessagesHandle_res_arena_size
#define Log_GetMessagesHandle_req_handles kl_core_Log_GetMessagesHandle_req_handles
#define Log_GetMessagesHandle_res_handles kl_core_Log_GetMessagesHandle_res_handles
#define Log_GetMessagesHandle_err_handles kl_core_Log_GetMessagesHandle_err_handles
#define Log_req_arena_size kl_core_Log_req_arena_size
#define Log_res_arena_size kl_core_Log_res_arena_size
#define Log_req_handles kl_core_Log_req_handles
#define Log_res_handles kl_core_Log_res_handles
#define Log_err_handles kl_core_Log_err_handles
#define Log_Handoff_req kl_core_Log_Handoff_req
#define Log_Handoff_res kl_core_Log_Handoff_res
#define Log_FetchMessages_req kl_core_Log_FetchMessages_req
#define Log_FetchMessages_res kl_core_Log_FetchMessages_res
#define Log_GetMessagesHandle_req kl_core_Log_GetMessagesHandle_req
#define Log_GetMessagesHandle_res kl_core_Log_GetMessagesHandle_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Log__INTERFACE__ */

#ifndef __kl_core__Notice__INTERFACE__
#define __kl_core__Notice__INTERFACE__
enum {
    kl_core_Notice_Create_mid,
    kl_core_Notice_SubscribeToObject_mid,
    kl_core_Notice_UnsubscribeFromEvent_mid,
    kl_core_Notice_UnsubscribeFromObject_mid,
    kl_core_Notice_GetEvent_mid,
    kl_core_Notice_DropAndWake_mid,
    kl_core_Notice_SetObjectEvent_mid,
    kl_core_Notice_mid_max,
};
enum {
    kl_core_Notice_Create_req_arena_size = 0,
    kl_core_Notice_Create_res_arena_size = 0,
    kl_core_Notice_Create_req_handles = 0,
    kl_core_Notice_Create_res_handles = 1,
    kl_core_Notice_Create_err_handles = 0,
    kl_core_Notice_SubscribeToObject_req_arena_size =
    0,
    kl_core_Notice_SubscribeToObject_res_arena_size =
    0,
    kl_core_Notice_SubscribeToObject_req_handles =
    2,
    kl_core_Notice_SubscribeToObject_res_handles =
    0,
    kl_core_Notice_SubscribeToObject_err_handles =
    0,
    kl_core_Notice_UnsubscribeFromEvent_req_arena_size =
    0,
    kl_core_Notice_UnsubscribeFromEvent_res_arena_size =
    0,
    kl_core_Notice_UnsubscribeFromEvent_req_handles =
    1,
    kl_core_Notice_UnsubscribeFromEvent_res_handles =
    0,
    kl_core_Notice_UnsubscribeFromEvent_err_handles =
    0,
    kl_core_Notice_UnsubscribeFromObject_req_arena_size =
    0,
    kl_core_Notice_UnsubscribeFromObject_res_arena_size =
    0,
    kl_core_Notice_UnsubscribeFromObject_req_handles =
    2,
    kl_core_Notice_UnsubscribeFromObject_res_handles =
    0,
    kl_core_Notice_UnsubscribeFromObject_err_handles =
    0,
    kl_core_Notice_GetEvent_res_events_size = 128,
    kl_core_Notice_GetEvent_req_arena_size = 0,
    kl_core_Notice_GetEvent_res_arena_size = 2048,
    kl_core_Notice_GetEvent_req_handles = 1,
    kl_core_Notice_GetEvent_res_handles = 0,
    kl_core_Notice_GetEvent_err_handles = 0,
    kl_core_Notice_DropAndWake_req_arena_size = 0,
    kl_core_Notice_DropAndWake_res_arena_size = 0,
    kl_core_Notice_DropAndWake_req_handles = 1,
    kl_core_Notice_DropAndWake_res_handles = 0,
    kl_core_Notice_DropAndWake_err_handles = 0,
    kl_core_Notice_SetObjectEvent_req_arena_size =
    0,
    kl_core_Notice_SetObjectEvent_res_arena_size =
    0,
    kl_core_Notice_SetObjectEvent_req_handles = 1,
    kl_core_Notice_SetObjectEvent_res_handles = 0,
    kl_core_Notice_SetObjectEvent_err_handles = 0,
    kl_core_Notice_req_arena_size = 0,
    kl_core_Notice_res_arena_size = 2048,
    kl_core_Notice_req_handles = 2,
    kl_core_Notice_res_handles = 1,
    kl_core_Notice_err_handles = 0,
};
typedef struct __nk_packed kl_core_Notice_Create_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Notice_Create_req;
nk_static_assert(sizeof(kl_core_Notice_Create_req) == 24, bad_kl_core_Notice_Create_req_size);
nk_static_assert(nk_offsetof(kl_core_Notice_Create_req, base_) == 0, bad_kl_core_Notice_Create_req_base__offset);
#pragma pack(push, 8) /* kl_core_Notice_Create_res */
typedef struct kl_core_Notice_Create_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Notice_Create_err;
nk_static_assert(sizeof(kl_core_Notice_Create_err) == 24, bad_kl_core_Notice_Create_err_size);
nk_static_assert(nk_offsetof(kl_core_Notice_Create_err, base_) == 0, bad_kl_core_Notice_Create_err_base__offset);
typedef struct kl_core_Notice_Create_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t notify;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t notify;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Notice_Create_err err_;
            };
        } kl_core_Notice_Create_res;
nk_static_assert(sizeof(kl_core_Notice_Create_res) == 48, bad_kl_core_Notice_Create_res_size);
nk_static_assert(nk_offsetof(kl_core_Notice_Create_res, base_) == 0, bad_kl_core_Notice_Create_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Notice_Create_res, notify) == 24, bad_kl_core_Notice_Create_res_notify_offset);
nk_static_assert(nk_offsetof(kl_core_Notice_Create_res, rc) == 40, bad_kl_core_Notice_Create_res_rc_offset);
#pragma pack(pop) /* kl_core_Notice_Create_res */
typedef struct __nk_packed kl_core_Notice_SubscribeToObject_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t notify;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t object;
            __nk_alignas(4) nk_uint32_t evMask;
            __nk_alignas(8) nk_uint64_t evId;
        } kl_core_Notice_SubscribeToObject_req;
nk_static_assert(sizeof(kl_core_Notice_SubscribeToObject_req) == 72, bad_kl_core_Notice_SubscribeToObject_req_size);
nk_static_assert(nk_offsetof(kl_core_Notice_SubscribeToObject_req, base_) == 0, bad_kl_core_Notice_SubscribeToObject_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Notice_SubscribeToObject_req, notify) == 24, bad_kl_core_Notice_SubscribeToObject_req_notify_offset);
nk_static_assert(nk_offsetof(kl_core_Notice_SubscribeToObject_req, object) == 40, bad_kl_core_Notice_SubscribeToObject_req_object_offset);
nk_static_assert(nk_offsetof(kl_core_Notice_SubscribeToObject_req, evMask) == 56, bad_kl_core_Notice_SubscribeToObject_req_evMask_offset);
nk_static_assert(nk_offsetof(kl_core_Notice_SubscribeToObject_req, evId) == 64, bad_kl_core_Notice_SubscribeToObject_req_evId_offset);
#pragma pack(push, 8) /* kl_core_Notice_SubscribeToObject_res */
typedef struct kl_core_Notice_SubscribeToObject_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Notice_SubscribeToObject_err;
nk_static_assert(sizeof(kl_core_Notice_SubscribeToObject_err) == 24, bad_kl_core_Notice_SubscribeToObject_err_size);
nk_static_assert(nk_offsetof(kl_core_Notice_SubscribeToObject_err, base_) == 0, bad_kl_core_Notice_SubscribeToObject_err_base__offset);
typedef struct kl_core_Notice_SubscribeToObject_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Notice_SubscribeToObject_err err_;
            };
        } kl_core_Notice_SubscribeToObject_res;
nk_static_assert(sizeof(kl_core_Notice_SubscribeToObject_res) == 32, bad_kl_core_Notice_SubscribeToObject_res_size);
nk_static_assert(nk_offsetof(kl_core_Notice_SubscribeToObject_res, base_) == 0, bad_kl_core_Notice_SubscribeToObject_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Notice_SubscribeToObject_res, rc) == 24, bad_kl_core_Notice_SubscribeToObject_res_rc_offset);
#pragma pack(pop) /* kl_core_Notice_SubscribeToObject_res */
typedef struct __nk_packed kl_core_Notice_UnsubscribeFromEvent_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t notify;
            __nk_alignas(8) nk_uint64_t evId;
        } kl_core_Notice_UnsubscribeFromEvent_req;
nk_static_assert(sizeof(kl_core_Notice_UnsubscribeFromEvent_req) == 48, bad_kl_core_Notice_UnsubscribeFromEvent_req_size);
nk_static_assert(nk_offsetof(kl_core_Notice_UnsubscribeFromEvent_req, base_) == 0, bad_kl_core_Notice_UnsubscribeFromEvent_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Notice_UnsubscribeFromEvent_req, notify) == 24, bad_kl_core_Notice_UnsubscribeFromEvent_req_notify_offset);
nk_static_assert(nk_offsetof(kl_core_Notice_UnsubscribeFromEvent_req, evId) == 40, bad_kl_core_Notice_UnsubscribeFromEvent_req_evId_offset);
#pragma pack(push, 8) /* kl_core_Notice_UnsubscribeFromEvent_res */
typedef struct kl_core_Notice_UnsubscribeFromEvent_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Notice_UnsubscribeFromEvent_err;
nk_static_assert(sizeof(kl_core_Notice_UnsubscribeFromEvent_err) == 24, bad_kl_core_Notice_UnsubscribeFromEvent_err_size);
nk_static_assert(nk_offsetof(kl_core_Notice_UnsubscribeFromEvent_err, base_) == 0, bad_kl_core_Notice_UnsubscribeFromEvent_err_base__offset);
typedef struct kl_core_Notice_UnsubscribeFromEvent_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Notice_UnsubscribeFromEvent_err err_;
            };
        } kl_core_Notice_UnsubscribeFromEvent_res;
nk_static_assert(sizeof(kl_core_Notice_UnsubscribeFromEvent_res) == 32, bad_kl_core_Notice_UnsubscribeFromEvent_res_size);
nk_static_assert(nk_offsetof(kl_core_Notice_UnsubscribeFromEvent_res, base_) == 0, bad_kl_core_Notice_UnsubscribeFromEvent_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Notice_UnsubscribeFromEvent_res, rc) == 24, bad_kl_core_Notice_UnsubscribeFromEvent_res_rc_offset);
#pragma pack(pop) /* kl_core_Notice_UnsubscribeFromEvent_res */
typedef struct __nk_packed kl_core_Notice_UnsubscribeFromObject_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t notify;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t object;
        }
kl_core_Notice_UnsubscribeFromObject_req;
nk_static_assert(sizeof(kl_core_Notice_UnsubscribeFromObject_req) == 56, bad_kl_core_Notice_UnsubscribeFromObject_req_size);
nk_static_assert(nk_offsetof(kl_core_Notice_UnsubscribeFromObject_req, base_) == 0, bad_kl_core_Notice_UnsubscribeFromObject_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Notice_UnsubscribeFromObject_req, notify) == 24, bad_kl_core_Notice_UnsubscribeFromObject_req_notify_offset);
nk_static_assert(nk_offsetof(kl_core_Notice_UnsubscribeFromObject_req, object) == 40, bad_kl_core_Notice_UnsubscribeFromObject_req_object_offset);
#pragma pack(push, 8) /* kl_core_Notice_UnsubscribeFromObject_res */
typedef struct kl_core_Notice_UnsubscribeFromObject_err {
            __nk_alignas(8)
            struct nk_message base_;
        }
kl_core_Notice_UnsubscribeFromObject_err;
nk_static_assert(sizeof(kl_core_Notice_UnsubscribeFromObject_err) == 24, bad_kl_core_Notice_UnsubscribeFromObject_err_size);
nk_static_assert(nk_offsetof(kl_core_Notice_UnsubscribeFromObject_err, base_) == 0, bad_kl_core_Notice_UnsubscribeFromObject_err_base__offset);
typedef struct kl_core_Notice_UnsubscribeFromObject_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Notice_UnsubscribeFromObject_err err_;
            };
        }
kl_core_Notice_UnsubscribeFromObject_res;
nk_static_assert(sizeof(kl_core_Notice_UnsubscribeFromObject_res) == 32, bad_kl_core_Notice_UnsubscribeFromObject_res_size);
nk_static_assert(nk_offsetof(kl_core_Notice_UnsubscribeFromObject_res, base_) == 0, bad_kl_core_Notice_UnsubscribeFromObject_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Notice_UnsubscribeFromObject_res, rc) == 24, bad_kl_core_Notice_UnsubscribeFromObject_res_rc_offset);
#pragma pack(pop) /* kl_core_Notice_UnsubscribeFromObject_res */
typedef struct __nk_packed kl_core_Notice_GetEvent_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t notify;
            __nk_alignas(4) nk_uint32_t mdelay;
        } kl_core_Notice_GetEvent_req;
nk_static_assert(sizeof(kl_core_Notice_GetEvent_req) == 48, bad_kl_core_Notice_GetEvent_req_size);
nk_static_assert(nk_offsetof(kl_core_Notice_GetEvent_req, base_) == 0, bad_kl_core_Notice_GetEvent_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Notice_GetEvent_req, notify) == 24, bad_kl_core_Notice_GetEvent_req_notify_offset);
nk_static_assert(nk_offsetof(kl_core_Notice_GetEvent_req, mdelay) == 40, bad_kl_core_Notice_GetEvent_req_mdelay_offset);
#pragma pack(push, 8) /* kl_core_Notice_GetEvent_res */
typedef struct kl_core_Notice_GetEvent_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Notice_GetEvent_err;
nk_static_assert(sizeof(kl_core_Notice_GetEvent_err) == 24, bad_kl_core_Notice_GetEvent_err_size);
nk_static_assert(nk_offsetof(kl_core_Notice_GetEvent_err, base_) == 0, bad_kl_core_Notice_GetEvent_err_base__offset);
typedef struct kl_core_Notice_GetEvent_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_ptr_t events;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_ptr_t events;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Notice_GetEvent_err err_;
            };
        } kl_core_Notice_GetEvent_res;
nk_static_assert(sizeof(kl_core_Notice_GetEvent_res) == 40, bad_kl_core_Notice_GetEvent_res_size);
nk_static_assert(nk_offsetof(kl_core_Notice_GetEvent_res, base_) == 0, bad_kl_core_Notice_GetEvent_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Notice_GetEvent_res, events) == 24, bad_kl_core_Notice_GetEvent_res_events_offset);
nk_static_assert(nk_offsetof(kl_core_Notice_GetEvent_res, rc) == 32, bad_kl_core_Notice_GetEvent_res_rc_offset);
#pragma pack(pop) /* kl_core_Notice_GetEvent_res */
typedef struct __nk_packed kl_core_Notice_DropAndWake_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t notify;
            __nk_alignas(4) nk_uint32_t finish;
        } kl_core_Notice_DropAndWake_req;
nk_static_assert(sizeof(kl_core_Notice_DropAndWake_req) == 48, bad_kl_core_Notice_DropAndWake_req_size);
nk_static_assert(nk_offsetof(kl_core_Notice_DropAndWake_req, base_) == 0, bad_kl_core_Notice_DropAndWake_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Notice_DropAndWake_req, notify) == 24, bad_kl_core_Notice_DropAndWake_req_notify_offset);
nk_static_assert(nk_offsetof(kl_core_Notice_DropAndWake_req, finish) == 40, bad_kl_core_Notice_DropAndWake_req_finish_offset);
#pragma pack(push, 8) /* kl_core_Notice_DropAndWake_res */
typedef struct kl_core_Notice_DropAndWake_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Notice_DropAndWake_err;
nk_static_assert(sizeof(kl_core_Notice_DropAndWake_err) == 24, bad_kl_core_Notice_DropAndWake_err_size);
nk_static_assert(nk_offsetof(kl_core_Notice_DropAndWake_err, base_) == 0, bad_kl_core_Notice_DropAndWake_err_base__offset);
typedef struct kl_core_Notice_DropAndWake_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Notice_DropAndWake_err err_;
            };
        } kl_core_Notice_DropAndWake_res;
nk_static_assert(sizeof(kl_core_Notice_DropAndWake_res) == 32, bad_kl_core_Notice_DropAndWake_res_size);
nk_static_assert(nk_offsetof(kl_core_Notice_DropAndWake_res, base_) == 0, bad_kl_core_Notice_DropAndWake_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Notice_DropAndWake_res, rc) == 24, bad_kl_core_Notice_DropAndWake_res_rc_offset);
#pragma pack(pop) /* kl_core_Notice_DropAndWake_res */
typedef struct __nk_packed kl_core_Notice_SetObjectEvent_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t object;
            __nk_alignas(4) nk_uint32_t evMask;
        } kl_core_Notice_SetObjectEvent_req;
nk_static_assert(sizeof(kl_core_Notice_SetObjectEvent_req) == 48, bad_kl_core_Notice_SetObjectEvent_req_size);
nk_static_assert(nk_offsetof(kl_core_Notice_SetObjectEvent_req, base_) == 0, bad_kl_core_Notice_SetObjectEvent_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Notice_SetObjectEvent_req, object) == 24, bad_kl_core_Notice_SetObjectEvent_req_object_offset);
nk_static_assert(nk_offsetof(kl_core_Notice_SetObjectEvent_req, evMask) == 40, bad_kl_core_Notice_SetObjectEvent_req_evMask_offset);
#pragma pack(push, 8) /* kl_core_Notice_SetObjectEvent_res */
typedef struct kl_core_Notice_SetObjectEvent_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Notice_SetObjectEvent_err;
nk_static_assert(sizeof(kl_core_Notice_SetObjectEvent_err) == 24, bad_kl_core_Notice_SetObjectEvent_err_size);
nk_static_assert(nk_offsetof(kl_core_Notice_SetObjectEvent_err, base_) == 0, bad_kl_core_Notice_SetObjectEvent_err_base__offset);
typedef struct kl_core_Notice_SetObjectEvent_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Notice_SetObjectEvent_err err_;
            };
        } kl_core_Notice_SetObjectEvent_res;
nk_static_assert(sizeof(kl_core_Notice_SetObjectEvent_res) == 32, bad_kl_core_Notice_SetObjectEvent_res_size);
nk_static_assert(nk_offsetof(kl_core_Notice_SetObjectEvent_res, base_) == 0, bad_kl_core_Notice_SetObjectEvent_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Notice_SetObjectEvent_res, rc) == 24, bad_kl_core_Notice_SetObjectEvent_res_rc_offset);
#pragma pack(pop) /* kl_core_Notice_SetObjectEvent_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Notice_Create_mid kl_core_Notice_Create_mid
#define Notice_SubscribeToObject_mid kl_core_Notice_SubscribeToObject_mid
#define Notice_UnsubscribeFromEvent_mid kl_core_Notice_UnsubscribeFromEvent_mid
#define Notice_UnsubscribeFromObject_mid kl_core_Notice_UnsubscribeFromObject_mid
#define Notice_GetEvent_mid kl_core_Notice_GetEvent_mid
#define Notice_DropAndWake_mid kl_core_Notice_DropAndWake_mid
#define Notice_SetObjectEvent_mid kl_core_Notice_SetObjectEvent_mid
#define Notice_mid_max kl_core_Notice_mid_max
#define Notice_Create_req_arena_size kl_core_Notice_Create_req_arena_size
#define Notice_Create_res_arena_size kl_core_Notice_Create_res_arena_size
#define Notice_Create_req_handles kl_core_Notice_Create_req_handles
#define Notice_Create_res_handles kl_core_Notice_Create_res_handles
#define Notice_Create_err_handles kl_core_Notice_Create_err_handles
#define Notice_SubscribeToObject_req_arena_size kl_core_Notice_SubscribeToObject_req_arena_size
#define Notice_SubscribeToObject_res_arena_size kl_core_Notice_SubscribeToObject_res_arena_size
#define Notice_SubscribeToObject_req_handles kl_core_Notice_SubscribeToObject_req_handles
#define Notice_SubscribeToObject_res_handles kl_core_Notice_SubscribeToObject_res_handles
#define Notice_SubscribeToObject_err_handles kl_core_Notice_SubscribeToObject_err_handles
#define Notice_UnsubscribeFromEvent_req_arena_size kl_core_Notice_UnsubscribeFromEvent_req_arena_size
#define Notice_UnsubscribeFromEvent_res_arena_size kl_core_Notice_UnsubscribeFromEvent_res_arena_size
#define Notice_UnsubscribeFromEvent_req_handles kl_core_Notice_UnsubscribeFromEvent_req_handles
#define Notice_UnsubscribeFromEvent_res_handles kl_core_Notice_UnsubscribeFromEvent_res_handles
#define Notice_UnsubscribeFromEvent_err_handles kl_core_Notice_UnsubscribeFromEvent_err_handles
#define Notice_UnsubscribeFromObject_req_arena_size kl_core_Notice_UnsubscribeFromObject_req_arena_size
#define Notice_UnsubscribeFromObject_res_arena_size kl_core_Notice_UnsubscribeFromObject_res_arena_size
#define Notice_UnsubscribeFromObject_req_handles kl_core_Notice_UnsubscribeFromObject_req_handles
#define Notice_UnsubscribeFromObject_res_handles kl_core_Notice_UnsubscribeFromObject_res_handles
#define Notice_UnsubscribeFromObject_err_handles kl_core_Notice_UnsubscribeFromObject_err_handles
#define Notice_GetEvent_res_events_size kl_core_Notice_GetEvent_res_events_size
#define Notice_GetEvent_req_arena_size kl_core_Notice_GetEvent_req_arena_size
#define Notice_GetEvent_res_arena_size kl_core_Notice_GetEvent_res_arena_size
#define Notice_GetEvent_req_handles kl_core_Notice_GetEvent_req_handles
#define Notice_GetEvent_res_handles kl_core_Notice_GetEvent_res_handles
#define Notice_GetEvent_err_handles kl_core_Notice_GetEvent_err_handles
#define Notice_DropAndWake_req_arena_size kl_core_Notice_DropAndWake_req_arena_size
#define Notice_DropAndWake_res_arena_size kl_core_Notice_DropAndWake_res_arena_size
#define Notice_DropAndWake_req_handles kl_core_Notice_DropAndWake_req_handles
#define Notice_DropAndWake_res_handles kl_core_Notice_DropAndWake_res_handles
#define Notice_DropAndWake_err_handles kl_core_Notice_DropAndWake_err_handles
#define Notice_SetObjectEvent_req_arena_size kl_core_Notice_SetObjectEvent_req_arena_size
#define Notice_SetObjectEvent_res_arena_size kl_core_Notice_SetObjectEvent_res_arena_size
#define Notice_SetObjectEvent_req_handles kl_core_Notice_SetObjectEvent_req_handles
#define Notice_SetObjectEvent_res_handles kl_core_Notice_SetObjectEvent_res_handles
#define Notice_SetObjectEvent_err_handles kl_core_Notice_SetObjectEvent_err_handles
#define Notice_req_arena_size kl_core_Notice_req_arena_size
#define Notice_res_arena_size kl_core_Notice_res_arena_size
#define Notice_req_handles kl_core_Notice_req_handles
#define Notice_res_handles kl_core_Notice_res_handles
#define Notice_err_handles kl_core_Notice_err_handles
#define Notice_Create_req kl_core_Notice_Create_req
#define Notice_Create_res kl_core_Notice_Create_res
#define Notice_SubscribeToObject_req kl_core_Notice_SubscribeToObject_req
#define Notice_SubscribeToObject_res kl_core_Notice_SubscribeToObject_res
#define Notice_UnsubscribeFromEvent_req kl_core_Notice_UnsubscribeFromEvent_req
#define Notice_UnsubscribeFromEvent_res kl_core_Notice_UnsubscribeFromEvent_res
#define Notice_UnsubscribeFromObject_req kl_core_Notice_UnsubscribeFromObject_req
#define Notice_UnsubscribeFromObject_res kl_core_Notice_UnsubscribeFromObject_res
#define Notice_GetEvent_req kl_core_Notice_GetEvent_req
#define Notice_GetEvent_res kl_core_Notice_GetEvent_res
#define Notice_DropAndWake_req kl_core_Notice_DropAndWake_req
#define Notice_DropAndWake_res kl_core_Notice_DropAndWake_res
#define Notice_SetObjectEvent_req kl_core_Notice_SetObjectEvent_req
#define Notice_SetObjectEvent_res kl_core_Notice_SetObjectEvent_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Notice__INTERFACE__ */

#ifndef __kl_core__PM__INTERFACE__
#define __kl_core__PM__INTERFACE__
enum {
    kl_core_PM_Request_mid,
    kl_core_PM_SetCpusOnline_mid,
    kl_core_PM_GetCpusOnline_mid,
    kl_core_PM_mid_max,
};
enum {
    kl_core_PM_Request_req_arena_size = 0,
    kl_core_PM_Request_res_arena_size = 0,
    kl_core_PM_Request_req_handles = 0,
    kl_core_PM_Request_res_handles = 0,
    kl_core_PM_Request_err_handles = 0,
    kl_core_PM_SetCpusOnline_req_arena_size = 0,
    kl_core_PM_SetCpusOnline_res_arena_size = 0,
    kl_core_PM_SetCpusOnline_req_handles = 0,
    kl_core_PM_SetCpusOnline_res_handles = 0,
    kl_core_PM_SetCpusOnline_err_handles = 0,
    kl_core_PM_GetCpusOnline_req_arena_size = 0,
    kl_core_PM_GetCpusOnline_res_arena_size = 0,
    kl_core_PM_GetCpusOnline_req_handles = 0,
    kl_core_PM_GetCpusOnline_res_handles = 0,
    kl_core_PM_GetCpusOnline_err_handles = 0,
    kl_core_PM_req_arena_size = 0,
    kl_core_PM_res_arena_size = 0,
    kl_core_PM_req_handles = 0,
    kl_core_PM_res_handles = 0,
    kl_core_PM_err_handles = 0,
};
typedef struct __nk_packed kl_core_PM_Request_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t request;
        } kl_core_PM_Request_req;
nk_static_assert(sizeof(kl_core_PM_Request_req) == 32, bad_kl_core_PM_Request_req_size);
nk_static_assert(nk_offsetof(kl_core_PM_Request_req, base_) == 0, bad_kl_core_PM_Request_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_PM_Request_req, request) == 24, bad_kl_core_PM_Request_req_request_offset);
#pragma pack(push, 8) /* kl_core_PM_Request_res */
typedef struct kl_core_PM_Request_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_PM_Request_err;
nk_static_assert(sizeof(kl_core_PM_Request_err) == 24, bad_kl_core_PM_Request_err_size);
nk_static_assert(nk_offsetof(kl_core_PM_Request_err, base_) == 0, bad_kl_core_PM_Request_err_base__offset);
typedef struct kl_core_PM_Request_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_PM_Request_err err_;
            };
        } kl_core_PM_Request_res;
nk_static_assert(sizeof(kl_core_PM_Request_res) == 32, bad_kl_core_PM_Request_res_size);
nk_static_assert(nk_offsetof(kl_core_PM_Request_res, base_) == 0, bad_kl_core_PM_Request_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_PM_Request_res, rc) == 24, bad_kl_core_PM_Request_res_rc_offset);
#pragma pack(pop) /* kl_core_PM_Request_res */
typedef struct __nk_packed kl_core_PM_SetCpusOnline_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t request;
        } kl_core_PM_SetCpusOnline_req;
nk_static_assert(sizeof(kl_core_PM_SetCpusOnline_req) == 32, bad_kl_core_PM_SetCpusOnline_req_size);
nk_static_assert(nk_offsetof(kl_core_PM_SetCpusOnline_req, base_) == 0, bad_kl_core_PM_SetCpusOnline_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_PM_SetCpusOnline_req, request) == 24, bad_kl_core_PM_SetCpusOnline_req_request_offset);
#pragma pack(push, 8) /* kl_core_PM_SetCpusOnline_res */
typedef struct kl_core_PM_SetCpusOnline_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_PM_SetCpusOnline_err;
nk_static_assert(sizeof(kl_core_PM_SetCpusOnline_err) == 24, bad_kl_core_PM_SetCpusOnline_err_size);
nk_static_assert(nk_offsetof(kl_core_PM_SetCpusOnline_err, base_) == 0, bad_kl_core_PM_SetCpusOnline_err_base__offset);
typedef struct kl_core_PM_SetCpusOnline_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_PM_SetCpusOnline_err err_;
            };
        } kl_core_PM_SetCpusOnline_res;
nk_static_assert(sizeof(kl_core_PM_SetCpusOnline_res) == 32, bad_kl_core_PM_SetCpusOnline_res_size);
nk_static_assert(nk_offsetof(kl_core_PM_SetCpusOnline_res, base_) == 0, bad_kl_core_PM_SetCpusOnline_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_PM_SetCpusOnline_res, rc) == 24, bad_kl_core_PM_SetCpusOnline_res_rc_offset);
#pragma pack(pop) /* kl_core_PM_SetCpusOnline_res */
typedef struct __nk_packed kl_core_PM_GetCpusOnline_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_PM_GetCpusOnline_req;
nk_static_assert(sizeof(kl_core_PM_GetCpusOnline_req) == 24, bad_kl_core_PM_GetCpusOnline_req_size);
nk_static_assert(nk_offsetof(kl_core_PM_GetCpusOnline_req, base_) == 0, bad_kl_core_PM_GetCpusOnline_req_base__offset);
#pragma pack(push, 8) /* kl_core_PM_GetCpusOnline_res */
typedef struct kl_core_PM_GetCpusOnline_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_PM_GetCpusOnline_err;
nk_static_assert(sizeof(kl_core_PM_GetCpusOnline_err) == 24, bad_kl_core_PM_GetCpusOnline_err_size);
nk_static_assert(nk_offsetof(kl_core_PM_GetCpusOnline_err, base_) == 0, bad_kl_core_PM_GetCpusOnline_err_base__offset);
typedef struct kl_core_PM_GetCpusOnline_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t online;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t online;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_PM_GetCpusOnline_err err_;
            };
        } kl_core_PM_GetCpusOnline_res;
nk_static_assert(sizeof(kl_core_PM_GetCpusOnline_res) == 40, bad_kl_core_PM_GetCpusOnline_res_size);
nk_static_assert(nk_offsetof(kl_core_PM_GetCpusOnline_res, base_) == 0, bad_kl_core_PM_GetCpusOnline_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_PM_GetCpusOnline_res, online) == 24, bad_kl_core_PM_GetCpusOnline_res_online_offset);
nk_static_assert(nk_offsetof(kl_core_PM_GetCpusOnline_res, rc) == 32, bad_kl_core_PM_GetCpusOnline_res_rc_offset);
#pragma pack(pop) /* kl_core_PM_GetCpusOnline_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define PM_Request_mid kl_core_PM_Request_mid
#define PM_SetCpusOnline_mid kl_core_PM_SetCpusOnline_mid
#define PM_GetCpusOnline_mid kl_core_PM_GetCpusOnline_mid
#define PM_mid_max kl_core_PM_mid_max
#define PM_Request_req_arena_size kl_core_PM_Request_req_arena_size
#define PM_Request_res_arena_size kl_core_PM_Request_res_arena_size
#define PM_Request_req_handles kl_core_PM_Request_req_handles
#define PM_Request_res_handles kl_core_PM_Request_res_handles
#define PM_Request_err_handles kl_core_PM_Request_err_handles
#define PM_SetCpusOnline_req_arena_size kl_core_PM_SetCpusOnline_req_arena_size
#define PM_SetCpusOnline_res_arena_size kl_core_PM_SetCpusOnline_res_arena_size
#define PM_SetCpusOnline_req_handles kl_core_PM_SetCpusOnline_req_handles
#define PM_SetCpusOnline_res_handles kl_core_PM_SetCpusOnline_res_handles
#define PM_SetCpusOnline_err_handles kl_core_PM_SetCpusOnline_err_handles
#define PM_GetCpusOnline_req_arena_size kl_core_PM_GetCpusOnline_req_arena_size
#define PM_GetCpusOnline_res_arena_size kl_core_PM_GetCpusOnline_res_arena_size
#define PM_GetCpusOnline_req_handles kl_core_PM_GetCpusOnline_req_handles
#define PM_GetCpusOnline_res_handles kl_core_PM_GetCpusOnline_res_handles
#define PM_GetCpusOnline_err_handles kl_core_PM_GetCpusOnline_err_handles
#define PM_req_arena_size kl_core_PM_req_arena_size
#define PM_res_arena_size kl_core_PM_res_arena_size
#define PM_req_handles kl_core_PM_req_handles
#define PM_res_handles kl_core_PM_res_handles
#define PM_err_handles kl_core_PM_err_handles
#define PM_Request_req kl_core_PM_Request_req
#define PM_Request_res kl_core_PM_Request_res
#define PM_SetCpusOnline_req kl_core_PM_SetCpusOnline_req
#define PM_SetCpusOnline_res kl_core_PM_SetCpusOnline_res
#define PM_GetCpusOnline_req kl_core_PM_GetCpusOnline_req
#define PM_GetCpusOnline_res kl_core_PM_GetCpusOnline_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__PM__INTERFACE__ */

#ifndef __kl_core__Profiler__INTERFACE__
#define __kl_core__Profiler__INTERFACE__
enum {
    kl_core_Profiler_GetCoverageData_mid,
    kl_core_Profiler_FlushGcov_mid,
    kl_core_Profiler_FlushGcovFile_mid,
    kl_core_Profiler_GetCounters_mid,
    kl_core_Profiler_ObjectGetStat_mid,
    kl_core_Profiler_SamplingStart_mid,
    kl_core_Profiler_SamplingStop_mid,
    kl_core_Profiler_SamplingRead_mid,
    kl_core_Profiler_SamplingAddPidToList_mid,
    kl_core_Profiler_SamplingClearPidList_mid,
    kl_core_Profiler_LoadSegInfo_mid,
    kl_core_Profiler_UnloadSegInfo_mid,
    kl_core_Profiler_KcovAlloc_mid,
    kl_core_Profiler_KcovFree_mid,
    kl_core_Profiler_KcovStart_mid,
    kl_core_Profiler_KcovStop_mid,
    kl_core_Profiler_mid_max,
};
enum {
    kl_core_Profiler_GetCoverageData_res_buf_size =
    65536,
    kl_core_Profiler_GetCoverageData_res_name_size =
    1024,
    kl_core_Profiler_GetCoverageData_req_arena_size =
    0,
    kl_core_Profiler_GetCoverageData_res_arena_size =
    66560,
    kl_core_Profiler_GetCoverageData_req_handles =
    0,
    kl_core_Profiler_GetCoverageData_res_handles =
    0,
    kl_core_Profiler_GetCoverageData_err_handles =
    0,
    kl_core_Profiler_FlushGcov_req_arena_size = 0,
    kl_core_Profiler_FlushGcov_res_arena_size = 0,
    kl_core_Profiler_FlushGcov_req_handles = 0,
    kl_core_Profiler_FlushGcov_res_handles = 0,
    kl_core_Profiler_FlushGcov_err_handles = 0,
    kl_core_Profiler_FlushGcovFile_req_name_size =
    1024,
    kl_core_Profiler_FlushGcovFile_req_arena_size =
    1024,
    kl_core_Profiler_FlushGcovFile_res_arena_size =
    0,
    kl_core_Profiler_FlushGcovFile_req_handles =
    0,
    kl_core_Profiler_FlushGcovFile_res_handles =
    0,
    kl_core_Profiler_FlushGcovFile_err_handles =
    0,
    kl_core_Profiler_GetCounters_req_prefix_size =
    1024,
    kl_core_Profiler_GetCounters_req_names_size =
    64,
    kl_core_Profiler_GetCounters_req_names_elem_size =
    128,
    kl_core_Profiler_GetCounters_res_values_size =
    64,
    kl_core_Profiler_GetCounters_req_arena_size =
    9728,
    kl_core_Profiler_GetCounters_res_arena_size =
    1536,
    kl_core_Profiler_GetCounters_req_handles = 0,
    kl_core_Profiler_GetCounters_res_handles = 0,
    kl_core_Profiler_GetCounters_err_handles = 0,
    kl_core_Profiler_ObjectGetStat_req_names_size =
    64,
    kl_core_Profiler_ObjectGetStat_req_names_elem_size =
    128,
    kl_core_Profiler_ObjectGetStat_res_values_size =
    64,
    kl_core_Profiler_ObjectGetStat_req_arena_size =
    8704,
    kl_core_Profiler_ObjectGetStat_res_arena_size =
    1536,
    kl_core_Profiler_ObjectGetStat_req_handles =
    1,
    kl_core_Profiler_ObjectGetStat_res_handles =
    0,
    kl_core_Profiler_ObjectGetStat_err_handles =
    0,
    kl_core_Profiler_SamplingStart_req_cpus_size =
    128,
    kl_core_Profiler_SamplingStart_req_arena_size =
    128,
    kl_core_Profiler_SamplingStart_res_arena_size =
    0,
    kl_core_Profiler_SamplingStart_req_handles =
    0,
    kl_core_Profiler_SamplingStart_res_handles =
    0,
    kl_core_Profiler_SamplingStart_err_handles =
    0,
    kl_core_Profiler_SamplingStop_req_arena_size =
    0,
    kl_core_Profiler_SamplingStop_res_arena_size =
    0,
    kl_core_Profiler_SamplingStop_req_handles = 0,
    kl_core_Profiler_SamplingStop_res_handles = 0,
    kl_core_Profiler_SamplingStop_err_handles = 0,
    kl_core_Profiler_SamplingRead_req_arena_size =
    0,
    kl_core_Profiler_SamplingRead_res_arena_size =
    0,
    kl_core_Profiler_SamplingRead_req_handles = 0,
    kl_core_Profiler_SamplingRead_res_handles = 0,
    kl_core_Profiler_SamplingRead_err_handles = 0,
    kl_core_Profiler_SamplingAddPidToList_req_arena_size =
    0,
    kl_core_Profiler_SamplingAddPidToList_res_arena_size =
    0,
    kl_core_Profiler_SamplingAddPidToList_req_handles =
    0,
    kl_core_Profiler_SamplingAddPidToList_res_handles =
    0,
    kl_core_Profiler_SamplingAddPidToList_err_handles =
    0,
    kl_core_Profiler_SamplingClearPidList_req_arena_size =
    0,
    kl_core_Profiler_SamplingClearPidList_res_arena_size =
    0,
    kl_core_Profiler_SamplingClearPidList_req_handles =
    0,
    kl_core_Profiler_SamplingClearPidList_res_handles =
    0,
    kl_core_Profiler_SamplingClearPidList_err_handles =
    0,
    kl_core_Profiler_LoadSegInfo_req_buildId_size =
    20,
    kl_core_Profiler_LoadSegInfo_req_arena_size =
    20,
    kl_core_Profiler_LoadSegInfo_res_arena_size =
    0,
    kl_core_Profiler_LoadSegInfo_req_handles = 1,
    kl_core_Profiler_LoadSegInfo_res_handles = 0,
    kl_core_Profiler_LoadSegInfo_err_handles = 0,
    kl_core_Profiler_UnloadSegInfo_req_arena_size =
    0,
    kl_core_Profiler_UnloadSegInfo_res_arena_size =
    0,
    kl_core_Profiler_UnloadSegInfo_req_handles =
    1,
    kl_core_Profiler_UnloadSegInfo_res_handles =
    0,
    kl_core_Profiler_UnloadSegInfo_err_handles =
    0,
    kl_core_Profiler_KcovAlloc_req_arena_size = 0,
    kl_core_Profiler_KcovAlloc_res_arena_size = 0,
    kl_core_Profiler_KcovAlloc_req_handles = 0,
    kl_core_Profiler_KcovAlloc_res_handles = 0,
    kl_core_Profiler_KcovAlloc_err_handles = 0,
    kl_core_Profiler_KcovFree_req_arena_size = 0,
    kl_core_Profiler_KcovFree_res_arena_size = 0,
    kl_core_Profiler_KcovFree_req_handles = 0,
    kl_core_Profiler_KcovFree_res_handles = 0,
    kl_core_Profiler_KcovFree_err_handles = 0,
    kl_core_Profiler_KcovStart_req_arena_size = 0,
    kl_core_Profiler_KcovStart_res_arena_size = 0,
    kl_core_Profiler_KcovStart_req_handles = 0,
    kl_core_Profiler_KcovStart_res_handles = 0,
    kl_core_Profiler_KcovStart_err_handles = 0,
    kl_core_Profiler_KcovStop_req_arena_size = 0,
    kl_core_Profiler_KcovStop_res_arena_size = 0,
    kl_core_Profiler_KcovStop_req_handles = 0,
    kl_core_Profiler_KcovStop_res_handles = 0,
    kl_core_Profiler_KcovStop_err_handles = 0,
    kl_core_Profiler_req_arena_size = 9728,
    kl_core_Profiler_res_arena_size = 66560,
    kl_core_Profiler_req_handles = 1,
    kl_core_Profiler_res_handles = 0,
    kl_core_Profiler_err_handles = 0,
};
typedef struct __nk_packed kl_core_Profiler_GetCoverageData_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t index;
        } kl_core_Profiler_GetCoverageData_req;
nk_static_assert(sizeof(kl_core_Profiler_GetCoverageData_req) == 32, bad_kl_core_Profiler_GetCoverageData_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCoverageData_req, base_) == 0, bad_kl_core_Profiler_GetCoverageData_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCoverageData_req, index) == 24, bad_kl_core_Profiler_GetCoverageData_req_index_offset);
#pragma pack(push, 8) /* kl_core_Profiler_GetCoverageData_res */
typedef struct kl_core_Profiler_GetCoverageData_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_GetCoverageData_err;
nk_static_assert(sizeof(kl_core_Profiler_GetCoverageData_err) == 24, bad_kl_core_Profiler_GetCoverageData_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCoverageData_err, base_) == 0, bad_kl_core_Profiler_GetCoverageData_err_base__offset);
typedef struct kl_core_Profiler_GetCoverageData_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t buf;
                    __nk_alignas(8)
                    nk_uint64_t size;
                    __nk_alignas(4) nk_ptr_t name;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t buf;
                    __nk_alignas(8)
                    nk_uint64_t size;
                    __nk_alignas(4) nk_ptr_t name;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_GetCoverageData_err err_;
            };
        } kl_core_Profiler_GetCoverageData_res;
nk_static_assert(sizeof(kl_core_Profiler_GetCoverageData_res) == 56, bad_kl_core_Profiler_GetCoverageData_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCoverageData_res, base_) == 0, bad_kl_core_Profiler_GetCoverageData_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCoverageData_res, buf) == 24, bad_kl_core_Profiler_GetCoverageData_res_buf_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCoverageData_res, size) == 32, bad_kl_core_Profiler_GetCoverageData_res_size_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCoverageData_res, name) == 40, bad_kl_core_Profiler_GetCoverageData_res_name_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCoverageData_res, rc) == 48, bad_kl_core_Profiler_GetCoverageData_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_GetCoverageData_res */
typedef struct __nk_packed kl_core_Profiler_FlushGcov_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_FlushGcov_req;
nk_static_assert(sizeof(kl_core_Profiler_FlushGcov_req) == 24, bad_kl_core_Profiler_FlushGcov_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_FlushGcov_req, base_) == 0, bad_kl_core_Profiler_FlushGcov_req_base__offset);
#pragma pack(push, 8) /* kl_core_Profiler_FlushGcov_res */
typedef struct kl_core_Profiler_FlushGcov_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_FlushGcov_err;
nk_static_assert(sizeof(kl_core_Profiler_FlushGcov_err) == 24, bad_kl_core_Profiler_FlushGcov_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_FlushGcov_err, base_) == 0, bad_kl_core_Profiler_FlushGcov_err_base__offset);
typedef struct kl_core_Profiler_FlushGcov_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_FlushGcov_err err_;
            };
        } kl_core_Profiler_FlushGcov_res;
nk_static_assert(sizeof(kl_core_Profiler_FlushGcov_res) == 32, bad_kl_core_Profiler_FlushGcov_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_FlushGcov_res, base_) == 0, bad_kl_core_Profiler_FlushGcov_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_FlushGcov_res, rc) == 24, bad_kl_core_Profiler_FlushGcov_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_FlushGcov_res */
typedef struct __nk_packed kl_core_Profiler_FlushGcovFile_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t name;
            __nk_alignas(8) nk_uint64_t buf;
            __nk_alignas(8) nk_uint64_t size;
        } kl_core_Profiler_FlushGcovFile_req;
nk_static_assert(sizeof(kl_core_Profiler_FlushGcovFile_req) == 48, bad_kl_core_Profiler_FlushGcovFile_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_FlushGcovFile_req, base_) == 0, bad_kl_core_Profiler_FlushGcovFile_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_FlushGcovFile_req, name) == 24, bad_kl_core_Profiler_FlushGcovFile_req_name_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_FlushGcovFile_req, buf) == 32, bad_kl_core_Profiler_FlushGcovFile_req_buf_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_FlushGcovFile_req, size) == 40, bad_kl_core_Profiler_FlushGcovFile_req_size_offset);
#pragma pack(push, 8) /* kl_core_Profiler_FlushGcovFile_res */
typedef struct kl_core_Profiler_FlushGcovFile_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_FlushGcovFile_err;
nk_static_assert(sizeof(kl_core_Profiler_FlushGcovFile_err) == 24, bad_kl_core_Profiler_FlushGcovFile_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_FlushGcovFile_err, base_) == 0, bad_kl_core_Profiler_FlushGcovFile_err_base__offset);
typedef struct kl_core_Profiler_FlushGcovFile_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_FlushGcovFile_err err_;
            };
        } kl_core_Profiler_FlushGcovFile_res;
nk_static_assert(sizeof(kl_core_Profiler_FlushGcovFile_res) == 32, bad_kl_core_Profiler_FlushGcovFile_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_FlushGcovFile_res, base_) == 0, bad_kl_core_Profiler_FlushGcovFile_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_FlushGcovFile_res, rc) == 24, bad_kl_core_Profiler_FlushGcovFile_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_FlushGcovFile_res */
typedef struct __nk_packed kl_core_Profiler_GetCounters_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t prefix;
            __nk_alignas(4) nk_ptr_t names;
        } kl_core_Profiler_GetCounters_req;
nk_static_assert(sizeof(kl_core_Profiler_GetCounters_req) == 40, bad_kl_core_Profiler_GetCounters_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCounters_req, base_) == 0, bad_kl_core_Profiler_GetCounters_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCounters_req, prefix) == 24, bad_kl_core_Profiler_GetCounters_req_prefix_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCounters_req, names) == 32, bad_kl_core_Profiler_GetCounters_req_names_offset);
#pragma pack(push, 8) /* kl_core_Profiler_GetCounters_res */
typedef struct kl_core_Profiler_GetCounters_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_GetCounters_err;
nk_static_assert(sizeof(kl_core_Profiler_GetCounters_err) == 24, bad_kl_core_Profiler_GetCounters_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCounters_err, base_) == 0, bad_kl_core_Profiler_GetCounters_err_base__offset);
typedef struct kl_core_Profiler_GetCounters_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_ptr_t values;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_ptr_t values;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_GetCounters_err err_;
            };
        } kl_core_Profiler_GetCounters_res;
nk_static_assert(sizeof(kl_core_Profiler_GetCounters_res) == 40, bad_kl_core_Profiler_GetCounters_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCounters_res, base_) == 0, bad_kl_core_Profiler_GetCounters_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCounters_res, values) == 24, bad_kl_core_Profiler_GetCounters_res_values_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_GetCounters_res, rc) == 32, bad_kl_core_Profiler_GetCounters_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_GetCounters_res */
typedef struct __nk_packed kl_core_Profiler_ObjectGetStat_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
            __nk_alignas(4) nk_ptr_t names;
        } kl_core_Profiler_ObjectGetStat_req;
nk_static_assert(sizeof(kl_core_Profiler_ObjectGetStat_req) == 48, bad_kl_core_Profiler_ObjectGetStat_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_ObjectGetStat_req, base_) == 0, bad_kl_core_Profiler_ObjectGetStat_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_ObjectGetStat_req, handle) == 24, bad_kl_core_Profiler_ObjectGetStat_req_handle_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_ObjectGetStat_req, names) == 40, bad_kl_core_Profiler_ObjectGetStat_req_names_offset);
#pragma pack(push, 8) /* kl_core_Profiler_ObjectGetStat_res */
typedef struct kl_core_Profiler_ObjectGetStat_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_ObjectGetStat_err;
nk_static_assert(sizeof(kl_core_Profiler_ObjectGetStat_err) == 24, bad_kl_core_Profiler_ObjectGetStat_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_ObjectGetStat_err, base_) == 0, bad_kl_core_Profiler_ObjectGetStat_err_base__offset);
typedef struct kl_core_Profiler_ObjectGetStat_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_ptr_t values;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_ptr_t values;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_ObjectGetStat_err err_;
            };
        } kl_core_Profiler_ObjectGetStat_res;
nk_static_assert(sizeof(kl_core_Profiler_ObjectGetStat_res) == 40, bad_kl_core_Profiler_ObjectGetStat_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_ObjectGetStat_res, base_) == 0, bad_kl_core_Profiler_ObjectGetStat_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_ObjectGetStat_res, values) == 24, bad_kl_core_Profiler_ObjectGetStat_res_values_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_ObjectGetStat_res, rc) == 32, bad_kl_core_Profiler_ObjectGetStat_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_ObjectGetStat_res */
typedef struct __nk_packed kl_core_Profiler_SamplingStart_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t conf;
            __nk_alignas(4) nk_ptr_t cpus;
            __nk_alignas(8) nk_uint64_t contSize;
            __nk_alignas(8) nk_uint64_t interval;
        } kl_core_Profiler_SamplingStart_req;
nk_static_assert(sizeof(kl_core_Profiler_SamplingStart_req) == 56, bad_kl_core_Profiler_SamplingStart_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingStart_req, base_) == 0, bad_kl_core_Profiler_SamplingStart_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingStart_req, conf) == 24, bad_kl_core_Profiler_SamplingStart_req_conf_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingStart_req, cpus) == 28, bad_kl_core_Profiler_SamplingStart_req_cpus_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingStart_req, contSize) == 40, bad_kl_core_Profiler_SamplingStart_req_contSize_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingStart_req, interval) == 48, bad_kl_core_Profiler_SamplingStart_req_interval_offset);
#pragma pack(push, 8) /* kl_core_Profiler_SamplingStart_res */
typedef struct kl_core_Profiler_SamplingStart_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_SamplingStart_err;
nk_static_assert(sizeof(kl_core_Profiler_SamplingStart_err) == 24, bad_kl_core_Profiler_SamplingStart_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingStart_err, base_) == 0, bad_kl_core_Profiler_SamplingStart_err_base__offset);
typedef struct kl_core_Profiler_SamplingStart_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_SamplingStart_err err_;
            };
        } kl_core_Profiler_SamplingStart_res;
nk_static_assert(sizeof(kl_core_Profiler_SamplingStart_res) == 32, bad_kl_core_Profiler_SamplingStart_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingStart_res, base_) == 0, bad_kl_core_Profiler_SamplingStart_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingStart_res, rc) == 24, bad_kl_core_Profiler_SamplingStart_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_SamplingStart_res */
typedef struct __nk_packed kl_core_Profiler_SamplingStop_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_SamplingStop_req;
nk_static_assert(sizeof(kl_core_Profiler_SamplingStop_req) == 24, bad_kl_core_Profiler_SamplingStop_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingStop_req, base_) == 0, bad_kl_core_Profiler_SamplingStop_req_base__offset);
#pragma pack(push, 8) /* kl_core_Profiler_SamplingStop_res */
typedef struct kl_core_Profiler_SamplingStop_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_SamplingStop_err;
nk_static_assert(sizeof(kl_core_Profiler_SamplingStop_err) == 24, bad_kl_core_Profiler_SamplingStop_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingStop_err, base_) == 0, bad_kl_core_Profiler_SamplingStop_err_base__offset);
typedef struct kl_core_Profiler_SamplingStop_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_SamplingStop_err err_;
            };
        } kl_core_Profiler_SamplingStop_res;
nk_static_assert(sizeof(kl_core_Profiler_SamplingStop_res) == 32, bad_kl_core_Profiler_SamplingStop_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingStop_res, base_) == 0, bad_kl_core_Profiler_SamplingStop_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingStop_res, rc) == 24, bad_kl_core_Profiler_SamplingStop_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_SamplingStop_res */
typedef struct __nk_packed kl_core_Profiler_SamplingRead_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8)
            nk_uint64_t unsafeBuffer;
            __nk_alignas(8) nk_uint64_t size;
            __nk_alignas(4) nk_uint32_t timeout;
        } kl_core_Profiler_SamplingRead_req;
nk_static_assert(sizeof(kl_core_Profiler_SamplingRead_req) == 48, bad_kl_core_Profiler_SamplingRead_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingRead_req, base_) == 0, bad_kl_core_Profiler_SamplingRead_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingRead_req, unsafeBuffer) == 24, bad_kl_core_Profiler_SamplingRead_req_unsafeBuffer_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingRead_req, size) == 32, bad_kl_core_Profiler_SamplingRead_req_size_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingRead_req, timeout) == 40, bad_kl_core_Profiler_SamplingRead_req_timeout_offset);
#pragma pack(push, 8) /* kl_core_Profiler_SamplingRead_res */
typedef struct kl_core_Profiler_SamplingRead_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_SamplingRead_err;
nk_static_assert(sizeof(kl_core_Profiler_SamplingRead_err) == 24, bad_kl_core_Profiler_SamplingRead_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingRead_err, base_) == 0, bad_kl_core_Profiler_SamplingRead_err_base__offset);
typedef struct kl_core_Profiler_SamplingRead_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t realSize;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t realSize;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_SamplingRead_err err_;
            };
        } kl_core_Profiler_SamplingRead_res;
nk_static_assert(sizeof(kl_core_Profiler_SamplingRead_res) == 40, bad_kl_core_Profiler_SamplingRead_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingRead_res, base_) == 0, bad_kl_core_Profiler_SamplingRead_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingRead_res, realSize) == 24, bad_kl_core_Profiler_SamplingRead_res_realSize_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingRead_res, rc) == 32, bad_kl_core_Profiler_SamplingRead_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_SamplingRead_res */
typedef struct __nk_packed kl_core_Profiler_SamplingAddPidToList_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t pid;
        }
kl_core_Profiler_SamplingAddPidToList_req;
nk_static_assert(sizeof(kl_core_Profiler_SamplingAddPidToList_req) == 32, bad_kl_core_Profiler_SamplingAddPidToList_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingAddPidToList_req, base_) == 0, bad_kl_core_Profiler_SamplingAddPidToList_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingAddPidToList_req, pid) == 24, bad_kl_core_Profiler_SamplingAddPidToList_req_pid_offset);
#pragma pack(push, 8) /* kl_core_Profiler_SamplingAddPidToList_res */
typedef struct kl_core_Profiler_SamplingAddPidToList_err {
            __nk_alignas(8)
            struct nk_message base_;
        }
kl_core_Profiler_SamplingAddPidToList_err;
nk_static_assert(sizeof(kl_core_Profiler_SamplingAddPidToList_err) == 24, bad_kl_core_Profiler_SamplingAddPidToList_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingAddPidToList_err, base_) == 0, bad_kl_core_Profiler_SamplingAddPidToList_err_base__offset);
typedef struct kl_core_Profiler_SamplingAddPidToList_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_SamplingAddPidToList_err err_;
            };
        }
kl_core_Profiler_SamplingAddPidToList_res;
nk_static_assert(sizeof(kl_core_Profiler_SamplingAddPidToList_res) == 32, bad_kl_core_Profiler_SamplingAddPidToList_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingAddPidToList_res, base_) == 0, bad_kl_core_Profiler_SamplingAddPidToList_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingAddPidToList_res, rc) == 24, bad_kl_core_Profiler_SamplingAddPidToList_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_SamplingAddPidToList_res */
typedef struct __nk_packed kl_core_Profiler_SamplingClearPidList_req {
            __nk_alignas(8)
            struct nk_message base_;
        }
kl_core_Profiler_SamplingClearPidList_req;
nk_static_assert(sizeof(kl_core_Profiler_SamplingClearPidList_req) == 24, bad_kl_core_Profiler_SamplingClearPidList_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingClearPidList_req, base_) == 0, bad_kl_core_Profiler_SamplingClearPidList_req_base__offset);
#pragma pack(push, 8) /* kl_core_Profiler_SamplingClearPidList_res */
typedef struct kl_core_Profiler_SamplingClearPidList_err {
            __nk_alignas(8)
            struct nk_message base_;
        }
kl_core_Profiler_SamplingClearPidList_err;
nk_static_assert(sizeof(kl_core_Profiler_SamplingClearPidList_err) == 24, bad_kl_core_Profiler_SamplingClearPidList_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingClearPidList_err, base_) == 0, bad_kl_core_Profiler_SamplingClearPidList_err_base__offset);
typedef struct kl_core_Profiler_SamplingClearPidList_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_SamplingClearPidList_err err_;
            };
        }
kl_core_Profiler_SamplingClearPidList_res;
nk_static_assert(sizeof(kl_core_Profiler_SamplingClearPidList_res) == 32, bad_kl_core_Profiler_SamplingClearPidList_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingClearPidList_res, base_) == 0, bad_kl_core_Profiler_SamplingClearPidList_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_SamplingClearPidList_res, rc) == 24, bad_kl_core_Profiler_SamplingClearPidList_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_SamplingClearPidList_res */
typedef struct __nk_packed kl_core_Profiler_LoadSegInfo_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(8) nk_uint64_t addr;
            __nk_alignas(8) nk_uint64_t size;
            __nk_alignas(8) nk_uint64_t offset;
            __nk_alignas(4) nk_uint32_t flags;
            __nk_alignas(4) nk_ptr_t buildId;
        } kl_core_Profiler_LoadSegInfo_req;
nk_static_assert(sizeof(kl_core_Profiler_LoadSegInfo_req) == 80, bad_kl_core_Profiler_LoadSegInfo_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_LoadSegInfo_req, base_) == 0, bad_kl_core_Profiler_LoadSegInfo_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_LoadSegInfo_req, task) == 24, bad_kl_core_Profiler_LoadSegInfo_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_LoadSegInfo_req, addr) == 40, bad_kl_core_Profiler_LoadSegInfo_req_addr_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_LoadSegInfo_req, size) == 48, bad_kl_core_Profiler_LoadSegInfo_req_size_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_LoadSegInfo_req, offset) == 56, bad_kl_core_Profiler_LoadSegInfo_req_offset_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_LoadSegInfo_req, flags) == 64, bad_kl_core_Profiler_LoadSegInfo_req_flags_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_LoadSegInfo_req, buildId) == 68, bad_kl_core_Profiler_LoadSegInfo_req_buildId_offset);
#pragma pack(push, 8) /* kl_core_Profiler_LoadSegInfo_res */
typedef struct kl_core_Profiler_LoadSegInfo_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_LoadSegInfo_err;
nk_static_assert(sizeof(kl_core_Profiler_LoadSegInfo_err) == 24, bad_kl_core_Profiler_LoadSegInfo_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_LoadSegInfo_err, base_) == 0, bad_kl_core_Profiler_LoadSegInfo_err_base__offset);
typedef struct kl_core_Profiler_LoadSegInfo_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_LoadSegInfo_err err_;
            };
        } kl_core_Profiler_LoadSegInfo_res;
nk_static_assert(sizeof(kl_core_Profiler_LoadSegInfo_res) == 32, bad_kl_core_Profiler_LoadSegInfo_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_LoadSegInfo_res, base_) == 0, bad_kl_core_Profiler_LoadSegInfo_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_LoadSegInfo_res, rc) == 24, bad_kl_core_Profiler_LoadSegInfo_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_LoadSegInfo_res */
typedef struct __nk_packed kl_core_Profiler_UnloadSegInfo_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(8) nk_uint64_t addr;
            __nk_alignas(8) nk_uint64_t size;
        } kl_core_Profiler_UnloadSegInfo_req;
nk_static_assert(sizeof(kl_core_Profiler_UnloadSegInfo_req) == 56, bad_kl_core_Profiler_UnloadSegInfo_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_UnloadSegInfo_req, base_) == 0, bad_kl_core_Profiler_UnloadSegInfo_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_UnloadSegInfo_req, task) == 24, bad_kl_core_Profiler_UnloadSegInfo_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_UnloadSegInfo_req, addr) == 40, bad_kl_core_Profiler_UnloadSegInfo_req_addr_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_UnloadSegInfo_req, size) == 48, bad_kl_core_Profiler_UnloadSegInfo_req_size_offset);
#pragma pack(push, 8) /* kl_core_Profiler_UnloadSegInfo_res */
typedef struct kl_core_Profiler_UnloadSegInfo_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_UnloadSegInfo_err;
nk_static_assert(sizeof(kl_core_Profiler_UnloadSegInfo_err) == 24, bad_kl_core_Profiler_UnloadSegInfo_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_UnloadSegInfo_err, base_) == 0, bad_kl_core_Profiler_UnloadSegInfo_err_base__offset);
typedef struct kl_core_Profiler_UnloadSegInfo_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_UnloadSegInfo_err err_;
            };
        } kl_core_Profiler_UnloadSegInfo_res;
nk_static_assert(sizeof(kl_core_Profiler_UnloadSegInfo_res) == 32, bad_kl_core_Profiler_UnloadSegInfo_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_UnloadSegInfo_res, base_) == 0, bad_kl_core_Profiler_UnloadSegInfo_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_UnloadSegInfo_res, rc) == 24, bad_kl_core_Profiler_UnloadSegInfo_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_UnloadSegInfo_res */
typedef struct __nk_packed kl_core_Profiler_KcovAlloc_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8)
            nk_uint64_t numThreads;
            __nk_alignas(8) nk_uint64_t maxPoints;
        } kl_core_Profiler_KcovAlloc_req;
nk_static_assert(sizeof(kl_core_Profiler_KcovAlloc_req) == 40, bad_kl_core_Profiler_KcovAlloc_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovAlloc_req, base_) == 0, bad_kl_core_Profiler_KcovAlloc_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovAlloc_req, numThreads) == 24, bad_kl_core_Profiler_KcovAlloc_req_numThreads_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovAlloc_req, maxPoints) == 32, bad_kl_core_Profiler_KcovAlloc_req_maxPoints_offset);
#pragma pack(push, 8) /* kl_core_Profiler_KcovAlloc_res */
typedef struct kl_core_Profiler_KcovAlloc_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_KcovAlloc_err;
nk_static_assert(sizeof(kl_core_Profiler_KcovAlloc_err) == 24, bad_kl_core_Profiler_KcovAlloc_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovAlloc_err, base_) == 0, bad_kl_core_Profiler_KcovAlloc_err_base__offset);
typedef struct kl_core_Profiler_KcovAlloc_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_KcovAlloc_err err_;
            };
        } kl_core_Profiler_KcovAlloc_res;
nk_static_assert(sizeof(kl_core_Profiler_KcovAlloc_res) == 32, bad_kl_core_Profiler_KcovAlloc_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovAlloc_res, base_) == 0, bad_kl_core_Profiler_KcovAlloc_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovAlloc_res, rc) == 24, bad_kl_core_Profiler_KcovAlloc_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_KcovAlloc_res */
typedef struct __nk_packed kl_core_Profiler_KcovFree_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_KcovFree_req;
nk_static_assert(sizeof(kl_core_Profiler_KcovFree_req) == 24, bad_kl_core_Profiler_KcovFree_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovFree_req, base_) == 0, bad_kl_core_Profiler_KcovFree_req_base__offset);
#pragma pack(push, 8) /* kl_core_Profiler_KcovFree_res */
typedef struct kl_core_Profiler_KcovFree_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_KcovFree_err;
nk_static_assert(sizeof(kl_core_Profiler_KcovFree_err) == 24, bad_kl_core_Profiler_KcovFree_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovFree_err, base_) == 0, bad_kl_core_Profiler_KcovFree_err_base__offset);
typedef struct kl_core_Profiler_KcovFree_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_KcovFree_err err_;
            };
        } kl_core_Profiler_KcovFree_res;
nk_static_assert(sizeof(kl_core_Profiler_KcovFree_res) == 32, bad_kl_core_Profiler_KcovFree_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovFree_res, base_) == 0, bad_kl_core_Profiler_KcovFree_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovFree_res, rc) == 24, bad_kl_core_Profiler_KcovFree_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_KcovFree_res */
typedef struct __nk_packed kl_core_Profiler_KcovStart_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_KcovStart_req;
nk_static_assert(sizeof(kl_core_Profiler_KcovStart_req) == 24, bad_kl_core_Profiler_KcovStart_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovStart_req, base_) == 0, bad_kl_core_Profiler_KcovStart_req_base__offset);
#pragma pack(push, 8) /* kl_core_Profiler_KcovStart_res */
typedef struct kl_core_Profiler_KcovStart_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_KcovStart_err;
nk_static_assert(sizeof(kl_core_Profiler_KcovStart_err) == 24, bad_kl_core_Profiler_KcovStart_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovStart_err, base_) == 0, bad_kl_core_Profiler_KcovStart_err_base__offset);
typedef struct kl_core_Profiler_KcovStart_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_KcovStart_err err_;
            };
        } kl_core_Profiler_KcovStart_res;
nk_static_assert(sizeof(kl_core_Profiler_KcovStart_res) == 32, bad_kl_core_Profiler_KcovStart_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovStart_res, base_) == 0, bad_kl_core_Profiler_KcovStart_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovStart_res, rc) == 24, bad_kl_core_Profiler_KcovStart_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_KcovStart_res */
typedef struct __nk_packed kl_core_Profiler_KcovStop_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t points;
            __nk_alignas(8) nk_uint64_t maxPoints;
        } kl_core_Profiler_KcovStop_req;
nk_static_assert(sizeof(kl_core_Profiler_KcovStop_req) == 40, bad_kl_core_Profiler_KcovStop_req_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovStop_req, base_) == 0, bad_kl_core_Profiler_KcovStop_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovStop_req, points) == 24, bad_kl_core_Profiler_KcovStop_req_points_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovStop_req, maxPoints) == 32, bad_kl_core_Profiler_KcovStop_req_maxPoints_offset);
#pragma pack(push, 8) /* kl_core_Profiler_KcovStop_res */
typedef struct kl_core_Profiler_KcovStop_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Profiler_KcovStop_err;
nk_static_assert(sizeof(kl_core_Profiler_KcovStop_err) == 24, bad_kl_core_Profiler_KcovStop_err_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovStop_err, base_) == 0, bad_kl_core_Profiler_KcovStop_err_base__offset);
typedef struct kl_core_Profiler_KcovStop_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t numPoints;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t numPoints;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Profiler_KcovStop_err err_;
            };
        } kl_core_Profiler_KcovStop_res;
nk_static_assert(sizeof(kl_core_Profiler_KcovStop_res) == 40, bad_kl_core_Profiler_KcovStop_res_size);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovStop_res, base_) == 0, bad_kl_core_Profiler_KcovStop_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovStop_res, numPoints) == 24, bad_kl_core_Profiler_KcovStop_res_numPoints_offset);
nk_static_assert(nk_offsetof(kl_core_Profiler_KcovStop_res, rc) == 32, bad_kl_core_Profiler_KcovStop_res_rc_offset);
#pragma pack(pop) /* kl_core_Profiler_KcovStop_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Profiler_GetCoverageData_mid kl_core_Profiler_GetCoverageData_mid
#define Profiler_FlushGcov_mid kl_core_Profiler_FlushGcov_mid
#define Profiler_FlushGcovFile_mid kl_core_Profiler_FlushGcovFile_mid
#define Profiler_GetCounters_mid kl_core_Profiler_GetCounters_mid
#define Profiler_ObjectGetStat_mid kl_core_Profiler_ObjectGetStat_mid
#define Profiler_SamplingStart_mid kl_core_Profiler_SamplingStart_mid
#define Profiler_SamplingStop_mid kl_core_Profiler_SamplingStop_mid
#define Profiler_SamplingRead_mid kl_core_Profiler_SamplingRead_mid
#define Profiler_SamplingAddPidToList_mid kl_core_Profiler_SamplingAddPidToList_mid
#define Profiler_SamplingClearPidList_mid kl_core_Profiler_SamplingClearPidList_mid
#define Profiler_LoadSegInfo_mid kl_core_Profiler_LoadSegInfo_mid
#define Profiler_UnloadSegInfo_mid kl_core_Profiler_UnloadSegInfo_mid
#define Profiler_KcovAlloc_mid kl_core_Profiler_KcovAlloc_mid
#define Profiler_KcovFree_mid kl_core_Profiler_KcovFree_mid
#define Profiler_KcovStart_mid kl_core_Profiler_KcovStart_mid
#define Profiler_KcovStop_mid kl_core_Profiler_KcovStop_mid
#define Profiler_mid_max kl_core_Profiler_mid_max
#define Profiler_GetCoverageData_res_buf_size kl_core_Profiler_GetCoverageData_res_buf_size
#define Profiler_GetCoverageData_res_name_size kl_core_Profiler_GetCoverageData_res_name_size
#define Profiler_GetCoverageData_req_arena_size kl_core_Profiler_GetCoverageData_req_arena_size
#define Profiler_GetCoverageData_res_arena_size kl_core_Profiler_GetCoverageData_res_arena_size
#define Profiler_GetCoverageData_req_handles kl_core_Profiler_GetCoverageData_req_handles
#define Profiler_GetCoverageData_res_handles kl_core_Profiler_GetCoverageData_res_handles
#define Profiler_GetCoverageData_err_handles kl_core_Profiler_GetCoverageData_err_handles
#define Profiler_FlushGcov_req_arena_size kl_core_Profiler_FlushGcov_req_arena_size
#define Profiler_FlushGcov_res_arena_size kl_core_Profiler_FlushGcov_res_arena_size
#define Profiler_FlushGcov_req_handles kl_core_Profiler_FlushGcov_req_handles
#define Profiler_FlushGcov_res_handles kl_core_Profiler_FlushGcov_res_handles
#define Profiler_FlushGcov_err_handles kl_core_Profiler_FlushGcov_err_handles
#define Profiler_FlushGcovFile_req_name_size kl_core_Profiler_FlushGcovFile_req_name_size
#define Profiler_FlushGcovFile_req_arena_size kl_core_Profiler_FlushGcovFile_req_arena_size
#define Profiler_FlushGcovFile_res_arena_size kl_core_Profiler_FlushGcovFile_res_arena_size
#define Profiler_FlushGcovFile_req_handles kl_core_Profiler_FlushGcovFile_req_handles
#define Profiler_FlushGcovFile_res_handles kl_core_Profiler_FlushGcovFile_res_handles
#define Profiler_FlushGcovFile_err_handles kl_core_Profiler_FlushGcovFile_err_handles
#define Profiler_GetCounters_req_prefix_size kl_core_Profiler_GetCounters_req_prefix_size
#define Profiler_GetCounters_req_names_size kl_core_Profiler_GetCounters_req_names_size
#define Profiler_GetCounters_req_names_elem_size kl_core_Profiler_GetCounters_req_names_elem_size
#define Profiler_GetCounters_res_values_size kl_core_Profiler_GetCounters_res_values_size
#define Profiler_GetCounters_req_arena_size kl_core_Profiler_GetCounters_req_arena_size
#define Profiler_GetCounters_res_arena_size kl_core_Profiler_GetCounters_res_arena_size
#define Profiler_GetCounters_req_handles kl_core_Profiler_GetCounters_req_handles
#define Profiler_GetCounters_res_handles kl_core_Profiler_GetCounters_res_handles
#define Profiler_GetCounters_err_handles kl_core_Profiler_GetCounters_err_handles
#define Profiler_ObjectGetStat_req_names_size kl_core_Profiler_ObjectGetStat_req_names_size
#define Profiler_ObjectGetStat_req_names_elem_size kl_core_Profiler_ObjectGetStat_req_names_elem_size
#define Profiler_ObjectGetStat_res_values_size kl_core_Profiler_ObjectGetStat_res_values_size
#define Profiler_ObjectGetStat_req_arena_size kl_core_Profiler_ObjectGetStat_req_arena_size
#define Profiler_ObjectGetStat_res_arena_size kl_core_Profiler_ObjectGetStat_res_arena_size
#define Profiler_ObjectGetStat_req_handles kl_core_Profiler_ObjectGetStat_req_handles
#define Profiler_ObjectGetStat_res_handles kl_core_Profiler_ObjectGetStat_res_handles
#define Profiler_ObjectGetStat_err_handles kl_core_Profiler_ObjectGetStat_err_handles
#define Profiler_SamplingStart_req_cpus_size kl_core_Profiler_SamplingStart_req_cpus_size
#define Profiler_SamplingStart_req_arena_size kl_core_Profiler_SamplingStart_req_arena_size
#define Profiler_SamplingStart_res_arena_size kl_core_Profiler_SamplingStart_res_arena_size
#define Profiler_SamplingStart_req_handles kl_core_Profiler_SamplingStart_req_handles
#define Profiler_SamplingStart_res_handles kl_core_Profiler_SamplingStart_res_handles
#define Profiler_SamplingStart_err_handles kl_core_Profiler_SamplingStart_err_handles
#define Profiler_SamplingStop_req_arena_size kl_core_Profiler_SamplingStop_req_arena_size
#define Profiler_SamplingStop_res_arena_size kl_core_Profiler_SamplingStop_res_arena_size
#define Profiler_SamplingStop_req_handles kl_core_Profiler_SamplingStop_req_handles
#define Profiler_SamplingStop_res_handles kl_core_Profiler_SamplingStop_res_handles
#define Profiler_SamplingStop_err_handles kl_core_Profiler_SamplingStop_err_handles
#define Profiler_SamplingRead_req_arena_size kl_core_Profiler_SamplingRead_req_arena_size
#define Profiler_SamplingRead_res_arena_size kl_core_Profiler_SamplingRead_res_arena_size
#define Profiler_SamplingRead_req_handles kl_core_Profiler_SamplingRead_req_handles
#define Profiler_SamplingRead_res_handles kl_core_Profiler_SamplingRead_res_handles
#define Profiler_SamplingRead_err_handles kl_core_Profiler_SamplingRead_err_handles
#define Profiler_SamplingAddPidToList_req_arena_size kl_core_Profiler_SamplingAddPidToList_req_arena_size
#define Profiler_SamplingAddPidToList_res_arena_size kl_core_Profiler_SamplingAddPidToList_res_arena_size
#define Profiler_SamplingAddPidToList_req_handles kl_core_Profiler_SamplingAddPidToList_req_handles
#define Profiler_SamplingAddPidToList_res_handles kl_core_Profiler_SamplingAddPidToList_res_handles
#define Profiler_SamplingAddPidToList_err_handles kl_core_Profiler_SamplingAddPidToList_err_handles
#define Profiler_SamplingClearPidList_req_arena_size kl_core_Profiler_SamplingClearPidList_req_arena_size
#define Profiler_SamplingClearPidList_res_arena_size kl_core_Profiler_SamplingClearPidList_res_arena_size
#define Profiler_SamplingClearPidList_req_handles kl_core_Profiler_SamplingClearPidList_req_handles
#define Profiler_SamplingClearPidList_res_handles kl_core_Profiler_SamplingClearPidList_res_handles
#define Profiler_SamplingClearPidList_err_handles kl_core_Profiler_SamplingClearPidList_err_handles
#define Profiler_LoadSegInfo_req_buildId_size kl_core_Profiler_LoadSegInfo_req_buildId_size
#define Profiler_LoadSegInfo_req_arena_size kl_core_Profiler_LoadSegInfo_req_arena_size
#define Profiler_LoadSegInfo_res_arena_size kl_core_Profiler_LoadSegInfo_res_arena_size
#define Profiler_LoadSegInfo_req_handles kl_core_Profiler_LoadSegInfo_req_handles
#define Profiler_LoadSegInfo_res_handles kl_core_Profiler_LoadSegInfo_res_handles
#define Profiler_LoadSegInfo_err_handles kl_core_Profiler_LoadSegInfo_err_handles
#define Profiler_UnloadSegInfo_req_arena_size kl_core_Profiler_UnloadSegInfo_req_arena_size
#define Profiler_UnloadSegInfo_res_arena_size kl_core_Profiler_UnloadSegInfo_res_arena_size
#define Profiler_UnloadSegInfo_req_handles kl_core_Profiler_UnloadSegInfo_req_handles
#define Profiler_UnloadSegInfo_res_handles kl_core_Profiler_UnloadSegInfo_res_handles
#define Profiler_UnloadSegInfo_err_handles kl_core_Profiler_UnloadSegInfo_err_handles
#define Profiler_KcovAlloc_req_arena_size kl_core_Profiler_KcovAlloc_req_arena_size
#define Profiler_KcovAlloc_res_arena_size kl_core_Profiler_KcovAlloc_res_arena_size
#define Profiler_KcovAlloc_req_handles kl_core_Profiler_KcovAlloc_req_handles
#define Profiler_KcovAlloc_res_handles kl_core_Profiler_KcovAlloc_res_handles
#define Profiler_KcovAlloc_err_handles kl_core_Profiler_KcovAlloc_err_handles
#define Profiler_KcovFree_req_arena_size kl_core_Profiler_KcovFree_req_arena_size
#define Profiler_KcovFree_res_arena_size kl_core_Profiler_KcovFree_res_arena_size
#define Profiler_KcovFree_req_handles kl_core_Profiler_KcovFree_req_handles
#define Profiler_KcovFree_res_handles kl_core_Profiler_KcovFree_res_handles
#define Profiler_KcovFree_err_handles kl_core_Profiler_KcovFree_err_handles
#define Profiler_KcovStart_req_arena_size kl_core_Profiler_KcovStart_req_arena_size
#define Profiler_KcovStart_res_arena_size kl_core_Profiler_KcovStart_res_arena_size
#define Profiler_KcovStart_req_handles kl_core_Profiler_KcovStart_req_handles
#define Profiler_KcovStart_res_handles kl_core_Profiler_KcovStart_res_handles
#define Profiler_KcovStart_err_handles kl_core_Profiler_KcovStart_err_handles
#define Profiler_KcovStop_req_arena_size kl_core_Profiler_KcovStop_req_arena_size
#define Profiler_KcovStop_res_arena_size kl_core_Profiler_KcovStop_res_arena_size
#define Profiler_KcovStop_req_handles kl_core_Profiler_KcovStop_req_handles
#define Profiler_KcovStop_res_handles kl_core_Profiler_KcovStop_res_handles
#define Profiler_KcovStop_err_handles kl_core_Profiler_KcovStop_err_handles
#define Profiler_req_arena_size kl_core_Profiler_req_arena_size
#define Profiler_res_arena_size kl_core_Profiler_res_arena_size
#define Profiler_req_handles kl_core_Profiler_req_handles
#define Profiler_res_handles kl_core_Profiler_res_handles
#define Profiler_err_handles kl_core_Profiler_err_handles
#define Profiler_GetCoverageData_req kl_core_Profiler_GetCoverageData_req
#define Profiler_GetCoverageData_res kl_core_Profiler_GetCoverageData_res
#define Profiler_FlushGcov_req kl_core_Profiler_FlushGcov_req
#define Profiler_FlushGcov_res kl_core_Profiler_FlushGcov_res
#define Profiler_FlushGcovFile_req kl_core_Profiler_FlushGcovFile_req
#define Profiler_FlushGcovFile_res kl_core_Profiler_FlushGcovFile_res
#define Profiler_GetCounters_req kl_core_Profiler_GetCounters_req
#define Profiler_GetCounters_res kl_core_Profiler_GetCounters_res
#define Profiler_ObjectGetStat_req kl_core_Profiler_ObjectGetStat_req
#define Profiler_ObjectGetStat_res kl_core_Profiler_ObjectGetStat_res
#define Profiler_SamplingStart_req kl_core_Profiler_SamplingStart_req
#define Profiler_SamplingStart_res kl_core_Profiler_SamplingStart_res
#define Profiler_SamplingStop_req kl_core_Profiler_SamplingStop_req
#define Profiler_SamplingStop_res kl_core_Profiler_SamplingStop_res
#define Profiler_SamplingRead_req kl_core_Profiler_SamplingRead_req
#define Profiler_SamplingRead_res kl_core_Profiler_SamplingRead_res
#define Profiler_SamplingAddPidToList_req kl_core_Profiler_SamplingAddPidToList_req
#define Profiler_SamplingAddPidToList_res kl_core_Profiler_SamplingAddPidToList_res
#define Profiler_SamplingClearPidList_req kl_core_Profiler_SamplingClearPidList_req
#define Profiler_SamplingClearPidList_res kl_core_Profiler_SamplingClearPidList_res
#define Profiler_LoadSegInfo_req kl_core_Profiler_LoadSegInfo_req
#define Profiler_LoadSegInfo_res kl_core_Profiler_LoadSegInfo_res
#define Profiler_UnloadSegInfo_req kl_core_Profiler_UnloadSegInfo_req
#define Profiler_UnloadSegInfo_res kl_core_Profiler_UnloadSegInfo_res
#define Profiler_KcovAlloc_req kl_core_Profiler_KcovAlloc_req
#define Profiler_KcovAlloc_res kl_core_Profiler_KcovAlloc_res
#define Profiler_KcovFree_req kl_core_Profiler_KcovFree_req
#define Profiler_KcovFree_res kl_core_Profiler_KcovFree_res
#define Profiler_KcovStart_req kl_core_Profiler_KcovStart_req
#define Profiler_KcovStart_res kl_core_Profiler_KcovStart_res
#define Profiler_KcovStop_req kl_core_Profiler_KcovStop_req
#define Profiler_KcovStop_res kl_core_Profiler_KcovStop_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Profiler__INTERFACE__ */

#ifndef __kl_core__Sync__INTERFACE__
#define __kl_core__Sync__INTERFACE__
enum {
    kl_core_Sync_Wait_mid,
    kl_core_Sync_Wake_mid,
    kl_core_Sync_mid_max,
};
enum {
    kl_core_Sync_Wait_req_arena_size = 0,
    kl_core_Sync_Wait_res_arena_size = 0,
    kl_core_Sync_Wait_req_handles = 0,
    kl_core_Sync_Wait_res_handles = 0,
    kl_core_Sync_Wait_err_handles = 0,
    kl_core_Sync_Wake_req_arena_size = 0,
    kl_core_Sync_Wake_res_arena_size = 0,
    kl_core_Sync_Wake_req_handles = 0,
    kl_core_Sync_Wake_res_handles = 0,
    kl_core_Sync_Wake_err_handles = 0,
    kl_core_Sync_req_arena_size = 0,
    kl_core_Sync_res_arena_size = 0,
    kl_core_Sync_req_handles = 0,
    kl_core_Sync_res_handles = 0,
    kl_core_Sync_err_handles = 0,
};
typedef struct __nk_packed kl_core_Sync_Wait_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t ptr;
            __nk_alignas(4) nk_uint32_t val;
            __nk_alignas(4) nk_uint32_t delay;
        } kl_core_Sync_Wait_req;
nk_static_assert(sizeof(kl_core_Sync_Wait_req) == 40, bad_kl_core_Sync_Wait_req_size);
nk_static_assert(nk_offsetof(kl_core_Sync_Wait_req, base_) == 0, bad_kl_core_Sync_Wait_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Sync_Wait_req, ptr) == 24, bad_kl_core_Sync_Wait_req_ptr_offset);
nk_static_assert(nk_offsetof(kl_core_Sync_Wait_req, val) == 32, bad_kl_core_Sync_Wait_req_val_offset);
nk_static_assert(nk_offsetof(kl_core_Sync_Wait_req, delay) == 36, bad_kl_core_Sync_Wait_req_delay_offset);
#pragma pack(push, 8) /* kl_core_Sync_Wait_res */
typedef struct kl_core_Sync_Wait_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Sync_Wait_err;
nk_static_assert(sizeof(kl_core_Sync_Wait_err) == 24, bad_kl_core_Sync_Wait_err_size);
nk_static_assert(nk_offsetof(kl_core_Sync_Wait_err, base_) == 0, bad_kl_core_Sync_Wait_err_base__offset);
typedef struct kl_core_Sync_Wait_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t outDelay;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t outDelay;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Sync_Wait_err err_;
            };
        } kl_core_Sync_Wait_res;
nk_static_assert(sizeof(kl_core_Sync_Wait_res) == 32, bad_kl_core_Sync_Wait_res_size);
nk_static_assert(nk_offsetof(kl_core_Sync_Wait_res, base_) == 0, bad_kl_core_Sync_Wait_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Sync_Wait_res, outDelay) == 24, bad_kl_core_Sync_Wait_res_outDelay_offset);
nk_static_assert(nk_offsetof(kl_core_Sync_Wait_res, rc) == 28, bad_kl_core_Sync_Wait_res_rc_offset);
#pragma pack(pop) /* kl_core_Sync_Wait_res */
typedef struct __nk_packed kl_core_Sync_Wake_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t ptr;
            __nk_alignas(4) nk_uint32_t nThreads;
        } kl_core_Sync_Wake_req;
nk_static_assert(sizeof(kl_core_Sync_Wake_req) == 40, bad_kl_core_Sync_Wake_req_size);
nk_static_assert(nk_offsetof(kl_core_Sync_Wake_req, base_) == 0, bad_kl_core_Sync_Wake_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Sync_Wake_req, ptr) == 24, bad_kl_core_Sync_Wake_req_ptr_offset);
nk_static_assert(nk_offsetof(kl_core_Sync_Wake_req, nThreads) == 32, bad_kl_core_Sync_Wake_req_nThreads_offset);
#pragma pack(push, 8) /* kl_core_Sync_Wake_res */
typedef struct kl_core_Sync_Wake_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Sync_Wake_err;
nk_static_assert(sizeof(kl_core_Sync_Wake_err) == 24, bad_kl_core_Sync_Wake_err_size);
nk_static_assert(nk_offsetof(kl_core_Sync_Wake_err, base_) == 0, bad_kl_core_Sync_Wake_err_base__offset);
typedef struct kl_core_Sync_Wake_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t wokenCnt;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t wokenCnt;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Sync_Wake_err err_;
            };
        } kl_core_Sync_Wake_res;
nk_static_assert(sizeof(kl_core_Sync_Wake_res) == 32, bad_kl_core_Sync_Wake_res_size);
nk_static_assert(nk_offsetof(kl_core_Sync_Wake_res, base_) == 0, bad_kl_core_Sync_Wake_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Sync_Wake_res, wokenCnt) == 24, bad_kl_core_Sync_Wake_res_wokenCnt_offset);
nk_static_assert(nk_offsetof(kl_core_Sync_Wake_res, rc) == 28, bad_kl_core_Sync_Wake_res_rc_offset);
#pragma pack(pop) /* kl_core_Sync_Wake_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Sync_Wait_mid kl_core_Sync_Wait_mid
#define Sync_Wake_mid kl_core_Sync_Wake_mid
#define Sync_mid_max kl_core_Sync_mid_max
#define Sync_Wait_req_arena_size kl_core_Sync_Wait_req_arena_size
#define Sync_Wait_res_arena_size kl_core_Sync_Wait_res_arena_size
#define Sync_Wait_req_handles kl_core_Sync_Wait_req_handles
#define Sync_Wait_res_handles kl_core_Sync_Wait_res_handles
#define Sync_Wait_err_handles kl_core_Sync_Wait_err_handles
#define Sync_Wake_req_arena_size kl_core_Sync_Wake_req_arena_size
#define Sync_Wake_res_arena_size kl_core_Sync_Wake_res_arena_size
#define Sync_Wake_req_handles kl_core_Sync_Wake_req_handles
#define Sync_Wake_res_handles kl_core_Sync_Wake_res_handles
#define Sync_Wake_err_handles kl_core_Sync_Wake_err_handles
#define Sync_req_arena_size kl_core_Sync_req_arena_size
#define Sync_res_arena_size kl_core_Sync_res_arena_size
#define Sync_req_handles kl_core_Sync_req_handles
#define Sync_res_handles kl_core_Sync_res_handles
#define Sync_err_handles kl_core_Sync_err_handles
#define Sync_Wait_req kl_core_Sync_Wait_req
#define Sync_Wait_res kl_core_Sync_Wait_res
#define Sync_Wake_req kl_core_Sync_Wake_req
#define Sync_Wake_res kl_core_Sync_Wake_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Sync__INTERFACE__ */

#ifndef __kl_core__TaskDebug__INTERFACE__
#define __kl_core__TaskDebug__INTERFACE__
enum {
    kl_core_TaskDebug_GetHandlesCount_mid,
    kl_core_TaskDebug_GetHandles_mid,
    kl_core_TaskDebug_GetHandleInfo_mid,
    kl_core_TaskDebug_EnableHandleTracing_mid,
    kl_core_TaskDebug_DisableHandleTracing_mid,
    kl_core_TaskDebug_mid_max,
};
enum {
    kl_core_TaskDebug_GetHandlesCount_req_arena_size =
    0,
    kl_core_TaskDebug_GetHandlesCount_res_arena_size =
    0,
    kl_core_TaskDebug_GetHandlesCount_req_handles =
    1,
    kl_core_TaskDebug_GetHandlesCount_res_handles =
    0,
    kl_core_TaskDebug_GetHandlesCount_err_handles =
    0,
    kl_core_TaskDebug_GetHandles_req_arena_size =
    0,
    kl_core_TaskDebug_GetHandles_res_arena_size =
    0,
    kl_core_TaskDebug_GetHandles_req_handles = 2,
    kl_core_TaskDebug_GetHandles_res_handles = 0,
    kl_core_TaskDebug_GetHandles_err_handles = 0,
    kl_core_TaskDebug_GetHandleInfo_res_info_owner_size =
    1024,
    kl_core_TaskDebug_GetHandleInfo_res_info_traceBuf_size =
    1024,
    kl_core_TaskDebug_GetHandleInfo_res_info_traceCreator_size =
    1024,
    kl_core_TaskDebug_GetHandleInfo_req_arena_size =
    0,
    kl_core_TaskDebug_GetHandleInfo_res_arena_size =
    10240,
    kl_core_TaskDebug_GetHandleInfo_req_handles =
    1,
    kl_core_TaskDebug_GetHandleInfo_res_handles =
    0,
    kl_core_TaskDebug_GetHandleInfo_err_handles =
    0,
    kl_core_TaskDebug_EnableHandleTracing_req_arena_size =
    0,
    kl_core_TaskDebug_EnableHandleTracing_res_arena_size =
    0,
    kl_core_TaskDebug_EnableHandleTracing_req_handles =
    1,
    kl_core_TaskDebug_EnableHandleTracing_res_handles =
    0,
    kl_core_TaskDebug_EnableHandleTracing_err_handles =
    0,
    kl_core_TaskDebug_DisableHandleTracing_req_arena_size =
    0,
    kl_core_TaskDebug_DisableHandleTracing_res_arena_size =
    0,
    kl_core_TaskDebug_DisableHandleTracing_req_handles =
    1,
    kl_core_TaskDebug_DisableHandleTracing_res_handles =
    0,
    kl_core_TaskDebug_DisableHandleTracing_err_handles =
    0,
    kl_core_TaskDebug_req_arena_size = 0,
    kl_core_TaskDebug_res_arena_size = 10240,
    kl_core_TaskDebug_req_handles = 2,
    kl_core_TaskDebug_res_handles = 0,
    kl_core_TaskDebug_err_handles = 0,
};
typedef struct __nk_packed kl_core_TaskDebug_GetHandlesCount_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
        } kl_core_TaskDebug_GetHandlesCount_req;
nk_static_assert(sizeof(kl_core_TaskDebug_GetHandlesCount_req) == 40, bad_kl_core_TaskDebug_GetHandlesCount_req_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandlesCount_req, base_) == 0, bad_kl_core_TaskDebug_GetHandlesCount_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandlesCount_req, task) == 24, bad_kl_core_TaskDebug_GetHandlesCount_req_task_offset);
#pragma pack(push, 8) /* kl_core_TaskDebug_GetHandlesCount_res */
typedef struct kl_core_TaskDebug_GetHandlesCount_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_TaskDebug_GetHandlesCount_err;
nk_static_assert(sizeof(kl_core_TaskDebug_GetHandlesCount_err) == 24, bad_kl_core_TaskDebug_GetHandlesCount_err_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandlesCount_err, base_) == 0, bad_kl_core_TaskDebug_GetHandlesCount_err_base__offset);
typedef struct kl_core_TaskDebug_GetHandlesCount_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t count;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t count;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_TaskDebug_GetHandlesCount_err err_;
            };
        } kl_core_TaskDebug_GetHandlesCount_res;
nk_static_assert(sizeof(kl_core_TaskDebug_GetHandlesCount_res) == 32, bad_kl_core_TaskDebug_GetHandlesCount_res_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandlesCount_res, base_) == 0, bad_kl_core_TaskDebug_GetHandlesCount_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandlesCount_res, count) == 24, bad_kl_core_TaskDebug_GetHandlesCount_res_count_offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandlesCount_res, rc) == 28, bad_kl_core_TaskDebug_GetHandlesCount_res_rc_offset);
#pragma pack(pop) /* kl_core_TaskDebug_GetHandlesCount_res */
typedef struct __nk_packed kl_core_TaskDebug_GetHandles_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t mdl;
            __nk_alignas(4) nk_uint32_t countMax;
        } kl_core_TaskDebug_GetHandles_req;
nk_static_assert(sizeof(kl_core_TaskDebug_GetHandles_req) == 64, bad_kl_core_TaskDebug_GetHandles_req_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandles_req, base_) == 0, bad_kl_core_TaskDebug_GetHandles_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandles_req, task) == 24, bad_kl_core_TaskDebug_GetHandles_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandles_req, mdl) == 40, bad_kl_core_TaskDebug_GetHandles_req_mdl_offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandles_req, countMax) == 56, bad_kl_core_TaskDebug_GetHandles_req_countMax_offset);
#pragma pack(push, 8) /* kl_core_TaskDebug_GetHandles_res */
typedef struct kl_core_TaskDebug_GetHandles_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_TaskDebug_GetHandles_err;
nk_static_assert(sizeof(kl_core_TaskDebug_GetHandles_err) == 24, bad_kl_core_TaskDebug_GetHandles_err_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandles_err, base_) == 0, bad_kl_core_TaskDebug_GetHandles_err_base__offset);
typedef struct kl_core_TaskDebug_GetHandles_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t count;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t count;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_TaskDebug_GetHandles_err err_;
            };
        } kl_core_TaskDebug_GetHandles_res;
nk_static_assert(sizeof(kl_core_TaskDebug_GetHandles_res) == 32, bad_kl_core_TaskDebug_GetHandles_res_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandles_res, base_) == 0, bad_kl_core_TaskDebug_GetHandles_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandles_res, count) == 24, bad_kl_core_TaskDebug_GetHandles_res_count_offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandles_res, rc) == 28, bad_kl_core_TaskDebug_GetHandles_res_rc_offset);
#pragma pack(pop) /* kl_core_TaskDebug_GetHandles_res */
typedef struct __nk_packed kl_core_TaskDebug_GetHandleInfo_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(4) nk_uint32_t handle;
        } kl_core_TaskDebug_GetHandleInfo_req;
nk_static_assert(sizeof(kl_core_TaskDebug_GetHandleInfo_req) == 48, bad_kl_core_TaskDebug_GetHandleInfo_req_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandleInfo_req, base_) == 0, bad_kl_core_TaskDebug_GetHandleInfo_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandleInfo_req, task) == 24, bad_kl_core_TaskDebug_GetHandleInfo_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandleInfo_req, handle) == 40, bad_kl_core_TaskDebug_GetHandleInfo_req_handle_offset);
#pragma pack(push, 8) /* kl_core_TaskDebug_GetHandleInfo_res */
typedef struct kl_core_TaskDebug_GetHandleInfo_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_TaskDebug_GetHandleInfo_err;
nk_static_assert(sizeof(kl_core_TaskDebug_GetHandleInfo_err) == 24, bad_kl_core_TaskDebug_GetHandleInfo_err_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandleInfo_err, base_) == 0, bad_kl_core_TaskDebug_GetHandleInfo_err_base__offset);
typedef struct kl_core_TaskDebug_GetHandleInfo_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    struct kl_core_TaskDebug_HandleInfo info;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    struct kl_core_TaskDebug_HandleInfo info;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_TaskDebug_GetHandleInfo_err err_;
            };
        } kl_core_TaskDebug_GetHandleInfo_res;
nk_static_assert(sizeof(kl_core_TaskDebug_GetHandleInfo_res) == 88, bad_kl_core_TaskDebug_GetHandleInfo_res_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandleInfo_res, base_) == 0, bad_kl_core_TaskDebug_GetHandleInfo_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandleInfo_res, info) == 24, bad_kl_core_TaskDebug_GetHandleInfo_res_info_offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_GetHandleInfo_res, rc) == 80, bad_kl_core_TaskDebug_GetHandleInfo_res_rc_offset);
#pragma pack(pop) /* kl_core_TaskDebug_GetHandleInfo_res */
typedef struct __nk_packed kl_core_TaskDebug_EnableHandleTracing_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
        }
kl_core_TaskDebug_EnableHandleTracing_req;
nk_static_assert(sizeof(kl_core_TaskDebug_EnableHandleTracing_req) == 40, bad_kl_core_TaskDebug_EnableHandleTracing_req_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_EnableHandleTracing_req, base_) == 0, bad_kl_core_TaskDebug_EnableHandleTracing_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_EnableHandleTracing_req, task) == 24, bad_kl_core_TaskDebug_EnableHandleTracing_req_task_offset);
#pragma pack(push, 8) /* kl_core_TaskDebug_EnableHandleTracing_res */
typedef struct kl_core_TaskDebug_EnableHandleTracing_err {
            __nk_alignas(8)
            struct nk_message base_;
        }
kl_core_TaskDebug_EnableHandleTracing_err;
nk_static_assert(sizeof(kl_core_TaskDebug_EnableHandleTracing_err) == 24, bad_kl_core_TaskDebug_EnableHandleTracing_err_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_EnableHandleTracing_err, base_) == 0, bad_kl_core_TaskDebug_EnableHandleTracing_err_base__offset);
typedef struct kl_core_TaskDebug_EnableHandleTracing_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_TaskDebug_EnableHandleTracing_err err_;
            };
        }
kl_core_TaskDebug_EnableHandleTracing_res;
nk_static_assert(sizeof(kl_core_TaskDebug_EnableHandleTracing_res) == 32, bad_kl_core_TaskDebug_EnableHandleTracing_res_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_EnableHandleTracing_res, base_) == 0, bad_kl_core_TaskDebug_EnableHandleTracing_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_EnableHandleTracing_res, rc) == 24, bad_kl_core_TaskDebug_EnableHandleTracing_res_rc_offset);
#pragma pack(pop) /* kl_core_TaskDebug_EnableHandleTracing_res */
typedef struct __nk_packed kl_core_TaskDebug_DisableHandleTracing_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
        }
kl_core_TaskDebug_DisableHandleTracing_req;
nk_static_assert(sizeof(kl_core_TaskDebug_DisableHandleTracing_req) == 40, bad_kl_core_TaskDebug_DisableHandleTracing_req_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_DisableHandleTracing_req, base_) == 0, bad_kl_core_TaskDebug_DisableHandleTracing_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_DisableHandleTracing_req, task) == 24, bad_kl_core_TaskDebug_DisableHandleTracing_req_task_offset);
#pragma pack(push, 8) /* kl_core_TaskDebug_DisableHandleTracing_res */
typedef struct kl_core_TaskDebug_DisableHandleTracing_err {
            __nk_alignas(8)
            struct nk_message base_;
        }
kl_core_TaskDebug_DisableHandleTracing_err;
nk_static_assert(sizeof(kl_core_TaskDebug_DisableHandleTracing_err) == 24, bad_kl_core_TaskDebug_DisableHandleTracing_err_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_DisableHandleTracing_err, base_) == 0, bad_kl_core_TaskDebug_DisableHandleTracing_err_base__offset);
typedef struct kl_core_TaskDebug_DisableHandleTracing_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_TaskDebug_DisableHandleTracing_err err_;
            };
        }
kl_core_TaskDebug_DisableHandleTracing_res;
nk_static_assert(sizeof(kl_core_TaskDebug_DisableHandleTracing_res) == 32, bad_kl_core_TaskDebug_DisableHandleTracing_res_size);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_DisableHandleTracing_res, base_) == 0, bad_kl_core_TaskDebug_DisableHandleTracing_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_TaskDebug_DisableHandleTracing_res, rc) == 24, bad_kl_core_TaskDebug_DisableHandleTracing_res_rc_offset);
#pragma pack(pop) /* kl_core_TaskDebug_DisableHandleTracing_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define TaskDebug_GetHandlesCount_mid kl_core_TaskDebug_GetHandlesCount_mid
#define TaskDebug_GetHandles_mid kl_core_TaskDebug_GetHandles_mid
#define TaskDebug_GetHandleInfo_mid kl_core_TaskDebug_GetHandleInfo_mid
#define TaskDebug_EnableHandleTracing_mid kl_core_TaskDebug_EnableHandleTracing_mid
#define TaskDebug_DisableHandleTracing_mid kl_core_TaskDebug_DisableHandleTracing_mid
#define TaskDebug_mid_max kl_core_TaskDebug_mid_max
#define TaskDebug_GetHandlesCount_req_arena_size kl_core_TaskDebug_GetHandlesCount_req_arena_size
#define TaskDebug_GetHandlesCount_res_arena_size kl_core_TaskDebug_GetHandlesCount_res_arena_size
#define TaskDebug_GetHandlesCount_req_handles kl_core_TaskDebug_GetHandlesCount_req_handles
#define TaskDebug_GetHandlesCount_res_handles kl_core_TaskDebug_GetHandlesCount_res_handles
#define TaskDebug_GetHandlesCount_err_handles kl_core_TaskDebug_GetHandlesCount_err_handles
#define TaskDebug_GetHandles_req_arena_size kl_core_TaskDebug_GetHandles_req_arena_size
#define TaskDebug_GetHandles_res_arena_size kl_core_TaskDebug_GetHandles_res_arena_size
#define TaskDebug_GetHandles_req_handles kl_core_TaskDebug_GetHandles_req_handles
#define TaskDebug_GetHandles_res_handles kl_core_TaskDebug_GetHandles_res_handles
#define TaskDebug_GetHandles_err_handles kl_core_TaskDebug_GetHandles_err_handles
#define TaskDebug_GetHandleInfo_res_info_owner_size kl_core_TaskDebug_GetHandleInfo_res_info_owner_size
#define TaskDebug_GetHandleInfo_res_info_traceBuf_size kl_core_TaskDebug_GetHandleInfo_res_info_traceBuf_size
#define TaskDebug_GetHandleInfo_res_info_traceCreator_size kl_core_TaskDebug_GetHandleInfo_res_info_traceCreator_size
#define TaskDebug_GetHandleInfo_req_arena_size kl_core_TaskDebug_GetHandleInfo_req_arena_size
#define TaskDebug_GetHandleInfo_res_arena_size kl_core_TaskDebug_GetHandleInfo_res_arena_size
#define TaskDebug_GetHandleInfo_req_handles kl_core_TaskDebug_GetHandleInfo_req_handles
#define TaskDebug_GetHandleInfo_res_handles kl_core_TaskDebug_GetHandleInfo_res_handles
#define TaskDebug_GetHandleInfo_err_handles kl_core_TaskDebug_GetHandleInfo_err_handles
#define TaskDebug_EnableHandleTracing_req_arena_size kl_core_TaskDebug_EnableHandleTracing_req_arena_size
#define TaskDebug_EnableHandleTracing_res_arena_size kl_core_TaskDebug_EnableHandleTracing_res_arena_size
#define TaskDebug_EnableHandleTracing_req_handles kl_core_TaskDebug_EnableHandleTracing_req_handles
#define TaskDebug_EnableHandleTracing_res_handles kl_core_TaskDebug_EnableHandleTracing_res_handles
#define TaskDebug_EnableHandleTracing_err_handles kl_core_TaskDebug_EnableHandleTracing_err_handles
#define TaskDebug_DisableHandleTracing_req_arena_size kl_core_TaskDebug_DisableHandleTracing_req_arena_size
#define TaskDebug_DisableHandleTracing_res_arena_size kl_core_TaskDebug_DisableHandleTracing_res_arena_size
#define TaskDebug_DisableHandleTracing_req_handles kl_core_TaskDebug_DisableHandleTracing_req_handles
#define TaskDebug_DisableHandleTracing_res_handles kl_core_TaskDebug_DisableHandleTracing_res_handles
#define TaskDebug_DisableHandleTracing_err_handles kl_core_TaskDebug_DisableHandleTracing_err_handles
#define TaskDebug_req_arena_size kl_core_TaskDebug_req_arena_size
#define TaskDebug_res_arena_size kl_core_TaskDebug_res_arena_size
#define TaskDebug_req_handles kl_core_TaskDebug_req_handles
#define TaskDebug_res_handles kl_core_TaskDebug_res_handles
#define TaskDebug_err_handles kl_core_TaskDebug_err_handles
#define TaskDebug_GetHandlesCount_req kl_core_TaskDebug_GetHandlesCount_req
#define TaskDebug_GetHandlesCount_res kl_core_TaskDebug_GetHandlesCount_res
#define TaskDebug_GetHandles_req kl_core_TaskDebug_GetHandles_req
#define TaskDebug_GetHandles_res kl_core_TaskDebug_GetHandles_res
#define TaskDebug_GetHandleInfo_req kl_core_TaskDebug_GetHandleInfo_req
#define TaskDebug_GetHandleInfo_res kl_core_TaskDebug_GetHandleInfo_res
#define TaskDebug_EnableHandleTracing_req kl_core_TaskDebug_EnableHandleTracing_req
#define TaskDebug_EnableHandleTracing_res kl_core_TaskDebug_EnableHandleTracing_res
#define TaskDebug_DisableHandleTracing_req kl_core_TaskDebug_DisableHandleTracing_req
#define TaskDebug_DisableHandleTracing_res kl_core_TaskDebug_DisableHandleTracing_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__TaskDebug__INTERFACE__ */

#ifndef __kl_core__Task__INTERFACE__
#define __kl_core__Task__INTERFACE__
enum {
    kl_core_Task_Create_mid,
    kl_core_Task_LoadSeg_mid,
    kl_core_Task_VmReserve_mid,
    kl_core_Task_VmFree_mid,
    kl_core_Task_SetEntry_mid,
    kl_core_Task_LoadElfSyms_mid,
    kl_core_Task_LoadElfHdr_mid,
    kl_core_Task_SetEnv_mid,
    kl_core_Task_FreeSelfEnv_mid,
    kl_core_Task_Resume_mid,
    kl_core_Task_Exit_mid,
    kl_core_Task_Terminate_mid,
    kl_core_Task_GetExitInfo_mid,
    kl_core_Task_GetThreadContext_mid,
    kl_core_Task_GetNextVmRegion_mid,
    kl_core_Task_TerminateAfterFreezing_mid,
    kl_core_Task_GetName_mid,
    kl_core_Task_GetPath_mid,
    kl_core_Task_GetInitialThreadPriority_mid,
    kl_core_Task_SetInitialThreadPriority_mid,
    kl_core_Task_GetTasksList_mid,
    kl_core_Task_SetInitialThreadSchedPolicy_mid,
    kl_core_Task_ReseedAslr_mid,
    kl_core_Task_GetElfSyms_mid,
    kl_core_Task_TransferHandle_mid,
    kl_core_Task_GetPid_mid,
    kl_core_Task_mid_max,
};
enum {
    kl_core_Task_Create_req_name_size = 1024,
    kl_core_Task_Create_req_eiid_size = 1024,
    kl_core_Task_Create_req_path_size = 1024,
    kl_core_Task_Create_req_arena_size = 3072,
    kl_core_Task_Create_res_arena_size = 0,
    kl_core_Task_Create_req_handles = 0,
    kl_core_Task_Create_res_handles = 1,
    kl_core_Task_Create_err_handles = 0,
    kl_core_Task_LoadSeg_req_arena_size = 0,
    kl_core_Task_LoadSeg_res_arena_size = 0,
    kl_core_Task_LoadSeg_req_handles = 2,
    kl_core_Task_LoadSeg_res_handles = 0,
    kl_core_Task_LoadSeg_err_handles = 0,
    kl_core_Task_VmReserve_req_arena_size = 0,
    kl_core_Task_VmReserve_res_arena_size = 0,
    kl_core_Task_VmReserve_req_handles = 1,
    kl_core_Task_VmReserve_res_handles = 0,
    kl_core_Task_VmReserve_err_handles = 0,
    kl_core_Task_VmFree_req_arena_size = 0,
    kl_core_Task_VmFree_res_arena_size = 0,
    kl_core_Task_VmFree_req_handles = 1,
    kl_core_Task_VmFree_res_handles = 0,
    kl_core_Task_VmFree_err_handles = 0,
    kl_core_Task_SetEntry_req_arena_size = 0,
    kl_core_Task_SetEntry_res_arena_size = 0,
    kl_core_Task_SetEntry_req_handles = 1,
    kl_core_Task_SetEntry_res_handles = 0,
    kl_core_Task_SetEntry_err_handles = 0,
    kl_core_Task_LoadElfSyms_req_arena_size = 0,
    kl_core_Task_LoadElfSyms_res_arena_size = 0,
    kl_core_Task_LoadElfSyms_req_handles = 3,
    kl_core_Task_LoadElfSyms_res_handles = 0,
    kl_core_Task_LoadElfSyms_err_handles = 0,
    kl_core_Task_LoadElfHdr_req_hdrData_size =
    1024,
    kl_core_Task_LoadElfHdr_req_arena_size = 1024,
    kl_core_Task_LoadElfHdr_res_arena_size = 0,
    kl_core_Task_LoadElfHdr_req_handles = 1,
    kl_core_Task_LoadElfHdr_res_handles = 0,
    kl_core_Task_LoadElfHdr_err_handles = 0,
    kl_core_Task_SetEnv_req_env_size = 131072,
    kl_core_Task_SetEnv_req_arena_size = 131072,
    kl_core_Task_SetEnv_res_arena_size = 0,
    kl_core_Task_SetEnv_req_handles = 1,
    kl_core_Task_SetEnv_res_handles = 0,
    kl_core_Task_SetEnv_err_handles = 0,
    kl_core_Task_FreeSelfEnv_req_arena_size = 0,
    kl_core_Task_FreeSelfEnv_res_arena_size = 0,
    kl_core_Task_FreeSelfEnv_req_handles = 0,
    kl_core_Task_FreeSelfEnv_res_handles = 0,
    kl_core_Task_FreeSelfEnv_err_handles = 0,
    kl_core_Task_Resume_req_arena_size = 0,
    kl_core_Task_Resume_res_arena_size = 0,
    kl_core_Task_Resume_req_handles = 1,
    kl_core_Task_Resume_res_handles = 0,
    kl_core_Task_Resume_err_handles = 0,
    kl_core_Task_Exit_req_arena_size = 0,
    kl_core_Task_Exit_res_arena_size = 0,
    kl_core_Task_Exit_req_handles = 0,
    kl_core_Task_Exit_res_handles = 0,
    kl_core_Task_Exit_err_handles = 0,
    kl_core_Task_Terminate_req_arena_size = 0,
    kl_core_Task_Terminate_res_arena_size = 0,
    kl_core_Task_Terminate_req_handles = 1,
    kl_core_Task_Terminate_res_handles = 0,
    kl_core_Task_Terminate_err_handles = 0,
    kl_core_Task_GetExitInfo_res_info_exc_frame_size =
    1024,
    kl_core_Task_GetExitInfo_req_arena_size = 0,
    kl_core_Task_GetExitInfo_res_arena_size =
    1024,
    kl_core_Task_GetExitInfo_req_handles = 1,
    kl_core_Task_GetExitInfo_res_handles = 0,
    kl_core_Task_GetExitInfo_err_handles = 0,
    kl_core_Task_GetThreadContext_res_context_frame_size =
    1024,
    kl_core_Task_GetThreadContext_req_arena_size =
    0,
    kl_core_Task_GetThreadContext_res_arena_size =
    1024,
    kl_core_Task_GetThreadContext_req_handles = 1,
    kl_core_Task_GetThreadContext_res_handles = 0,
    kl_core_Task_GetThreadContext_err_handles = 0,
    kl_core_Task_GetNextVmRegion_req_arena_size =
    0,
    kl_core_Task_GetNextVmRegion_res_arena_size =
    0,
    kl_core_Task_GetNextVmRegion_req_handles = 1,
    kl_core_Task_GetNextVmRegion_res_handles = 1,
    kl_core_Task_GetNextVmRegion_err_handles = 0,
    kl_core_Task_TerminateAfterFreezing_req_arena_size =
    0,
    kl_core_Task_TerminateAfterFreezing_res_arena_size =
    0,
    kl_core_Task_TerminateAfterFreezing_req_handles =
    1,
    kl_core_Task_TerminateAfterFreezing_res_handles =
    0,
    kl_core_Task_TerminateAfterFreezing_err_handles =
    0,
    kl_core_Task_GetName_res_name_size = 1024,
    kl_core_Task_GetName_req_arena_size = 0,
    kl_core_Task_GetName_res_arena_size = 1024,
    kl_core_Task_GetName_req_handles = 0,
    kl_core_Task_GetName_res_handles = 0,
    kl_core_Task_GetName_err_handles = 0,
    kl_core_Task_GetPath_res_path_size = 1024,
    kl_core_Task_GetPath_req_arena_size = 0,
    kl_core_Task_GetPath_res_arena_size = 1024,
    kl_core_Task_GetPath_req_handles = 0,
    kl_core_Task_GetPath_res_handles = 0,
    kl_core_Task_GetPath_err_handles = 0,
    kl_core_Task_GetInitialThreadPriority_req_arena_size =
    0,
    kl_core_Task_GetInitialThreadPriority_res_arena_size =
    0,
    kl_core_Task_GetInitialThreadPriority_req_handles =
    1,
    kl_core_Task_GetInitialThreadPriority_res_handles =
    0,
    kl_core_Task_GetInitialThreadPriority_err_handles =
    0,
    kl_core_Task_SetInitialThreadPriority_req_arena_size =
    0,
    kl_core_Task_SetInitialThreadPriority_res_arena_size =
    0,
    kl_core_Task_SetInitialThreadPriority_req_handles =
    1,
    kl_core_Task_SetInitialThreadPriority_res_handles =
    0,
    kl_core_Task_SetInitialThreadPriority_err_handles =
    0,
    kl_core_Task_GetTasksList_res_strings_size =
    131072,
    kl_core_Task_GetTasksList_res_pids_size =
    4294967295,
    kl_core_Task_GetTasksList_req_arena_size = 0,
    kl_core_Task_GetTasksList_res_arena_size =
    17180000252,
    kl_core_Task_GetTasksList_req_handles = 0,
    kl_core_Task_GetTasksList_res_handles = 1,
    kl_core_Task_GetTasksList_err_handles = 0,
    kl_core_Task_SetInitialThreadSchedPolicy_req_arena_size =
    0,
    kl_core_Task_SetInitialThreadSchedPolicy_res_arena_size =
    0,
    kl_core_Task_SetInitialThreadSchedPolicy_req_handles =
    1,
    kl_core_Task_SetInitialThreadSchedPolicy_res_handles =
    0,
    kl_core_Task_SetInitialThreadSchedPolicy_err_handles =
    0,
    kl_core_Task_ReseedAslr_req_seed_size = 32,
    kl_core_Task_ReseedAslr_req_arena_size = 32,
    kl_core_Task_ReseedAslr_res_arena_size = 0,
    kl_core_Task_ReseedAslr_req_handles = 1,
    kl_core_Task_ReseedAslr_res_handles = 0,
    kl_core_Task_ReseedAslr_err_handles = 0,
    kl_core_Task_GetElfSyms_req_arena_size = 0,
    kl_core_Task_GetElfSyms_res_arena_size = 0,
    kl_core_Task_GetElfSyms_req_handles = 0,
    kl_core_Task_GetElfSyms_res_handles = 0,
    kl_core_Task_GetElfSyms_err_handles = 0,
    kl_core_Task_TransferHandle_req_arena_size =
    0,
    kl_core_Task_TransferHandle_res_arena_size =
    0,
    kl_core_Task_TransferHandle_req_handles = 3,
    kl_core_Task_TransferHandle_res_handles = 0,
    kl_core_Task_TransferHandle_err_handles = 0,
    kl_core_Task_GetPid_req_arena_size = 0,
    kl_core_Task_GetPid_res_arena_size = 0,
    kl_core_Task_GetPid_req_handles = 1,
    kl_core_Task_GetPid_res_handles = 0,
    kl_core_Task_GetPid_err_handles = 0,
    kl_core_Task_req_arena_size = 131072,
    kl_core_Task_res_arena_size = 17180000252,
    kl_core_Task_req_handles = 3,
    kl_core_Task_res_handles = 1,
    kl_core_Task_err_handles = 0,
};
typedef struct __nk_packed kl_core_Task_Create_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_ptr_t name;
            __nk_alignas(4) nk_ptr_t eiid;
            __nk_alignas(4) nk_ptr_t path;
            __nk_alignas(8) nk_uint64_t stackSize;
            __nk_alignas(4) nk_uint32_t priority;
            __nk_alignas(4) nk_uint32_t flags;
        } kl_core_Task_Create_req;
nk_static_assert(sizeof(kl_core_Task_Create_req) == 64, bad_kl_core_Task_Create_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_Create_req, base_) == 0, bad_kl_core_Task_Create_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_Create_req, name) == 24, bad_kl_core_Task_Create_req_name_offset);
nk_static_assert(nk_offsetof(kl_core_Task_Create_req, eiid) == 32, bad_kl_core_Task_Create_req_eiid_offset);
nk_static_assert(nk_offsetof(kl_core_Task_Create_req, path) == 40, bad_kl_core_Task_Create_req_path_offset);
nk_static_assert(nk_offsetof(kl_core_Task_Create_req, stackSize) == 48, bad_kl_core_Task_Create_req_stackSize_offset);
nk_static_assert(nk_offsetof(kl_core_Task_Create_req, priority) == 56, bad_kl_core_Task_Create_req_priority_offset);
nk_static_assert(nk_offsetof(kl_core_Task_Create_req, flags) == 60, bad_kl_core_Task_Create_req_flags_offset);
#pragma pack(push, 8) /* kl_core_Task_Create_res */
typedef struct kl_core_Task_Create_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_Create_err;
nk_static_assert(sizeof(kl_core_Task_Create_err) == 24, bad_kl_core_Task_Create_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_Create_err, base_) == 0, bad_kl_core_Task_Create_err_base__offset);
typedef struct kl_core_Task_Create_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t child;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t child;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_Create_err err_;
            };
        } kl_core_Task_Create_res;
nk_static_assert(sizeof(kl_core_Task_Create_res) == 48, bad_kl_core_Task_Create_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_Create_res, base_) == 0, bad_kl_core_Task_Create_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_Create_res, child) == 24, bad_kl_core_Task_Create_res_child_offset);
nk_static_assert(nk_offsetof(kl_core_Task_Create_res, rc) == 40, bad_kl_core_Task_Create_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_Create_res */
typedef struct __nk_packed kl_core_Task_LoadSeg_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t mdl;
            __nk_alignas(8)
            struct kl_core_Task_VmSegAttr segAttr;
        } kl_core_Task_LoadSeg_req;
nk_static_assert(sizeof(kl_core_Task_LoadSeg_req) == 88, bad_kl_core_Task_LoadSeg_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_LoadSeg_req, base_) == 0, bad_kl_core_Task_LoadSeg_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadSeg_req, task) == 24, bad_kl_core_Task_LoadSeg_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadSeg_req, mdl) == 40, bad_kl_core_Task_LoadSeg_req_mdl_offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadSeg_req, segAttr) == 56, bad_kl_core_Task_LoadSeg_req_segAttr_offset);
#pragma pack(push, 8) /* kl_core_Task_LoadSeg_res */
typedef struct kl_core_Task_LoadSeg_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_LoadSeg_err;
nk_static_assert(sizeof(kl_core_Task_LoadSeg_err) == 24, bad_kl_core_Task_LoadSeg_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_LoadSeg_err, base_) == 0, bad_kl_core_Task_LoadSeg_err_base__offset);
typedef struct kl_core_Task_LoadSeg_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                    __nk_alignas(8)
                    nk_uint64_t retaddr;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                    __nk_alignas(8)
                    nk_uint64_t retaddr;
                } res_;
                struct kl_core_Task_LoadSeg_err err_;
            };
        } kl_core_Task_LoadSeg_res;
nk_static_assert(sizeof(kl_core_Task_LoadSeg_res) == 40, bad_kl_core_Task_LoadSeg_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_LoadSeg_res, base_) == 0, bad_kl_core_Task_LoadSeg_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadSeg_res, rc) == 24, bad_kl_core_Task_LoadSeg_res_rc_offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadSeg_res, retaddr) == 32, bad_kl_core_Task_LoadSeg_res_retaddr_offset);
#pragma pack(pop) /* kl_core_Task_LoadSeg_res */
typedef struct __nk_packed kl_core_Task_VmReserve_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(8) nk_uint64_t addr;
            __nk_alignas(8) nk_uint64_t size;
            __nk_alignas(4) nk_uint32_t flags;
        } kl_core_Task_VmReserve_req;
nk_static_assert(sizeof(kl_core_Task_VmReserve_req) == 64, bad_kl_core_Task_VmReserve_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_VmReserve_req, base_) == 0, bad_kl_core_Task_VmReserve_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_VmReserve_req, task) == 24, bad_kl_core_Task_VmReserve_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Task_VmReserve_req, addr) == 40, bad_kl_core_Task_VmReserve_req_addr_offset);
nk_static_assert(nk_offsetof(kl_core_Task_VmReserve_req, size) == 48, bad_kl_core_Task_VmReserve_req_size_offset);
nk_static_assert(nk_offsetof(kl_core_Task_VmReserve_req, flags) == 56, bad_kl_core_Task_VmReserve_req_flags_offset);
#pragma pack(push, 8) /* kl_core_Task_VmReserve_res */
typedef struct kl_core_Task_VmReserve_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_VmReserve_err;
nk_static_assert(sizeof(kl_core_Task_VmReserve_err) == 24, bad_kl_core_Task_VmReserve_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_VmReserve_err, base_) == 0, bad_kl_core_Task_VmReserve_err_base__offset);
typedef struct kl_core_Task_VmReserve_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t outAddr;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t outAddr;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_VmReserve_err err_;
            };
        } kl_core_Task_VmReserve_res;
nk_static_assert(sizeof(kl_core_Task_VmReserve_res) == 40, bad_kl_core_Task_VmReserve_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_VmReserve_res, base_) == 0, bad_kl_core_Task_VmReserve_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_VmReserve_res, outAddr) == 24, bad_kl_core_Task_VmReserve_res_outAddr_offset);
nk_static_assert(nk_offsetof(kl_core_Task_VmReserve_res, rc) == 32, bad_kl_core_Task_VmReserve_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_VmReserve_res */
typedef struct __nk_packed kl_core_Task_VmFree_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(8) nk_uint64_t addr;
            __nk_alignas(8) nk_uint64_t size;
        } kl_core_Task_VmFree_req;
nk_static_assert(sizeof(kl_core_Task_VmFree_req) == 56, bad_kl_core_Task_VmFree_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_VmFree_req, base_) == 0, bad_kl_core_Task_VmFree_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_VmFree_req, task) == 24, bad_kl_core_Task_VmFree_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Task_VmFree_req, addr) == 40, bad_kl_core_Task_VmFree_req_addr_offset);
nk_static_assert(nk_offsetof(kl_core_Task_VmFree_req, size) == 48, bad_kl_core_Task_VmFree_req_size_offset);
#pragma pack(push, 8) /* kl_core_Task_VmFree_res */
typedef struct kl_core_Task_VmFree_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_VmFree_err;
nk_static_assert(sizeof(kl_core_Task_VmFree_err) == 24, bad_kl_core_Task_VmFree_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_VmFree_err, base_) == 0, bad_kl_core_Task_VmFree_err_base__offset);
typedef struct kl_core_Task_VmFree_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_VmFree_err err_;
            };
        } kl_core_Task_VmFree_res;
nk_static_assert(sizeof(kl_core_Task_VmFree_res) == 32, bad_kl_core_Task_VmFree_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_VmFree_res, base_) == 0, bad_kl_core_Task_VmFree_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_VmFree_res, rc) == 24, bad_kl_core_Task_VmFree_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_VmFree_res */
typedef struct __nk_packed kl_core_Task_SetEntry_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(8)
            struct kl_core_Task_InitialStateParams state;
        } kl_core_Task_SetEntry_req;
nk_static_assert(sizeof(kl_core_Task_SetEntry_req) == 56, bad_kl_core_Task_SetEntry_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_SetEntry_req, base_) == 0, bad_kl_core_Task_SetEntry_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetEntry_req, task) == 24, bad_kl_core_Task_SetEntry_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetEntry_req, state) == 40, bad_kl_core_Task_SetEntry_req_state_offset);
#pragma pack(push, 8) /* kl_core_Task_SetEntry_res */
typedef struct kl_core_Task_SetEntry_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_SetEntry_err;
nk_static_assert(sizeof(kl_core_Task_SetEntry_err) == 24, bad_kl_core_Task_SetEntry_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_SetEntry_err, base_) == 0, bad_kl_core_Task_SetEntry_err_base__offset);
typedef struct kl_core_Task_SetEntry_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_SetEntry_err err_;
            };
        } kl_core_Task_SetEntry_res;
nk_static_assert(sizeof(kl_core_Task_SetEntry_res) == 32, bad_kl_core_Task_SetEntry_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_SetEntry_res, base_) == 0, bad_kl_core_Task_SetEntry_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetEntry_res, rc) == 24, bad_kl_core_Task_SetEntry_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_SetEntry_res */
typedef struct __nk_packed kl_core_Task_LoadElfSyms_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t symMdl;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t strMdl;
            __nk_alignas(8)
            struct kl_core_Task_VmSegAttr symSegAttr;
            __nk_alignas(8) nk_uint64_t symSize;
            __nk_alignas(8)
            struct kl_core_Task_VmSegAttr strSegAttr;
            __nk_alignas(8) nk_uint64_t strSize;
        } kl_core_Task_LoadElfSyms_req;
nk_static_assert(sizeof(kl_core_Task_LoadElfSyms_req) == 152, bad_kl_core_Task_LoadElfSyms_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfSyms_req, base_) == 0, bad_kl_core_Task_LoadElfSyms_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfSyms_req, task) == 24, bad_kl_core_Task_LoadElfSyms_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfSyms_req, symMdl) == 40, bad_kl_core_Task_LoadElfSyms_req_symMdl_offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfSyms_req, strMdl) == 56, bad_kl_core_Task_LoadElfSyms_req_strMdl_offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfSyms_req, symSegAttr) == 72, bad_kl_core_Task_LoadElfSyms_req_symSegAttr_offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfSyms_req, symSize) == 104, bad_kl_core_Task_LoadElfSyms_req_symSize_offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfSyms_req, strSegAttr) == 112, bad_kl_core_Task_LoadElfSyms_req_strSegAttr_offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfSyms_req, strSize) == 144, bad_kl_core_Task_LoadElfSyms_req_strSize_offset);
#pragma pack(push, 8) /* kl_core_Task_LoadElfSyms_res */
typedef struct kl_core_Task_LoadElfSyms_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_LoadElfSyms_err;
nk_static_assert(sizeof(kl_core_Task_LoadElfSyms_err) == 24, bad_kl_core_Task_LoadElfSyms_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfSyms_err, base_) == 0, bad_kl_core_Task_LoadElfSyms_err_base__offset);
typedef struct kl_core_Task_LoadElfSyms_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_LoadElfSyms_err err_;
            };
        } kl_core_Task_LoadElfSyms_res;
nk_static_assert(sizeof(kl_core_Task_LoadElfSyms_res) == 32, bad_kl_core_Task_LoadElfSyms_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfSyms_res, base_) == 0, bad_kl_core_Task_LoadElfSyms_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfSyms_res, rc) == 24, bad_kl_core_Task_LoadElfSyms_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_LoadElfSyms_res */
typedef struct __nk_packed kl_core_Task_LoadElfHdr_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(4) nk_ptr_t hdrData;
        } kl_core_Task_LoadElfHdr_req;
nk_static_assert(sizeof(kl_core_Task_LoadElfHdr_req) == 48, bad_kl_core_Task_LoadElfHdr_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfHdr_req, base_) == 0, bad_kl_core_Task_LoadElfHdr_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfHdr_req, task) == 24, bad_kl_core_Task_LoadElfHdr_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfHdr_req, hdrData) == 40, bad_kl_core_Task_LoadElfHdr_req_hdrData_offset);
#pragma pack(push, 8) /* kl_core_Task_LoadElfHdr_res */
typedef struct kl_core_Task_LoadElfHdr_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_LoadElfHdr_err;
nk_static_assert(sizeof(kl_core_Task_LoadElfHdr_err) == 24, bad_kl_core_Task_LoadElfHdr_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfHdr_err, base_) == 0, bad_kl_core_Task_LoadElfHdr_err_base__offset);
typedef struct kl_core_Task_LoadElfHdr_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_LoadElfHdr_err err_;
            };
        } kl_core_Task_LoadElfHdr_res;
nk_static_assert(sizeof(kl_core_Task_LoadElfHdr_res) == 32, bad_kl_core_Task_LoadElfHdr_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfHdr_res, base_) == 0, bad_kl_core_Task_LoadElfHdr_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_LoadElfHdr_res, rc) == 24, bad_kl_core_Task_LoadElfHdr_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_LoadElfHdr_res */
typedef struct __nk_packed kl_core_Task_SetEnv_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(4) nk_ptr_t env;
        } kl_core_Task_SetEnv_req;
nk_static_assert(sizeof(kl_core_Task_SetEnv_req) == 48, bad_kl_core_Task_SetEnv_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_SetEnv_req, base_) == 0, bad_kl_core_Task_SetEnv_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetEnv_req, task) == 24, bad_kl_core_Task_SetEnv_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetEnv_req, env) == 40, bad_kl_core_Task_SetEnv_req_env_offset);
#pragma pack(push, 8) /* kl_core_Task_SetEnv_res */
typedef struct kl_core_Task_SetEnv_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_SetEnv_err;
nk_static_assert(sizeof(kl_core_Task_SetEnv_err) == 24, bad_kl_core_Task_SetEnv_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_SetEnv_err, base_) == 0, bad_kl_core_Task_SetEnv_err_base__offset);
typedef struct kl_core_Task_SetEnv_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_SetEnv_err err_;
            };
        } kl_core_Task_SetEnv_res;
nk_static_assert(sizeof(kl_core_Task_SetEnv_res) == 32, bad_kl_core_Task_SetEnv_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_SetEnv_res, base_) == 0, bad_kl_core_Task_SetEnv_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetEnv_res, rc) == 24, bad_kl_core_Task_SetEnv_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_SetEnv_res */
typedef struct __nk_packed kl_core_Task_FreeSelfEnv_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_FreeSelfEnv_req;
nk_static_assert(sizeof(kl_core_Task_FreeSelfEnv_req) == 24, bad_kl_core_Task_FreeSelfEnv_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_FreeSelfEnv_req, base_) == 0, bad_kl_core_Task_FreeSelfEnv_req_base__offset);
#pragma pack(push, 8) /* kl_core_Task_FreeSelfEnv_res */
typedef struct kl_core_Task_FreeSelfEnv_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_FreeSelfEnv_err;
nk_static_assert(sizeof(kl_core_Task_FreeSelfEnv_err) == 24, bad_kl_core_Task_FreeSelfEnv_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_FreeSelfEnv_err, base_) == 0, bad_kl_core_Task_FreeSelfEnv_err_base__offset);
typedef struct kl_core_Task_FreeSelfEnv_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_FreeSelfEnv_err err_;
            };
        } kl_core_Task_FreeSelfEnv_res;
nk_static_assert(sizeof(kl_core_Task_FreeSelfEnv_res) == 32, bad_kl_core_Task_FreeSelfEnv_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_FreeSelfEnv_res, base_) == 0, bad_kl_core_Task_FreeSelfEnv_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_FreeSelfEnv_res, rc) == 24, bad_kl_core_Task_FreeSelfEnv_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_FreeSelfEnv_res */
typedef struct __nk_packed kl_core_Task_Resume_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
        } kl_core_Task_Resume_req;
nk_static_assert(sizeof(kl_core_Task_Resume_req) == 40, bad_kl_core_Task_Resume_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_Resume_req, base_) == 0, bad_kl_core_Task_Resume_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_Resume_req, task) == 24, bad_kl_core_Task_Resume_req_task_offset);
#pragma pack(push, 8) /* kl_core_Task_Resume_res */
typedef struct kl_core_Task_Resume_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_Resume_err;
nk_static_assert(sizeof(kl_core_Task_Resume_err) == 24, bad_kl_core_Task_Resume_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_Resume_err, base_) == 0, bad_kl_core_Task_Resume_err_base__offset);
typedef struct kl_core_Task_Resume_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_Resume_err err_;
            };
        } kl_core_Task_Resume_res;
nk_static_assert(sizeof(kl_core_Task_Resume_res) == 32, bad_kl_core_Task_Resume_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_Resume_res, base_) == 0, bad_kl_core_Task_Resume_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_Resume_res, rc) == 24, bad_kl_core_Task_Resume_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_Resume_res */
typedef struct __nk_packed kl_core_Task_Exit_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t status;
        } kl_core_Task_Exit_req;
nk_static_assert(sizeof(kl_core_Task_Exit_req) == 32, bad_kl_core_Task_Exit_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_Exit_req, base_) == 0, bad_kl_core_Task_Exit_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_Exit_req, status) == 24, bad_kl_core_Task_Exit_req_status_offset);
#pragma pack(push, 8) /* kl_core_Task_Exit_res */
typedef struct kl_core_Task_Exit_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_Exit_err;
nk_static_assert(sizeof(kl_core_Task_Exit_err) == 24, bad_kl_core_Task_Exit_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_Exit_err, base_) == 0, bad_kl_core_Task_Exit_err_base__offset);
typedef struct kl_core_Task_Exit_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_Exit_err err_;
            };
        } kl_core_Task_Exit_res;
nk_static_assert(sizeof(kl_core_Task_Exit_res) == 32, bad_kl_core_Task_Exit_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_Exit_res, base_) == 0, bad_kl_core_Task_Exit_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_Exit_res, rc) == 24, bad_kl_core_Task_Exit_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_Exit_res */
typedef struct __nk_packed kl_core_Task_Terminate_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
        } kl_core_Task_Terminate_req;
nk_static_assert(sizeof(kl_core_Task_Terminate_req) == 40, bad_kl_core_Task_Terminate_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_Terminate_req, base_) == 0, bad_kl_core_Task_Terminate_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_Terminate_req, task) == 24, bad_kl_core_Task_Terminate_req_task_offset);
#pragma pack(push, 8) /* kl_core_Task_Terminate_res */
typedef struct kl_core_Task_Terminate_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_Terminate_err;
nk_static_assert(sizeof(kl_core_Task_Terminate_err) == 24, bad_kl_core_Task_Terminate_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_Terminate_err, base_) == 0, bad_kl_core_Task_Terminate_err_base__offset);
typedef struct kl_core_Task_Terminate_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_Terminate_err err_;
            };
        } kl_core_Task_Terminate_res;
nk_static_assert(sizeof(kl_core_Task_Terminate_res) == 32, bad_kl_core_Task_Terminate_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_Terminate_res, base_) == 0, bad_kl_core_Task_Terminate_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_Terminate_res, rc) == 24, bad_kl_core_Task_Terminate_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_Terminate_res */
typedef struct __nk_packed kl_core_Task_GetExitInfo_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
        } kl_core_Task_GetExitInfo_req;
nk_static_assert(sizeof(kl_core_Task_GetExitInfo_req) == 40, bad_kl_core_Task_GetExitInfo_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetExitInfo_req, base_) == 0, bad_kl_core_Task_GetExitInfo_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetExitInfo_req, task) == 24, bad_kl_core_Task_GetExitInfo_req_task_offset);
#pragma pack(push, 8) /* kl_core_Task_GetExitInfo_res */
typedef struct kl_core_Task_GetExitInfo_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_GetExitInfo_err;
nk_static_assert(sizeof(kl_core_Task_GetExitInfo_err) == 24, bad_kl_core_Task_GetExitInfo_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetExitInfo_err, base_) == 0, bad_kl_core_Task_GetExitInfo_err_base__offset);
typedef struct kl_core_Task_GetExitInfo_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t status;
                    __nk_alignas(4)
                    struct kl_core_Task_ExitInfo info;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t status;
                    __nk_alignas(4)
                    struct kl_core_Task_ExitInfo info;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_GetExitInfo_err err_;
            };
        } kl_core_Task_GetExitInfo_res;
nk_static_assert(sizeof(kl_core_Task_GetExitInfo_res) == 56, bad_kl_core_Task_GetExitInfo_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetExitInfo_res, base_) == 0, bad_kl_core_Task_GetExitInfo_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetExitInfo_res, status) == 24, bad_kl_core_Task_GetExitInfo_res_status_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetExitInfo_res, info) == 28, bad_kl_core_Task_GetExitInfo_res_info_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetExitInfo_res, rc) == 48, bad_kl_core_Task_GetExitInfo_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_GetExitInfo_res */
typedef struct __nk_packed kl_core_Task_GetThreadContext_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(4) nk_uint32_t index;
        } kl_core_Task_GetThreadContext_req;
nk_static_assert(sizeof(kl_core_Task_GetThreadContext_req) == 48, bad_kl_core_Task_GetThreadContext_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetThreadContext_req, base_) == 0, bad_kl_core_Task_GetThreadContext_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetThreadContext_req, task) == 24, bad_kl_core_Task_GetThreadContext_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetThreadContext_req, index) == 40, bad_kl_core_Task_GetThreadContext_req_index_offset);
#pragma pack(push, 8) /* kl_core_Task_GetThreadContext_res */
typedef struct kl_core_Task_GetThreadContext_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_GetThreadContext_err;
nk_static_assert(sizeof(kl_core_Task_GetThreadContext_err) == 24, bad_kl_core_Task_GetThreadContext_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetThreadContext_err, base_) == 0, bad_kl_core_Task_GetThreadContext_err_base__offset);
typedef struct kl_core_Task_GetThreadContext_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    struct kl_core_Task_ThreadContext context;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    struct kl_core_Task_ThreadContext context;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_GetThreadContext_err err_;
            };
        } kl_core_Task_GetThreadContext_res;
nk_static_assert(sizeof(kl_core_Task_GetThreadContext_res) == 40, bad_kl_core_Task_GetThreadContext_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetThreadContext_res, base_) == 0, bad_kl_core_Task_GetThreadContext_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetThreadContext_res, context) == 24, bad_kl_core_Task_GetThreadContext_res_context_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetThreadContext_res, rc) == 36, bad_kl_core_Task_GetThreadContext_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_GetThreadContext_res */
typedef struct __nk_packed kl_core_Task_GetNextVmRegion_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(8) nk_uint64_t after;
        } kl_core_Task_GetNextVmRegion_req;
nk_static_assert(sizeof(kl_core_Task_GetNextVmRegion_req) == 48, bad_kl_core_Task_GetNextVmRegion_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetNextVmRegion_req, base_) == 0, bad_kl_core_Task_GetNextVmRegion_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetNextVmRegion_req, task) == 24, bad_kl_core_Task_GetNextVmRegion_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetNextVmRegion_req, after) == 40, bad_kl_core_Task_GetNextVmRegion_req_after_offset);
#pragma pack(push, 8) /* kl_core_Task_GetNextVmRegion_res */
typedef struct kl_core_Task_GetNextVmRegion_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_GetNextVmRegion_err;
nk_static_assert(sizeof(kl_core_Task_GetNextVmRegion_err) == 24, bad_kl_core_Task_GetNextVmRegion_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetNextVmRegion_err, base_) == 0, bad_kl_core_Task_GetNextVmRegion_err_base__offset);
typedef struct kl_core_Task_GetNextVmRegion_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(8)
                    nk_uint64_t next;
                    __nk_alignas(8)
                    nk_uint64_t size;
                    __nk_alignas(4)
                    nk_uint32_t flags;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(8)
                    nk_uint64_t next;
                    __nk_alignas(8)
                    nk_uint64_t size;
                    __nk_alignas(4)
                    nk_uint32_t flags;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_GetNextVmRegion_err err_;
            };
        } kl_core_Task_GetNextVmRegion_res;
nk_static_assert(sizeof(kl_core_Task_GetNextVmRegion_res) == 64, bad_kl_core_Task_GetNextVmRegion_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetNextVmRegion_res, base_) == 0, bad_kl_core_Task_GetNextVmRegion_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetNextVmRegion_res, handle) == 24, bad_kl_core_Task_GetNextVmRegion_res_handle_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetNextVmRegion_res, next) == 40, bad_kl_core_Task_GetNextVmRegion_res_next_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetNextVmRegion_res, size) == 48, bad_kl_core_Task_GetNextVmRegion_res_size_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetNextVmRegion_res, flags) == 56, bad_kl_core_Task_GetNextVmRegion_res_flags_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetNextVmRegion_res, rc) == 60, bad_kl_core_Task_GetNextVmRegion_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_GetNextVmRegion_res */
typedef struct __nk_packed kl_core_Task_TerminateAfterFreezing_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
        } kl_core_Task_TerminateAfterFreezing_req;
nk_static_assert(sizeof(kl_core_Task_TerminateAfterFreezing_req) == 40, bad_kl_core_Task_TerminateAfterFreezing_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_TerminateAfterFreezing_req, base_) == 0, bad_kl_core_Task_TerminateAfterFreezing_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_TerminateAfterFreezing_req, task) == 24, bad_kl_core_Task_TerminateAfterFreezing_req_task_offset);
#pragma pack(push, 8) /* kl_core_Task_TerminateAfterFreezing_res */
typedef struct kl_core_Task_TerminateAfterFreezing_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_TerminateAfterFreezing_err;
nk_static_assert(sizeof(kl_core_Task_TerminateAfterFreezing_err) == 24, bad_kl_core_Task_TerminateAfterFreezing_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_TerminateAfterFreezing_err, base_) == 0, bad_kl_core_Task_TerminateAfterFreezing_err_base__offset);
typedef struct kl_core_Task_TerminateAfterFreezing_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_TerminateAfterFreezing_err err_;
            };
        } kl_core_Task_TerminateAfterFreezing_res;
nk_static_assert(sizeof(kl_core_Task_TerminateAfterFreezing_res) == 32, bad_kl_core_Task_TerminateAfterFreezing_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_TerminateAfterFreezing_res, base_) == 0, bad_kl_core_Task_TerminateAfterFreezing_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_TerminateAfterFreezing_res, rc) == 24, bad_kl_core_Task_TerminateAfterFreezing_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_TerminateAfterFreezing_res */
typedef struct __nk_packed kl_core_Task_GetName_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_GetName_req;
nk_static_assert(sizeof(kl_core_Task_GetName_req) == 24, bad_kl_core_Task_GetName_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetName_req, base_) == 0, bad_kl_core_Task_GetName_req_base__offset);
#pragma pack(push, 8) /* kl_core_Task_GetName_res */
typedef struct kl_core_Task_GetName_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_GetName_err;
nk_static_assert(sizeof(kl_core_Task_GetName_err) == 24, bad_kl_core_Task_GetName_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetName_err, base_) == 0, bad_kl_core_Task_GetName_err_base__offset);
typedef struct kl_core_Task_GetName_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t name;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t name;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_GetName_err err_;
            };
        } kl_core_Task_GetName_res;
nk_static_assert(sizeof(kl_core_Task_GetName_res) == 40, bad_kl_core_Task_GetName_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetName_res, base_) == 0, bad_kl_core_Task_GetName_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetName_res, name) == 24, bad_kl_core_Task_GetName_res_name_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetName_res, rc) == 32, bad_kl_core_Task_GetName_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_GetName_res */
typedef struct __nk_packed kl_core_Task_GetPath_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_GetPath_req;
nk_static_assert(sizeof(kl_core_Task_GetPath_req) == 24, bad_kl_core_Task_GetPath_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetPath_req, base_) == 0, bad_kl_core_Task_GetPath_req_base__offset);
#pragma pack(push, 8) /* kl_core_Task_GetPath_res */
typedef struct kl_core_Task_GetPath_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_GetPath_err;
nk_static_assert(sizeof(kl_core_Task_GetPath_err) == 24, bad_kl_core_Task_GetPath_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetPath_err, base_) == 0, bad_kl_core_Task_GetPath_err_base__offset);
typedef struct kl_core_Task_GetPath_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t path;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t path;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_GetPath_err err_;
            };
        } kl_core_Task_GetPath_res;
nk_static_assert(sizeof(kl_core_Task_GetPath_res) == 40, bad_kl_core_Task_GetPath_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetPath_res, base_) == 0, bad_kl_core_Task_GetPath_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetPath_res, path) == 24, bad_kl_core_Task_GetPath_res_path_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetPath_res, rc) == 32, bad_kl_core_Task_GetPath_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_GetPath_res */
typedef struct __nk_packed kl_core_Task_GetInitialThreadPriority_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
        }
kl_core_Task_GetInitialThreadPriority_req;
nk_static_assert(sizeof(kl_core_Task_GetInitialThreadPriority_req) == 40, bad_kl_core_Task_GetInitialThreadPriority_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetInitialThreadPriority_req, base_) == 0, bad_kl_core_Task_GetInitialThreadPriority_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetInitialThreadPriority_req, task) == 24, bad_kl_core_Task_GetInitialThreadPriority_req_task_offset);
#pragma pack(push, 8) /* kl_core_Task_GetInitialThreadPriority_res */
typedef struct kl_core_Task_GetInitialThreadPriority_err {
            __nk_alignas(8)
            struct nk_message base_;
        }
kl_core_Task_GetInitialThreadPriority_err;
nk_static_assert(sizeof(kl_core_Task_GetInitialThreadPriority_err) == 24, bad_kl_core_Task_GetInitialThreadPriority_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetInitialThreadPriority_err, base_) == 0, bad_kl_core_Task_GetInitialThreadPriority_err_base__offset);
typedef struct kl_core_Task_GetInitialThreadPriority_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t priority;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t priority;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_GetInitialThreadPriority_err err_;
            };
        }
kl_core_Task_GetInitialThreadPriority_res;
nk_static_assert(sizeof(kl_core_Task_GetInitialThreadPriority_res) == 32, bad_kl_core_Task_GetInitialThreadPriority_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetInitialThreadPriority_res, base_) == 0, bad_kl_core_Task_GetInitialThreadPriority_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetInitialThreadPriority_res, priority) == 24, bad_kl_core_Task_GetInitialThreadPriority_res_priority_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetInitialThreadPriority_res, rc) == 28, bad_kl_core_Task_GetInitialThreadPriority_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_GetInitialThreadPriority_res */
typedef struct __nk_packed kl_core_Task_SetInitialThreadPriority_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(4) nk_uint32_t priority;
        }
kl_core_Task_SetInitialThreadPriority_req;
nk_static_assert(sizeof(kl_core_Task_SetInitialThreadPriority_req) == 48, bad_kl_core_Task_SetInitialThreadPriority_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadPriority_req, base_) == 0, bad_kl_core_Task_SetInitialThreadPriority_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadPriority_req, task) == 24, bad_kl_core_Task_SetInitialThreadPriority_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadPriority_req, priority) == 40, bad_kl_core_Task_SetInitialThreadPriority_req_priority_offset);
#pragma pack(push, 8) /* kl_core_Task_SetInitialThreadPriority_res */
typedef struct kl_core_Task_SetInitialThreadPriority_err {
            __nk_alignas(8)
            struct nk_message base_;
        }
kl_core_Task_SetInitialThreadPriority_err;
nk_static_assert(sizeof(kl_core_Task_SetInitialThreadPriority_err) == 24, bad_kl_core_Task_SetInitialThreadPriority_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadPriority_err, base_) == 0, bad_kl_core_Task_SetInitialThreadPriority_err_base__offset);
typedef struct kl_core_Task_SetInitialThreadPriority_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_SetInitialThreadPriority_err err_;
            };
        }
kl_core_Task_SetInitialThreadPriority_res;
nk_static_assert(sizeof(kl_core_Task_SetInitialThreadPriority_res) == 32, bad_kl_core_Task_SetInitialThreadPriority_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadPriority_res, base_) == 0, bad_kl_core_Task_SetInitialThreadPriority_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadPriority_res, rc) == 24, bad_kl_core_Task_SetInitialThreadPriority_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_SetInitialThreadPriority_res */
typedef struct __nk_packed kl_core_Task_GetTasksList_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_GetTasksList_req;
nk_static_assert(sizeof(kl_core_Task_GetTasksList_req) == 24, bad_kl_core_Task_GetTasksList_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetTasksList_req, base_) == 0, bad_kl_core_Task_GetTasksList_req_base__offset);
#pragma pack(push, 8) /* kl_core_Task_GetTasksList_res */
typedef struct kl_core_Task_GetTasksList_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_GetTasksList_err;
nk_static_assert(sizeof(kl_core_Task_GetTasksList_err) == 24, bad_kl_core_Task_GetTasksList_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetTasksList_err, base_) == 0, bad_kl_core_Task_GetTasksList_err_base__offset);
typedef struct kl_core_Task_GetTasksList_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t notice;
                    __nk_alignas(4)
                    nk_ptr_t strings;
                    __nk_alignas(4) nk_ptr_t pids;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t notice;
                    __nk_alignas(4)
                    nk_ptr_t strings;
                    __nk_alignas(4) nk_ptr_t pids;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_GetTasksList_err err_;
            };
        } kl_core_Task_GetTasksList_res;
nk_static_assert(sizeof(kl_core_Task_GetTasksList_res) == 64, bad_kl_core_Task_GetTasksList_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetTasksList_res, base_) == 0, bad_kl_core_Task_GetTasksList_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetTasksList_res, notice) == 24, bad_kl_core_Task_GetTasksList_res_notice_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetTasksList_res, strings) == 40, bad_kl_core_Task_GetTasksList_res_strings_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetTasksList_res, pids) == 48, bad_kl_core_Task_GetTasksList_res_pids_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetTasksList_res, rc) == 56, bad_kl_core_Task_GetTasksList_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_GetTasksList_res */
typedef struct __nk_packed kl_core_Task_SetInitialThreadSchedPolicy_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(4) nk_uint32_t policy;
            __nk_alignas(4) nk_uint32_t priority;
            __nk_alignas(8)
            struct kl_core_Types_TrSchedParam param;
        }
kl_core_Task_SetInitialThreadSchedPolicy_req;
nk_static_assert(sizeof(kl_core_Task_SetInitialThreadSchedPolicy_req) == 72, bad_kl_core_Task_SetInitialThreadSchedPolicy_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadSchedPolicy_req, base_) == 0, bad_kl_core_Task_SetInitialThreadSchedPolicy_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadSchedPolicy_req, task) == 24, bad_kl_core_Task_SetInitialThreadSchedPolicy_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadSchedPolicy_req, policy) == 40, bad_kl_core_Task_SetInitialThreadSchedPolicy_req_policy_offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadSchedPolicy_req, priority) == 44, bad_kl_core_Task_SetInitialThreadSchedPolicy_req_priority_offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadSchedPolicy_req, param) == 48, bad_kl_core_Task_SetInitialThreadSchedPolicy_req_param_offset);
#pragma pack(push, 8) /* kl_core_Task_SetInitialThreadSchedPolicy_res */
typedef struct kl_core_Task_SetInitialThreadSchedPolicy_err {
            __nk_alignas(8)
            struct nk_message base_;
        }
kl_core_Task_SetInitialThreadSchedPolicy_err;
nk_static_assert(sizeof(kl_core_Task_SetInitialThreadSchedPolicy_err) == 24, bad_kl_core_Task_SetInitialThreadSchedPolicy_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadSchedPolicy_err, base_) == 0, bad_kl_core_Task_SetInitialThreadSchedPolicy_err_base__offset);
typedef struct kl_core_Task_SetInitialThreadSchedPolicy_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_SetInitialThreadSchedPolicy_err err_;
            };
        }
kl_core_Task_SetInitialThreadSchedPolicy_res;
nk_static_assert(sizeof(kl_core_Task_SetInitialThreadSchedPolicy_res) == 32, bad_kl_core_Task_SetInitialThreadSchedPolicy_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadSchedPolicy_res, base_) == 0, bad_kl_core_Task_SetInitialThreadSchedPolicy_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_SetInitialThreadSchedPolicy_res, rc) == 24, bad_kl_core_Task_SetInitialThreadSchedPolicy_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_SetInitialThreadSchedPolicy_res */
typedef struct __nk_packed kl_core_Task_ReseedAslr_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(4) nk_ptr_t seed;
        } kl_core_Task_ReseedAslr_req;
nk_static_assert(sizeof(kl_core_Task_ReseedAslr_req) == 48, bad_kl_core_Task_ReseedAslr_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_ReseedAslr_req, base_) == 0, bad_kl_core_Task_ReseedAslr_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_ReseedAslr_req, task) == 24, bad_kl_core_Task_ReseedAslr_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Task_ReseedAslr_req, seed) == 40, bad_kl_core_Task_ReseedAslr_req_seed_offset);
#pragma pack(push, 8) /* kl_core_Task_ReseedAslr_res */
typedef struct kl_core_Task_ReseedAslr_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_ReseedAslr_err;
nk_static_assert(sizeof(kl_core_Task_ReseedAslr_err) == 24, bad_kl_core_Task_ReseedAslr_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_ReseedAslr_err, base_) == 0, bad_kl_core_Task_ReseedAslr_err_base__offset);
typedef struct kl_core_Task_ReseedAslr_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_ReseedAslr_err err_;
            };
        } kl_core_Task_ReseedAslr_res;
nk_static_assert(sizeof(kl_core_Task_ReseedAslr_res) == 32, bad_kl_core_Task_ReseedAslr_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_ReseedAslr_res, base_) == 0, bad_kl_core_Task_ReseedAslr_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_ReseedAslr_res, rc) == 24, bad_kl_core_Task_ReseedAslr_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_ReseedAslr_res */
typedef struct __nk_packed kl_core_Task_GetElfSyms_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_GetElfSyms_req;
nk_static_assert(sizeof(kl_core_Task_GetElfSyms_req) == 24, bad_kl_core_Task_GetElfSyms_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetElfSyms_req, base_) == 0, bad_kl_core_Task_GetElfSyms_req_base__offset);
#pragma pack(push, 8) /* kl_core_Task_GetElfSyms_res */
typedef struct kl_core_Task_GetElfSyms_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_GetElfSyms_err;
nk_static_assert(sizeof(kl_core_Task_GetElfSyms_err) == 24, bad_kl_core_Task_GetElfSyms_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetElfSyms_err, base_) == 0, bad_kl_core_Task_GetElfSyms_err_base__offset);
typedef struct kl_core_Task_GetElfSyms_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t relocBase;
                    __nk_alignas(8)
                    nk_uint64_t syms;
                    __nk_alignas(8)
                    nk_uint64_t symsCnt;
                    __nk_alignas(8)
                    nk_uint64_t strs;
                    __nk_alignas(8)
                    nk_uint64_t strsSize;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t relocBase;
                    __nk_alignas(8)
                    nk_uint64_t syms;
                    __nk_alignas(8)
                    nk_uint64_t symsCnt;
                    __nk_alignas(8)
                    nk_uint64_t strs;
                    __nk_alignas(8)
                    nk_uint64_t strsSize;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_GetElfSyms_err err_;
            };
        } kl_core_Task_GetElfSyms_res;
nk_static_assert(sizeof(kl_core_Task_GetElfSyms_res) == 72, bad_kl_core_Task_GetElfSyms_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetElfSyms_res, base_) == 0, bad_kl_core_Task_GetElfSyms_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetElfSyms_res, relocBase) == 24, bad_kl_core_Task_GetElfSyms_res_relocBase_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetElfSyms_res, syms) == 32, bad_kl_core_Task_GetElfSyms_res_syms_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetElfSyms_res, symsCnt) == 40, bad_kl_core_Task_GetElfSyms_res_symsCnt_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetElfSyms_res, strs) == 48, bad_kl_core_Task_GetElfSyms_res_strs_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetElfSyms_res, strsSize) == 56, bad_kl_core_Task_GetElfSyms_res_strsSize_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetElfSyms_res, rc) == 64, bad_kl_core_Task_GetElfSyms_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_GetElfSyms_res */
typedef struct __nk_packed kl_core_Task_TransferHandle_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t srcHandle;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t srcBadge;
            __nk_alignas(4) nk_uint32_t dstRights;
        } kl_core_Task_TransferHandle_req;
nk_static_assert(sizeof(kl_core_Task_TransferHandle_req) == 80, bad_kl_core_Task_TransferHandle_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_TransferHandle_req, base_) == 0, bad_kl_core_Task_TransferHandle_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_TransferHandle_req, task) == 24, bad_kl_core_Task_TransferHandle_req_task_offset);
nk_static_assert(nk_offsetof(kl_core_Task_TransferHandle_req, srcHandle) == 40, bad_kl_core_Task_TransferHandle_req_srcHandle_offset);
nk_static_assert(nk_offsetof(kl_core_Task_TransferHandle_req, srcBadge) == 56, bad_kl_core_Task_TransferHandle_req_srcBadge_offset);
nk_static_assert(nk_offsetof(kl_core_Task_TransferHandle_req, dstRights) == 72, bad_kl_core_Task_TransferHandle_req_dstRights_offset);
#pragma pack(push, 8) /* kl_core_Task_TransferHandle_res */
typedef struct kl_core_Task_TransferHandle_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_TransferHandle_err;
nk_static_assert(sizeof(kl_core_Task_TransferHandle_err) == 24, bad_kl_core_Task_TransferHandle_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_TransferHandle_err, base_) == 0, bad_kl_core_Task_TransferHandle_err_base__offset);
typedef struct kl_core_Task_TransferHandle_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t dstHandle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t dstHandle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_TransferHandle_err err_;
            };
        } kl_core_Task_TransferHandle_res;
nk_static_assert(sizeof(kl_core_Task_TransferHandle_res) == 32, bad_kl_core_Task_TransferHandle_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_TransferHandle_res, base_) == 0, bad_kl_core_Task_TransferHandle_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_TransferHandle_res, dstHandle) == 24, bad_kl_core_Task_TransferHandle_res_dstHandle_offset);
nk_static_assert(nk_offsetof(kl_core_Task_TransferHandle_res, rc) == 28, bad_kl_core_Task_TransferHandle_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_TransferHandle_res */
typedef struct __nk_packed kl_core_Task_GetPid_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t task;
        } kl_core_Task_GetPid_req;
nk_static_assert(sizeof(kl_core_Task_GetPid_req) == 40, bad_kl_core_Task_GetPid_req_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetPid_req, base_) == 0, bad_kl_core_Task_GetPid_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetPid_req, task) == 24, bad_kl_core_Task_GetPid_req_task_offset);
#pragma pack(push, 8) /* kl_core_Task_GetPid_res */
typedef struct kl_core_Task_GetPid_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Task_GetPid_err;
nk_static_assert(sizeof(kl_core_Task_GetPid_err) == 24, bad_kl_core_Task_GetPid_err_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetPid_err, base_) == 0, bad_kl_core_Task_GetPid_err_base__offset);
typedef struct kl_core_Task_GetPid_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t pid;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t pid;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Task_GetPid_err err_;
            };
        } kl_core_Task_GetPid_res;
nk_static_assert(sizeof(kl_core_Task_GetPid_res) == 32, bad_kl_core_Task_GetPid_res_size);
nk_static_assert(nk_offsetof(kl_core_Task_GetPid_res, base_) == 0, bad_kl_core_Task_GetPid_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetPid_res, pid) == 24, bad_kl_core_Task_GetPid_res_pid_offset);
nk_static_assert(nk_offsetof(kl_core_Task_GetPid_res, rc) == 28, bad_kl_core_Task_GetPid_res_rc_offset);
#pragma pack(pop) /* kl_core_Task_GetPid_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Task_Create_mid kl_core_Task_Create_mid
#define Task_LoadSeg_mid kl_core_Task_LoadSeg_mid
#define Task_VmReserve_mid kl_core_Task_VmReserve_mid
#define Task_VmFree_mid kl_core_Task_VmFree_mid
#define Task_SetEntry_mid kl_core_Task_SetEntry_mid
#define Task_LoadElfSyms_mid kl_core_Task_LoadElfSyms_mid
#define Task_LoadElfHdr_mid kl_core_Task_LoadElfHdr_mid
#define Task_SetEnv_mid kl_core_Task_SetEnv_mid
#define Task_FreeSelfEnv_mid kl_core_Task_FreeSelfEnv_mid
#define Task_Resume_mid kl_core_Task_Resume_mid
#define Task_Exit_mid kl_core_Task_Exit_mid
#define Task_Terminate_mid kl_core_Task_Terminate_mid
#define Task_GetExitInfo_mid kl_core_Task_GetExitInfo_mid
#define Task_GetThreadContext_mid kl_core_Task_GetThreadContext_mid
#define Task_GetNextVmRegion_mid kl_core_Task_GetNextVmRegion_mid
#define Task_TerminateAfterFreezing_mid kl_core_Task_TerminateAfterFreezing_mid
#define Task_GetName_mid kl_core_Task_GetName_mid
#define Task_GetPath_mid kl_core_Task_GetPath_mid
#define Task_GetInitialThreadPriority_mid kl_core_Task_GetInitialThreadPriority_mid
#define Task_SetInitialThreadPriority_mid kl_core_Task_SetInitialThreadPriority_mid
#define Task_GetTasksList_mid kl_core_Task_GetTasksList_mid
#define Task_SetInitialThreadSchedPolicy_mid kl_core_Task_SetInitialThreadSchedPolicy_mid
#define Task_ReseedAslr_mid kl_core_Task_ReseedAslr_mid
#define Task_GetElfSyms_mid kl_core_Task_GetElfSyms_mid
#define Task_TransferHandle_mid kl_core_Task_TransferHandle_mid
#define Task_GetPid_mid kl_core_Task_GetPid_mid
#define Task_mid_max kl_core_Task_mid_max
#define Task_Create_req_name_size kl_core_Task_Create_req_name_size
#define Task_Create_req_eiid_size kl_core_Task_Create_req_eiid_size
#define Task_Create_req_path_size kl_core_Task_Create_req_path_size
#define Task_Create_req_arena_size kl_core_Task_Create_req_arena_size
#define Task_Create_res_arena_size kl_core_Task_Create_res_arena_size
#define Task_Create_req_handles kl_core_Task_Create_req_handles
#define Task_Create_res_handles kl_core_Task_Create_res_handles
#define Task_Create_err_handles kl_core_Task_Create_err_handles
#define Task_LoadSeg_req_arena_size kl_core_Task_LoadSeg_req_arena_size
#define Task_LoadSeg_res_arena_size kl_core_Task_LoadSeg_res_arena_size
#define Task_LoadSeg_req_handles kl_core_Task_LoadSeg_req_handles
#define Task_LoadSeg_res_handles kl_core_Task_LoadSeg_res_handles
#define Task_LoadSeg_err_handles kl_core_Task_LoadSeg_err_handles
#define Task_VmReserve_req_arena_size kl_core_Task_VmReserve_req_arena_size
#define Task_VmReserve_res_arena_size kl_core_Task_VmReserve_res_arena_size
#define Task_VmReserve_req_handles kl_core_Task_VmReserve_req_handles
#define Task_VmReserve_res_handles kl_core_Task_VmReserve_res_handles
#define Task_VmReserve_err_handles kl_core_Task_VmReserve_err_handles
#define Task_VmFree_req_arena_size kl_core_Task_VmFree_req_arena_size
#define Task_VmFree_res_arena_size kl_core_Task_VmFree_res_arena_size
#define Task_VmFree_req_handles kl_core_Task_VmFree_req_handles
#define Task_VmFree_res_handles kl_core_Task_VmFree_res_handles
#define Task_VmFree_err_handles kl_core_Task_VmFree_err_handles
#define Task_SetEntry_req_arena_size kl_core_Task_SetEntry_req_arena_size
#define Task_SetEntry_res_arena_size kl_core_Task_SetEntry_res_arena_size
#define Task_SetEntry_req_handles kl_core_Task_SetEntry_req_handles
#define Task_SetEntry_res_handles kl_core_Task_SetEntry_res_handles
#define Task_SetEntry_err_handles kl_core_Task_SetEntry_err_handles
#define Task_LoadElfSyms_req_arena_size kl_core_Task_LoadElfSyms_req_arena_size
#define Task_LoadElfSyms_res_arena_size kl_core_Task_LoadElfSyms_res_arena_size
#define Task_LoadElfSyms_req_handles kl_core_Task_LoadElfSyms_req_handles
#define Task_LoadElfSyms_res_handles kl_core_Task_LoadElfSyms_res_handles
#define Task_LoadElfSyms_err_handles kl_core_Task_LoadElfSyms_err_handles
#define Task_LoadElfHdr_req_hdrData_size kl_core_Task_LoadElfHdr_req_hdrData_size
#define Task_LoadElfHdr_req_arena_size kl_core_Task_LoadElfHdr_req_arena_size
#define Task_LoadElfHdr_res_arena_size kl_core_Task_LoadElfHdr_res_arena_size
#define Task_LoadElfHdr_req_handles kl_core_Task_LoadElfHdr_req_handles
#define Task_LoadElfHdr_res_handles kl_core_Task_LoadElfHdr_res_handles
#define Task_LoadElfHdr_err_handles kl_core_Task_LoadElfHdr_err_handles
#define Task_SetEnv_req_env_size kl_core_Task_SetEnv_req_env_size
#define Task_SetEnv_req_arena_size kl_core_Task_SetEnv_req_arena_size
#define Task_SetEnv_res_arena_size kl_core_Task_SetEnv_res_arena_size
#define Task_SetEnv_req_handles kl_core_Task_SetEnv_req_handles
#define Task_SetEnv_res_handles kl_core_Task_SetEnv_res_handles
#define Task_SetEnv_err_handles kl_core_Task_SetEnv_err_handles
#define Task_FreeSelfEnv_req_arena_size kl_core_Task_FreeSelfEnv_req_arena_size
#define Task_FreeSelfEnv_res_arena_size kl_core_Task_FreeSelfEnv_res_arena_size
#define Task_FreeSelfEnv_req_handles kl_core_Task_FreeSelfEnv_req_handles
#define Task_FreeSelfEnv_res_handles kl_core_Task_FreeSelfEnv_res_handles
#define Task_FreeSelfEnv_err_handles kl_core_Task_FreeSelfEnv_err_handles
#define Task_Resume_req_arena_size kl_core_Task_Resume_req_arena_size
#define Task_Resume_res_arena_size kl_core_Task_Resume_res_arena_size
#define Task_Resume_req_handles kl_core_Task_Resume_req_handles
#define Task_Resume_res_handles kl_core_Task_Resume_res_handles
#define Task_Resume_err_handles kl_core_Task_Resume_err_handles
#define Task_Exit_req_arena_size kl_core_Task_Exit_req_arena_size
#define Task_Exit_res_arena_size kl_core_Task_Exit_res_arena_size
#define Task_Exit_req_handles kl_core_Task_Exit_req_handles
#define Task_Exit_res_handles kl_core_Task_Exit_res_handles
#define Task_Exit_err_handles kl_core_Task_Exit_err_handles
#define Task_Terminate_req_arena_size kl_core_Task_Terminate_req_arena_size
#define Task_Terminate_res_arena_size kl_core_Task_Terminate_res_arena_size
#define Task_Terminate_req_handles kl_core_Task_Terminate_req_handles
#define Task_Terminate_res_handles kl_core_Task_Terminate_res_handles
#define Task_Terminate_err_handles kl_core_Task_Terminate_err_handles
#define Task_GetExitInfo_res_info_exc_frame_size kl_core_Task_GetExitInfo_res_info_exc_frame_size
#define Task_GetExitInfo_req_arena_size kl_core_Task_GetExitInfo_req_arena_size
#define Task_GetExitInfo_res_arena_size kl_core_Task_GetExitInfo_res_arena_size
#define Task_GetExitInfo_req_handles kl_core_Task_GetExitInfo_req_handles
#define Task_GetExitInfo_res_handles kl_core_Task_GetExitInfo_res_handles
#define Task_GetExitInfo_err_handles kl_core_Task_GetExitInfo_err_handles
#define Task_GetThreadContext_res_context_frame_size kl_core_Task_GetThreadContext_res_context_frame_size
#define Task_GetThreadContext_req_arena_size kl_core_Task_GetThreadContext_req_arena_size
#define Task_GetThreadContext_res_arena_size kl_core_Task_GetThreadContext_res_arena_size
#define Task_GetThreadContext_req_handles kl_core_Task_GetThreadContext_req_handles
#define Task_GetThreadContext_res_handles kl_core_Task_GetThreadContext_res_handles
#define Task_GetThreadContext_err_handles kl_core_Task_GetThreadContext_err_handles
#define Task_GetNextVmRegion_req_arena_size kl_core_Task_GetNextVmRegion_req_arena_size
#define Task_GetNextVmRegion_res_arena_size kl_core_Task_GetNextVmRegion_res_arena_size
#define Task_GetNextVmRegion_req_handles kl_core_Task_GetNextVmRegion_req_handles
#define Task_GetNextVmRegion_res_handles kl_core_Task_GetNextVmRegion_res_handles
#define Task_GetNextVmRegion_err_handles kl_core_Task_GetNextVmRegion_err_handles
#define Task_TerminateAfterFreezing_req_arena_size kl_core_Task_TerminateAfterFreezing_req_arena_size
#define Task_TerminateAfterFreezing_res_arena_size kl_core_Task_TerminateAfterFreezing_res_arena_size
#define Task_TerminateAfterFreezing_req_handles kl_core_Task_TerminateAfterFreezing_req_handles
#define Task_TerminateAfterFreezing_res_handles kl_core_Task_TerminateAfterFreezing_res_handles
#define Task_TerminateAfterFreezing_err_handles kl_core_Task_TerminateAfterFreezing_err_handles
#define Task_GetName_res_name_size kl_core_Task_GetName_res_name_size
#define Task_GetName_req_arena_size kl_core_Task_GetName_req_arena_size
#define Task_GetName_res_arena_size kl_core_Task_GetName_res_arena_size
#define Task_GetName_req_handles kl_core_Task_GetName_req_handles
#define Task_GetName_res_handles kl_core_Task_GetName_res_handles
#define Task_GetName_err_handles kl_core_Task_GetName_err_handles
#define Task_GetPath_res_path_size kl_core_Task_GetPath_res_path_size
#define Task_GetPath_req_arena_size kl_core_Task_GetPath_req_arena_size
#define Task_GetPath_res_arena_size kl_core_Task_GetPath_res_arena_size
#define Task_GetPath_req_handles kl_core_Task_GetPath_req_handles
#define Task_GetPath_res_handles kl_core_Task_GetPath_res_handles
#define Task_GetPath_err_handles kl_core_Task_GetPath_err_handles
#define Task_GetInitialThreadPriority_req_arena_size kl_core_Task_GetInitialThreadPriority_req_arena_size
#define Task_GetInitialThreadPriority_res_arena_size kl_core_Task_GetInitialThreadPriority_res_arena_size
#define Task_GetInitialThreadPriority_req_handles kl_core_Task_GetInitialThreadPriority_req_handles
#define Task_GetInitialThreadPriority_res_handles kl_core_Task_GetInitialThreadPriority_res_handles
#define Task_GetInitialThreadPriority_err_handles kl_core_Task_GetInitialThreadPriority_err_handles
#define Task_SetInitialThreadPriority_req_arena_size kl_core_Task_SetInitialThreadPriority_req_arena_size
#define Task_SetInitialThreadPriority_res_arena_size kl_core_Task_SetInitialThreadPriority_res_arena_size
#define Task_SetInitialThreadPriority_req_handles kl_core_Task_SetInitialThreadPriority_req_handles
#define Task_SetInitialThreadPriority_res_handles kl_core_Task_SetInitialThreadPriority_res_handles
#define Task_SetInitialThreadPriority_err_handles kl_core_Task_SetInitialThreadPriority_err_handles
#define Task_GetTasksList_res_strings_size kl_core_Task_GetTasksList_res_strings_size
#define Task_GetTasksList_res_pids_size kl_core_Task_GetTasksList_res_pids_size
#define Task_GetTasksList_req_arena_size kl_core_Task_GetTasksList_req_arena_size
#define Task_GetTasksList_res_arena_size kl_core_Task_GetTasksList_res_arena_size
#define Task_GetTasksList_req_handles kl_core_Task_GetTasksList_req_handles
#define Task_GetTasksList_res_handles kl_core_Task_GetTasksList_res_handles
#define Task_GetTasksList_err_handles kl_core_Task_GetTasksList_err_handles
#define Task_SetInitialThreadSchedPolicy_req_arena_size kl_core_Task_SetInitialThreadSchedPolicy_req_arena_size
#define Task_SetInitialThreadSchedPolicy_res_arena_size kl_core_Task_SetInitialThreadSchedPolicy_res_arena_size
#define Task_SetInitialThreadSchedPolicy_req_handles kl_core_Task_SetInitialThreadSchedPolicy_req_handles
#define Task_SetInitialThreadSchedPolicy_res_handles kl_core_Task_SetInitialThreadSchedPolicy_res_handles
#define Task_SetInitialThreadSchedPolicy_err_handles kl_core_Task_SetInitialThreadSchedPolicy_err_handles
#define Task_ReseedAslr_req_seed_size kl_core_Task_ReseedAslr_req_seed_size
#define Task_ReseedAslr_req_arena_size kl_core_Task_ReseedAslr_req_arena_size
#define Task_ReseedAslr_res_arena_size kl_core_Task_ReseedAslr_res_arena_size
#define Task_ReseedAslr_req_handles kl_core_Task_ReseedAslr_req_handles
#define Task_ReseedAslr_res_handles kl_core_Task_ReseedAslr_res_handles
#define Task_ReseedAslr_err_handles kl_core_Task_ReseedAslr_err_handles
#define Task_GetElfSyms_req_arena_size kl_core_Task_GetElfSyms_req_arena_size
#define Task_GetElfSyms_res_arena_size kl_core_Task_GetElfSyms_res_arena_size
#define Task_GetElfSyms_req_handles kl_core_Task_GetElfSyms_req_handles
#define Task_GetElfSyms_res_handles kl_core_Task_GetElfSyms_res_handles
#define Task_GetElfSyms_err_handles kl_core_Task_GetElfSyms_err_handles
#define Task_TransferHandle_req_arena_size kl_core_Task_TransferHandle_req_arena_size
#define Task_TransferHandle_res_arena_size kl_core_Task_TransferHandle_res_arena_size
#define Task_TransferHandle_req_handles kl_core_Task_TransferHandle_req_handles
#define Task_TransferHandle_res_handles kl_core_Task_TransferHandle_res_handles
#define Task_TransferHandle_err_handles kl_core_Task_TransferHandle_err_handles
#define Task_GetPid_req_arena_size kl_core_Task_GetPid_req_arena_size
#define Task_GetPid_res_arena_size kl_core_Task_GetPid_res_arena_size
#define Task_GetPid_req_handles kl_core_Task_GetPid_req_handles
#define Task_GetPid_res_handles kl_core_Task_GetPid_res_handles
#define Task_GetPid_err_handles kl_core_Task_GetPid_err_handles
#define Task_req_arena_size kl_core_Task_req_arena_size
#define Task_res_arena_size kl_core_Task_res_arena_size
#define Task_req_handles kl_core_Task_req_handles
#define Task_res_handles kl_core_Task_res_handles
#define Task_err_handles kl_core_Task_err_handles
#define Task_Create_req kl_core_Task_Create_req
#define Task_Create_res kl_core_Task_Create_res
#define Task_LoadSeg_req kl_core_Task_LoadSeg_req
#define Task_LoadSeg_res kl_core_Task_LoadSeg_res
#define Task_VmReserve_req kl_core_Task_VmReserve_req
#define Task_VmReserve_res kl_core_Task_VmReserve_res
#define Task_VmFree_req kl_core_Task_VmFree_req
#define Task_VmFree_res kl_core_Task_VmFree_res
#define Task_SetEntry_req kl_core_Task_SetEntry_req
#define Task_SetEntry_res kl_core_Task_SetEntry_res
#define Task_LoadElfSyms_req kl_core_Task_LoadElfSyms_req
#define Task_LoadElfSyms_res kl_core_Task_LoadElfSyms_res
#define Task_LoadElfHdr_req kl_core_Task_LoadElfHdr_req
#define Task_LoadElfHdr_res kl_core_Task_LoadElfHdr_res
#define Task_SetEnv_req kl_core_Task_SetEnv_req
#define Task_SetEnv_res kl_core_Task_SetEnv_res
#define Task_FreeSelfEnv_req kl_core_Task_FreeSelfEnv_req
#define Task_FreeSelfEnv_res kl_core_Task_FreeSelfEnv_res
#define Task_Resume_req kl_core_Task_Resume_req
#define Task_Resume_res kl_core_Task_Resume_res
#define Task_Exit_req kl_core_Task_Exit_req
#define Task_Exit_res kl_core_Task_Exit_res
#define Task_Terminate_req kl_core_Task_Terminate_req
#define Task_Terminate_res kl_core_Task_Terminate_res
#define Task_GetExitInfo_req kl_core_Task_GetExitInfo_req
#define Task_GetExitInfo_res kl_core_Task_GetExitInfo_res
#define Task_GetThreadContext_req kl_core_Task_GetThreadContext_req
#define Task_GetThreadContext_res kl_core_Task_GetThreadContext_res
#define Task_GetNextVmRegion_req kl_core_Task_GetNextVmRegion_req
#define Task_GetNextVmRegion_res kl_core_Task_GetNextVmRegion_res
#define Task_TerminateAfterFreezing_req kl_core_Task_TerminateAfterFreezing_req
#define Task_TerminateAfterFreezing_res kl_core_Task_TerminateAfterFreezing_res
#define Task_GetName_req kl_core_Task_GetName_req
#define Task_GetName_res kl_core_Task_GetName_res
#define Task_GetPath_req kl_core_Task_GetPath_req
#define Task_GetPath_res kl_core_Task_GetPath_res
#define Task_GetInitialThreadPriority_req kl_core_Task_GetInitialThreadPriority_req
#define Task_GetInitialThreadPriority_res kl_core_Task_GetInitialThreadPriority_res
#define Task_SetInitialThreadPriority_req kl_core_Task_SetInitialThreadPriority_req
#define Task_SetInitialThreadPriority_res kl_core_Task_SetInitialThreadPriority_res
#define Task_GetTasksList_req kl_core_Task_GetTasksList_req
#define Task_GetTasksList_res kl_core_Task_GetTasksList_res
#define Task_SetInitialThreadSchedPolicy_req kl_core_Task_SetInitialThreadSchedPolicy_req
#define Task_SetInitialThreadSchedPolicy_res kl_core_Task_SetInitialThreadSchedPolicy_res
#define Task_ReseedAslr_req kl_core_Task_ReseedAslr_req
#define Task_ReseedAslr_res kl_core_Task_ReseedAslr_res
#define Task_GetElfSyms_req kl_core_Task_GetElfSyms_req
#define Task_GetElfSyms_res kl_core_Task_GetElfSyms_res
#define Task_TransferHandle_req kl_core_Task_TransferHandle_req
#define Task_TransferHandle_res kl_core_Task_TransferHandle_res
#define Task_GetPid_req kl_core_Task_GetPid_req
#define Task_GetPid_res kl_core_Task_GetPid_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Task__INTERFACE__ */

#ifndef __kl_core__Thread__INTERFACE__
#define __kl_core__Thread__INTERFACE__
enum {
    kl_core_Thread_Create_mid,
    kl_core_Thread_OpenCurrent_mid,
    kl_core_Thread_Attach_mid,
    kl_core_Thread_Suspend_mid,
    kl_core_Thread_Resume_mid,
    kl_core_Thread_Terminate_mid,
    kl_core_Thread_Exit_mid,
    kl_core_Thread_Wait_mid,
    kl_core_Thread_SetPriority_mid,
    kl_core_Thread_SetTls_mid,
    kl_core_Thread_Sleep_mid,
    kl_core_Thread_GetInfo_mid,
    kl_core_Thread_DetachIrq_mid,
    kl_core_Thread_GetAffinity_mid,
    kl_core_Thread_SetAffinity_mid,
    kl_core_Thread_SetSchedPolicy_mid,
    kl_core_Thread_GetSchedPolicy_mid,
    kl_core_Thread_mid_max,
};
enum {
    kl_core_Thread_Create_req_arena_size = 0,
    kl_core_Thread_Create_res_arena_size = 0,
    kl_core_Thread_Create_req_handles = 0,
    kl_core_Thread_Create_res_handles = 1,
    kl_core_Thread_Create_err_handles = 0,
    kl_core_Thread_OpenCurrent_req_arena_size = 0,
    kl_core_Thread_OpenCurrent_res_arena_size = 0,
    kl_core_Thread_OpenCurrent_req_handles = 0,
    kl_core_Thread_OpenCurrent_res_handles = 1,
    kl_core_Thread_OpenCurrent_err_handles = 0,
    kl_core_Thread_Attach_req_arena_size = 0,
    kl_core_Thread_Attach_res_arena_size = 0,
    kl_core_Thread_Attach_req_handles = 0,
    kl_core_Thread_Attach_res_handles = 1,
    kl_core_Thread_Attach_err_handles = 0,
    kl_core_Thread_Suspend_req_arena_size = 0,
    kl_core_Thread_Suspend_res_arena_size = 0,
    kl_core_Thread_Suspend_req_handles = 0,
    kl_core_Thread_Suspend_res_handles = 0,
    kl_core_Thread_Suspend_err_handles = 0,
    kl_core_Thread_Resume_req_arena_size = 0,
    kl_core_Thread_Resume_res_arena_size = 0,
    kl_core_Thread_Resume_req_handles = 1,
    kl_core_Thread_Resume_res_handles = 0,
    kl_core_Thread_Resume_err_handles = 0,
    kl_core_Thread_Terminate_req_arena_size = 0,
    kl_core_Thread_Terminate_res_arena_size = 0,
    kl_core_Thread_Terminate_req_handles = 1,
    kl_core_Thread_Terminate_res_handles = 0,
    kl_core_Thread_Terminate_err_handles = 0,
    kl_core_Thread_Exit_req_arena_size = 0,
    kl_core_Thread_Exit_res_arena_size = 0,
    kl_core_Thread_Exit_req_handles = 0,
    kl_core_Thread_Exit_res_handles = 0,
    kl_core_Thread_Exit_err_handles = 0,
    kl_core_Thread_Wait_req_arena_size = 0,
    kl_core_Thread_Wait_res_arena_size = 0,
    kl_core_Thread_Wait_req_handles = 1,
    kl_core_Thread_Wait_res_handles = 0,
    kl_core_Thread_Wait_err_handles = 0,
    kl_core_Thread_SetPriority_req_arena_size = 0,
    kl_core_Thread_SetPriority_res_arena_size = 0,
    kl_core_Thread_SetPriority_req_handles = 1,
    kl_core_Thread_SetPriority_res_handles = 0,
    kl_core_Thread_SetPriority_err_handles = 0,
    kl_core_Thread_SetTls_req_arena_size = 0,
    kl_core_Thread_SetTls_res_arena_size = 0,
    kl_core_Thread_SetTls_req_handles = 0,
    kl_core_Thread_SetTls_res_handles = 0,
    kl_core_Thread_SetTls_err_handles = 0,
    kl_core_Thread_Sleep_req_arena_size = 0,
    kl_core_Thread_Sleep_res_arena_size = 0,
    kl_core_Thread_Sleep_req_handles = 0,
    kl_core_Thread_Sleep_res_handles = 0,
    kl_core_Thread_Sleep_err_handles = 0,
    kl_core_Thread_GetInfo_req_arena_size = 0,
    kl_core_Thread_GetInfo_res_arena_size = 0,
    kl_core_Thread_GetInfo_req_handles = 1,
    kl_core_Thread_GetInfo_res_handles = 0,
    kl_core_Thread_GetInfo_err_handles = 0,
    kl_core_Thread_DetachIrq_req_arena_size = 0,
    kl_core_Thread_DetachIrq_res_arena_size = 0,
    kl_core_Thread_DetachIrq_req_handles = 0,
    kl_core_Thread_DetachIrq_res_handles = 0,
    kl_core_Thread_DetachIrq_err_handles = 0,
    kl_core_Thread_GetAffinity_req_arena_size = 0,
    kl_core_Thread_GetAffinity_res_arena_size = 0,
    kl_core_Thread_GetAffinity_req_handles = 1,
    kl_core_Thread_GetAffinity_res_handles = 0,
    kl_core_Thread_GetAffinity_err_handles = 0,
    kl_core_Thread_SetAffinity_req_arena_size = 0,
    kl_core_Thread_SetAffinity_res_arena_size = 0,
    kl_core_Thread_SetAffinity_req_handles = 1,
    kl_core_Thread_SetAffinity_res_handles = 0,
    kl_core_Thread_SetAffinity_err_handles = 0,
    kl_core_Thread_SetSchedPolicy_req_arena_size =
    0,
    kl_core_Thread_SetSchedPolicy_res_arena_size =
    0,
    kl_core_Thread_SetSchedPolicy_req_handles = 1,
    kl_core_Thread_SetSchedPolicy_res_handles = 0,
    kl_core_Thread_SetSchedPolicy_err_handles = 0,
    kl_core_Thread_GetSchedPolicy_req_arena_size =
    0,
    kl_core_Thread_GetSchedPolicy_res_arena_size =
    0,
    kl_core_Thread_GetSchedPolicy_req_handles = 1,
    kl_core_Thread_GetSchedPolicy_res_handles = 0,
    kl_core_Thread_GetSchedPolicy_err_handles = 0,
    kl_core_Thread_req_arena_size = 0,
    kl_core_Thread_res_arena_size = 0,
    kl_core_Thread_req_handles = 1,
    kl_core_Thread_res_handles = 1,
    kl_core_Thread_err_handles = 0,
};
typedef struct __nk_packed kl_core_Thread_Create_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t priority;
            __nk_alignas(8) nk_uint64_t stackSize;
            __nk_alignas(8) nk_uint64_t routine;
            __nk_alignas(8) nk_uint64_t context;
            __nk_alignas(8) nk_uint64_t context2;
            __nk_alignas(4) nk_uint32_t flags;
        } kl_core_Thread_Create_req;
nk_static_assert(sizeof(kl_core_Thread_Create_req) == 72, bad_kl_core_Thread_Create_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Create_req, base_) == 0, bad_kl_core_Thread_Create_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Create_req, priority) == 24, bad_kl_core_Thread_Create_req_priority_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Create_req, stackSize) == 32, bad_kl_core_Thread_Create_req_stackSize_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Create_req, routine) == 40, bad_kl_core_Thread_Create_req_routine_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Create_req, context) == 48, bad_kl_core_Thread_Create_req_context_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Create_req, context2) == 56, bad_kl_core_Thread_Create_req_context2_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Create_req, flags) == 64, bad_kl_core_Thread_Create_req_flags_offset);
#pragma pack(push, 8) /* kl_core_Thread_Create_res */
typedef struct kl_core_Thread_Create_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_Create_err;
nk_static_assert(sizeof(kl_core_Thread_Create_err) == 24, bad_kl_core_Thread_Create_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Create_err, base_) == 0, bad_kl_core_Thread_Create_err_base__offset);
typedef struct kl_core_Thread_Create_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
                    __nk_alignas(4)
                    nk_uint32_t tid;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
                    __nk_alignas(4)
                    nk_uint32_t tid;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_Create_err err_;
            };
        } kl_core_Thread_Create_res;
nk_static_assert(sizeof(kl_core_Thread_Create_res) == 48, bad_kl_core_Thread_Create_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Create_res, base_) == 0, bad_kl_core_Thread_Create_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Create_res, thread) == 24, bad_kl_core_Thread_Create_res_thread_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Create_res, tid) == 40, bad_kl_core_Thread_Create_res_tid_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Create_res, rc) == 44, bad_kl_core_Thread_Create_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_Create_res */
typedef struct __nk_packed kl_core_Thread_OpenCurrent_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_OpenCurrent_req;
nk_static_assert(sizeof(kl_core_Thread_OpenCurrent_req) == 24, bad_kl_core_Thread_OpenCurrent_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_OpenCurrent_req, base_) == 0, bad_kl_core_Thread_OpenCurrent_req_base__offset);
#pragma pack(push, 8) /* kl_core_Thread_OpenCurrent_res */
typedef struct kl_core_Thread_OpenCurrent_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_OpenCurrent_err;
nk_static_assert(sizeof(kl_core_Thread_OpenCurrent_err) == 24, bad_kl_core_Thread_OpenCurrent_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_OpenCurrent_err, base_) == 0, bad_kl_core_Thread_OpenCurrent_err_base__offset);
typedef struct kl_core_Thread_OpenCurrent_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_OpenCurrent_err err_;
            };
        } kl_core_Thread_OpenCurrent_res;
nk_static_assert(sizeof(kl_core_Thread_OpenCurrent_res) == 48, bad_kl_core_Thread_OpenCurrent_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_OpenCurrent_res, base_) == 0, bad_kl_core_Thread_OpenCurrent_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_OpenCurrent_res, thread) == 24, bad_kl_core_Thread_OpenCurrent_res_thread_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_OpenCurrent_res, rc) == 40, bad_kl_core_Thread_OpenCurrent_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_OpenCurrent_res */
typedef struct __nk_packed kl_core_Thread_Attach_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t tid;
            __nk_alignas(4) nk_uint32_t rights;
        } kl_core_Thread_Attach_req;
nk_static_assert(sizeof(kl_core_Thread_Attach_req) == 32, bad_kl_core_Thread_Attach_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Attach_req, base_) == 0, bad_kl_core_Thread_Attach_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Attach_req, tid) == 24, bad_kl_core_Thread_Attach_req_tid_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Attach_req, rights) == 28, bad_kl_core_Thread_Attach_req_rights_offset);
#pragma pack(push, 8) /* kl_core_Thread_Attach_res */
typedef struct kl_core_Thread_Attach_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_Attach_err;
nk_static_assert(sizeof(kl_core_Thread_Attach_err) == 24, bad_kl_core_Thread_Attach_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Attach_err, base_) == 0, bad_kl_core_Thread_Attach_err_base__offset);
typedef struct kl_core_Thread_Attach_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_Attach_err err_;
            };
        } kl_core_Thread_Attach_res;
nk_static_assert(sizeof(kl_core_Thread_Attach_res) == 48, bad_kl_core_Thread_Attach_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Attach_res, base_) == 0, bad_kl_core_Thread_Attach_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Attach_res, thread) == 24, bad_kl_core_Thread_Attach_res_thread_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Attach_res, rc) == 40, bad_kl_core_Thread_Attach_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_Attach_res */
typedef struct __nk_packed kl_core_Thread_Suspend_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_Suspend_req;
nk_static_assert(sizeof(kl_core_Thread_Suspend_req) == 24, bad_kl_core_Thread_Suspend_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Suspend_req, base_) == 0, bad_kl_core_Thread_Suspend_req_base__offset);
#pragma pack(push, 8) /* kl_core_Thread_Suspend_res */
typedef struct kl_core_Thread_Suspend_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_Suspend_err;
nk_static_assert(sizeof(kl_core_Thread_Suspend_err) == 24, bad_kl_core_Thread_Suspend_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Suspend_err, base_) == 0, bad_kl_core_Thread_Suspend_err_base__offset);
typedef struct kl_core_Thread_Suspend_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_Suspend_err err_;
            };
        } kl_core_Thread_Suspend_res;
nk_static_assert(sizeof(kl_core_Thread_Suspend_res) == 32, bad_kl_core_Thread_Suspend_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Suspend_res, base_) == 0, bad_kl_core_Thread_Suspend_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Suspend_res, rc) == 24, bad_kl_core_Thread_Suspend_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_Suspend_res */
typedef struct __nk_packed kl_core_Thread_Resume_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
        } kl_core_Thread_Resume_req;
nk_static_assert(sizeof(kl_core_Thread_Resume_req) == 40, bad_kl_core_Thread_Resume_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Resume_req, base_) == 0, bad_kl_core_Thread_Resume_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Resume_req, thread) == 24, bad_kl_core_Thread_Resume_req_thread_offset);
#pragma pack(push, 8) /* kl_core_Thread_Resume_res */
typedef struct kl_core_Thread_Resume_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_Resume_err;
nk_static_assert(sizeof(kl_core_Thread_Resume_err) == 24, bad_kl_core_Thread_Resume_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Resume_err, base_) == 0, bad_kl_core_Thread_Resume_err_base__offset);
typedef struct kl_core_Thread_Resume_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_Resume_err err_;
            };
        } kl_core_Thread_Resume_res;
nk_static_assert(sizeof(kl_core_Thread_Resume_res) == 32, bad_kl_core_Thread_Resume_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Resume_res, base_) == 0, bad_kl_core_Thread_Resume_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Resume_res, rc) == 24, bad_kl_core_Thread_Resume_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_Resume_res */
typedef struct __nk_packed kl_core_Thread_Terminate_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
            __nk_alignas(4) nk_uint32_t code;
        } kl_core_Thread_Terminate_req;
nk_static_assert(sizeof(kl_core_Thread_Terminate_req) == 48, bad_kl_core_Thread_Terminate_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Terminate_req, base_) == 0, bad_kl_core_Thread_Terminate_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Terminate_req, thread) == 24, bad_kl_core_Thread_Terminate_req_thread_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Terminate_req, code) == 40, bad_kl_core_Thread_Terminate_req_code_offset);
#pragma pack(push, 8) /* kl_core_Thread_Terminate_res */
typedef struct kl_core_Thread_Terminate_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_Terminate_err;
nk_static_assert(sizeof(kl_core_Thread_Terminate_err) == 24, bad_kl_core_Thread_Terminate_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Terminate_err, base_) == 0, bad_kl_core_Thread_Terminate_err_base__offset);
typedef struct kl_core_Thread_Terminate_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t tid;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t tid;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_Terminate_err err_;
            };
        } kl_core_Thread_Terminate_res;
nk_static_assert(sizeof(kl_core_Thread_Terminate_res) == 32, bad_kl_core_Thread_Terminate_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Terminate_res, base_) == 0, bad_kl_core_Thread_Terminate_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Terminate_res, tid) == 24, bad_kl_core_Thread_Terminate_res_tid_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Terminate_res, rc) == 28, bad_kl_core_Thread_Terminate_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_Terminate_res */
typedef struct __nk_packed kl_core_Thread_Exit_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t code;
        } kl_core_Thread_Exit_req;
nk_static_assert(sizeof(kl_core_Thread_Exit_req) == 32, bad_kl_core_Thread_Exit_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Exit_req, base_) == 0, bad_kl_core_Thread_Exit_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Exit_req, code) == 24, bad_kl_core_Thread_Exit_req_code_offset);
#pragma pack(push, 8) /* kl_core_Thread_Exit_res */
typedef struct kl_core_Thread_Exit_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_Exit_err;
nk_static_assert(sizeof(kl_core_Thread_Exit_err) == 24, bad_kl_core_Thread_Exit_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Exit_err, base_) == 0, bad_kl_core_Thread_Exit_err_base__offset);
typedef struct kl_core_Thread_Exit_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_Exit_err err_;
            };
        } kl_core_Thread_Exit_res;
nk_static_assert(sizeof(kl_core_Thread_Exit_res) == 32, bad_kl_core_Thread_Exit_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Exit_res, base_) == 0, bad_kl_core_Thread_Exit_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Exit_res, rc) == 24, bad_kl_core_Thread_Exit_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_Exit_res */
typedef struct __nk_packed kl_core_Thread_Wait_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
            __nk_alignas(4) nk_uint32_t msec;
        } kl_core_Thread_Wait_req;
nk_static_assert(sizeof(kl_core_Thread_Wait_req) == 48, bad_kl_core_Thread_Wait_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Wait_req, base_) == 0, bad_kl_core_Thread_Wait_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Wait_req, thread) == 24, bad_kl_core_Thread_Wait_req_thread_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Wait_req, msec) == 40, bad_kl_core_Thread_Wait_req_msec_offset);
#pragma pack(push, 8) /* kl_core_Thread_Wait_res */
typedef struct kl_core_Thread_Wait_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_Wait_err;
nk_static_assert(sizeof(kl_core_Thread_Wait_err) == 24, bad_kl_core_Thread_Wait_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Wait_err, base_) == 0, bad_kl_core_Thread_Wait_err_base__offset);
typedef struct kl_core_Thread_Wait_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t code;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t code;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_Wait_err err_;
            };
        } kl_core_Thread_Wait_res;
nk_static_assert(sizeof(kl_core_Thread_Wait_res) == 32, bad_kl_core_Thread_Wait_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Wait_res, base_) == 0, bad_kl_core_Thread_Wait_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Wait_res, code) == 24, bad_kl_core_Thread_Wait_res_code_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Wait_res, rc) == 28, bad_kl_core_Thread_Wait_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_Wait_res */
typedef struct __nk_packed kl_core_Thread_SetPriority_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
            __nk_alignas(4) nk_uint32_t priority;
        } kl_core_Thread_SetPriority_req;
nk_static_assert(sizeof(kl_core_Thread_SetPriority_req) == 48, bad_kl_core_Thread_SetPriority_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_SetPriority_req, base_) == 0, bad_kl_core_Thread_SetPriority_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_SetPriority_req, thread) == 24, bad_kl_core_Thread_SetPriority_req_thread_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_SetPriority_req, priority) == 40, bad_kl_core_Thread_SetPriority_req_priority_offset);
#pragma pack(push, 8) /* kl_core_Thread_SetPriority_res */
typedef struct kl_core_Thread_SetPriority_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_SetPriority_err;
nk_static_assert(sizeof(kl_core_Thread_SetPriority_err) == 24, bad_kl_core_Thread_SetPriority_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_SetPriority_err, base_) == 0, bad_kl_core_Thread_SetPriority_err_base__offset);
typedef struct kl_core_Thread_SetPriority_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_SetPriority_err err_;
            };
        } kl_core_Thread_SetPriority_res;
nk_static_assert(sizeof(kl_core_Thread_SetPriority_res) == 32, bad_kl_core_Thread_SetPriority_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_SetPriority_res, base_) == 0, bad_kl_core_Thread_SetPriority_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_SetPriority_res, rc) == 24, bad_kl_core_Thread_SetPriority_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_SetPriority_res */
typedef struct __nk_packed kl_core_Thread_SetTls_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t va;
        } kl_core_Thread_SetTls_req;
nk_static_assert(sizeof(kl_core_Thread_SetTls_req) == 32, bad_kl_core_Thread_SetTls_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_SetTls_req, base_) == 0, bad_kl_core_Thread_SetTls_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_SetTls_req, va) == 24, bad_kl_core_Thread_SetTls_req_va_offset);
#pragma pack(push, 8) /* kl_core_Thread_SetTls_res */
typedef struct kl_core_Thread_SetTls_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_SetTls_err;
nk_static_assert(sizeof(kl_core_Thread_SetTls_err) == 24, bad_kl_core_Thread_SetTls_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_SetTls_err, base_) == 0, bad_kl_core_Thread_SetTls_err_base__offset);
typedef struct kl_core_Thread_SetTls_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_SetTls_err err_;
            };
        } kl_core_Thread_SetTls_res;
nk_static_assert(sizeof(kl_core_Thread_SetTls_res) == 32, bad_kl_core_Thread_SetTls_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_SetTls_res, base_) == 0, bad_kl_core_Thread_SetTls_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_SetTls_res, rc) == 24, bad_kl_core_Thread_SetTls_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_SetTls_res */
typedef struct __nk_packed kl_core_Thread_Sleep_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(4) nk_uint32_t mdelay;
        } kl_core_Thread_Sleep_req;
nk_static_assert(sizeof(kl_core_Thread_Sleep_req) == 32, bad_kl_core_Thread_Sleep_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Sleep_req, base_) == 0, bad_kl_core_Thread_Sleep_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Sleep_req, mdelay) == 24, bad_kl_core_Thread_Sleep_req_mdelay_offset);
#pragma pack(push, 8) /* kl_core_Thread_Sleep_res */
typedef struct kl_core_Thread_Sleep_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_Sleep_err;
nk_static_assert(sizeof(kl_core_Thread_Sleep_err) == 24, bad_kl_core_Thread_Sleep_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Sleep_err, base_) == 0, bad_kl_core_Thread_Sleep_err_base__offset);
typedef struct kl_core_Thread_Sleep_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_Sleep_err err_;
            };
        } kl_core_Thread_Sleep_res;
nk_static_assert(sizeof(kl_core_Thread_Sleep_res) == 32, bad_kl_core_Thread_Sleep_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_Sleep_res, base_) == 0, bad_kl_core_Thread_Sleep_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_Sleep_res, rc) == 24, bad_kl_core_Thread_Sleep_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_Sleep_res */
typedef struct __nk_packed kl_core_Thread_GetInfo_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
        } kl_core_Thread_GetInfo_req;
nk_static_assert(sizeof(kl_core_Thread_GetInfo_req) == 40, bad_kl_core_Thread_GetInfo_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_GetInfo_req, base_) == 0, bad_kl_core_Thread_GetInfo_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_GetInfo_req, thread) == 24, bad_kl_core_Thread_GetInfo_req_thread_offset);
#pragma pack(push, 8) /* kl_core_Thread_GetInfo_res */
typedef struct kl_core_Thread_GetInfo_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_GetInfo_err;
nk_static_assert(sizeof(kl_core_Thread_GetInfo_err) == 24, bad_kl_core_Thread_GetInfo_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_GetInfo_err, base_) == 0, bad_kl_core_Thread_GetInfo_err_base__offset);
typedef struct kl_core_Thread_GetInfo_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    struct kl_core_Thread_TrThreadInfo info;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    struct kl_core_Thread_TrThreadInfo info;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_GetInfo_err err_;
            };
        } kl_core_Thread_GetInfo_res;
nk_static_assert(sizeof(kl_core_Thread_GetInfo_res) == 56, bad_kl_core_Thread_GetInfo_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_GetInfo_res, base_) == 0, bad_kl_core_Thread_GetInfo_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_GetInfo_res, info) == 24, bad_kl_core_Thread_GetInfo_res_info_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_GetInfo_res, rc) == 48, bad_kl_core_Thread_GetInfo_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_GetInfo_res */
typedef struct __nk_packed kl_core_Thread_DetachIrq_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_DetachIrq_req;
nk_static_assert(sizeof(kl_core_Thread_DetachIrq_req) == 24, bad_kl_core_Thread_DetachIrq_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_DetachIrq_req, base_) == 0, bad_kl_core_Thread_DetachIrq_req_base__offset);
#pragma pack(push, 8) /* kl_core_Thread_DetachIrq_res */
typedef struct kl_core_Thread_DetachIrq_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_DetachIrq_err;
nk_static_assert(sizeof(kl_core_Thread_DetachIrq_err) == 24, bad_kl_core_Thread_DetachIrq_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_DetachIrq_err, base_) == 0, bad_kl_core_Thread_DetachIrq_err_base__offset);
typedef struct kl_core_Thread_DetachIrq_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_DetachIrq_err err_;
            };
        } kl_core_Thread_DetachIrq_res;
nk_static_assert(sizeof(kl_core_Thread_DetachIrq_res) == 32, bad_kl_core_Thread_DetachIrq_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_DetachIrq_res, base_) == 0, bad_kl_core_Thread_DetachIrq_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_DetachIrq_res, rc) == 24, bad_kl_core_Thread_DetachIrq_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_DetachIrq_res */
typedef struct __nk_packed kl_core_Thread_GetAffinity_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
        } kl_core_Thread_GetAffinity_req;
nk_static_assert(sizeof(kl_core_Thread_GetAffinity_req) == 40, bad_kl_core_Thread_GetAffinity_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_GetAffinity_req, base_) == 0, bad_kl_core_Thread_GetAffinity_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_GetAffinity_req, thread) == 24, bad_kl_core_Thread_GetAffinity_req_thread_offset);
#pragma pack(push, 8) /* kl_core_Thread_GetAffinity_res */
typedef struct kl_core_Thread_GetAffinity_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_GetAffinity_err;
nk_static_assert(sizeof(kl_core_Thread_GetAffinity_err) == 24, bad_kl_core_Thread_GetAffinity_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_GetAffinity_err, base_) == 0, bad_kl_core_Thread_GetAffinity_err_base__offset);
typedef struct kl_core_Thread_GetAffinity_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t mask;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t mask;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_GetAffinity_err err_;
            };
        } kl_core_Thread_GetAffinity_res;
nk_static_assert(sizeof(kl_core_Thread_GetAffinity_res) == 40, bad_kl_core_Thread_GetAffinity_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_GetAffinity_res, base_) == 0, bad_kl_core_Thread_GetAffinity_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_GetAffinity_res, mask) == 24, bad_kl_core_Thread_GetAffinity_res_mask_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_GetAffinity_res, rc) == 32, bad_kl_core_Thread_GetAffinity_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_GetAffinity_res */
typedef struct __nk_packed kl_core_Thread_SetAffinity_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
            __nk_alignas(8) nk_uint64_t mask;
        } kl_core_Thread_SetAffinity_req;
nk_static_assert(sizeof(kl_core_Thread_SetAffinity_req) == 48, bad_kl_core_Thread_SetAffinity_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_SetAffinity_req, base_) == 0, bad_kl_core_Thread_SetAffinity_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_SetAffinity_req, thread) == 24, bad_kl_core_Thread_SetAffinity_req_thread_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_SetAffinity_req, mask) == 40, bad_kl_core_Thread_SetAffinity_req_mask_offset);
#pragma pack(push, 8) /* kl_core_Thread_SetAffinity_res */
typedef struct kl_core_Thread_SetAffinity_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_SetAffinity_err;
nk_static_assert(sizeof(kl_core_Thread_SetAffinity_err) == 24, bad_kl_core_Thread_SetAffinity_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_SetAffinity_err, base_) == 0, bad_kl_core_Thread_SetAffinity_err_base__offset);
typedef struct kl_core_Thread_SetAffinity_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_SetAffinity_err err_;
            };
        } kl_core_Thread_SetAffinity_res;
nk_static_assert(sizeof(kl_core_Thread_SetAffinity_res) == 32, bad_kl_core_Thread_SetAffinity_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_SetAffinity_res, base_) == 0, bad_kl_core_Thread_SetAffinity_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_SetAffinity_res, rc) == 24, bad_kl_core_Thread_SetAffinity_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_SetAffinity_res */
typedef struct __nk_packed kl_core_Thread_SetSchedPolicy_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
            __nk_alignas(4) nk_uint32_t policy;
            __nk_alignas(4) nk_uint32_t priority;
            __nk_alignas(8)
            struct kl_core_Types_TrSchedParam param;
        } kl_core_Thread_SetSchedPolicy_req;
nk_static_assert(sizeof(kl_core_Thread_SetSchedPolicy_req) == 72, bad_kl_core_Thread_SetSchedPolicy_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_SetSchedPolicy_req, base_) == 0, bad_kl_core_Thread_SetSchedPolicy_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_SetSchedPolicy_req, thread) == 24, bad_kl_core_Thread_SetSchedPolicy_req_thread_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_SetSchedPolicy_req, policy) == 40, bad_kl_core_Thread_SetSchedPolicy_req_policy_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_SetSchedPolicy_req, priority) == 44, bad_kl_core_Thread_SetSchedPolicy_req_priority_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_SetSchedPolicy_req, param) == 48, bad_kl_core_Thread_SetSchedPolicy_req_param_offset);
#pragma pack(push, 8) /* kl_core_Thread_SetSchedPolicy_res */
typedef struct kl_core_Thread_SetSchedPolicy_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_SetSchedPolicy_err;
nk_static_assert(sizeof(kl_core_Thread_SetSchedPolicy_err) == 24, bad_kl_core_Thread_SetSchedPolicy_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_SetSchedPolicy_err, base_) == 0, bad_kl_core_Thread_SetSchedPolicy_err_base__offset);
typedef struct kl_core_Thread_SetSchedPolicy_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_SetSchedPolicy_err err_;
            };
        } kl_core_Thread_SetSchedPolicy_res;
nk_static_assert(sizeof(kl_core_Thread_SetSchedPolicy_res) == 32, bad_kl_core_Thread_SetSchedPolicy_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_SetSchedPolicy_res, base_) == 0, bad_kl_core_Thread_SetSchedPolicy_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_SetSchedPolicy_res, rc) == 24, bad_kl_core_Thread_SetSchedPolicy_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_SetSchedPolicy_res */
typedef struct __nk_packed kl_core_Thread_GetSchedPolicy_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t thread;
        } kl_core_Thread_GetSchedPolicy_req;
nk_static_assert(sizeof(kl_core_Thread_GetSchedPolicy_req) == 40, bad_kl_core_Thread_GetSchedPolicy_req_size);
nk_static_assert(nk_offsetof(kl_core_Thread_GetSchedPolicy_req, base_) == 0, bad_kl_core_Thread_GetSchedPolicy_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_GetSchedPolicy_req, thread) == 24, bad_kl_core_Thread_GetSchedPolicy_req_thread_offset);
#pragma pack(push, 8) /* kl_core_Thread_GetSchedPolicy_res */
typedef struct kl_core_Thread_GetSchedPolicy_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Thread_GetSchedPolicy_err;
nk_static_assert(sizeof(kl_core_Thread_GetSchedPolicy_err) == 24, bad_kl_core_Thread_GetSchedPolicy_err_size);
nk_static_assert(nk_offsetof(kl_core_Thread_GetSchedPolicy_err, base_) == 0, bad_kl_core_Thread_GetSchedPolicy_err_base__offset);
typedef struct kl_core_Thread_GetSchedPolicy_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t policy;
                    __nk_alignas(4)
                    nk_uint32_t priority;
                    __nk_alignas(8)
                    struct kl_core_Types_TrSchedParam param;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_uint32_t policy;
                    __nk_alignas(4)
                    nk_uint32_t priority;
                    __nk_alignas(8)
                    struct kl_core_Types_TrSchedParam param;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Thread_GetSchedPolicy_err err_;
            };
        } kl_core_Thread_GetSchedPolicy_res;
nk_static_assert(sizeof(kl_core_Thread_GetSchedPolicy_res) == 64, bad_kl_core_Thread_GetSchedPolicy_res_size);
nk_static_assert(nk_offsetof(kl_core_Thread_GetSchedPolicy_res, base_) == 0, bad_kl_core_Thread_GetSchedPolicy_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Thread_GetSchedPolicy_res, policy) == 24, bad_kl_core_Thread_GetSchedPolicy_res_policy_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_GetSchedPolicy_res, priority) == 28, bad_kl_core_Thread_GetSchedPolicy_res_priority_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_GetSchedPolicy_res, param) == 32, bad_kl_core_Thread_GetSchedPolicy_res_param_offset);
nk_static_assert(nk_offsetof(kl_core_Thread_GetSchedPolicy_res, rc) == 56, bad_kl_core_Thread_GetSchedPolicy_res_rc_offset);
#pragma pack(pop) /* kl_core_Thread_GetSchedPolicy_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Thread_Create_mid kl_core_Thread_Create_mid
#define Thread_OpenCurrent_mid kl_core_Thread_OpenCurrent_mid
#define Thread_Attach_mid kl_core_Thread_Attach_mid
#define Thread_Suspend_mid kl_core_Thread_Suspend_mid
#define Thread_Resume_mid kl_core_Thread_Resume_mid
#define Thread_Terminate_mid kl_core_Thread_Terminate_mid
#define Thread_Exit_mid kl_core_Thread_Exit_mid
#define Thread_Wait_mid kl_core_Thread_Wait_mid
#define Thread_SetPriority_mid kl_core_Thread_SetPriority_mid
#define Thread_SetTls_mid kl_core_Thread_SetTls_mid
#define Thread_Sleep_mid kl_core_Thread_Sleep_mid
#define Thread_GetInfo_mid kl_core_Thread_GetInfo_mid
#define Thread_DetachIrq_mid kl_core_Thread_DetachIrq_mid
#define Thread_GetAffinity_mid kl_core_Thread_GetAffinity_mid
#define Thread_SetAffinity_mid kl_core_Thread_SetAffinity_mid
#define Thread_SetSchedPolicy_mid kl_core_Thread_SetSchedPolicy_mid
#define Thread_GetSchedPolicy_mid kl_core_Thread_GetSchedPolicy_mid
#define Thread_mid_max kl_core_Thread_mid_max
#define Thread_Create_req_arena_size kl_core_Thread_Create_req_arena_size
#define Thread_Create_res_arena_size kl_core_Thread_Create_res_arena_size
#define Thread_Create_req_handles kl_core_Thread_Create_req_handles
#define Thread_Create_res_handles kl_core_Thread_Create_res_handles
#define Thread_Create_err_handles kl_core_Thread_Create_err_handles
#define Thread_OpenCurrent_req_arena_size kl_core_Thread_OpenCurrent_req_arena_size
#define Thread_OpenCurrent_res_arena_size kl_core_Thread_OpenCurrent_res_arena_size
#define Thread_OpenCurrent_req_handles kl_core_Thread_OpenCurrent_req_handles
#define Thread_OpenCurrent_res_handles kl_core_Thread_OpenCurrent_res_handles
#define Thread_OpenCurrent_err_handles kl_core_Thread_OpenCurrent_err_handles
#define Thread_Attach_req_arena_size kl_core_Thread_Attach_req_arena_size
#define Thread_Attach_res_arena_size kl_core_Thread_Attach_res_arena_size
#define Thread_Attach_req_handles kl_core_Thread_Attach_req_handles
#define Thread_Attach_res_handles kl_core_Thread_Attach_res_handles
#define Thread_Attach_err_handles kl_core_Thread_Attach_err_handles
#define Thread_Suspend_req_arena_size kl_core_Thread_Suspend_req_arena_size
#define Thread_Suspend_res_arena_size kl_core_Thread_Suspend_res_arena_size
#define Thread_Suspend_req_handles kl_core_Thread_Suspend_req_handles
#define Thread_Suspend_res_handles kl_core_Thread_Suspend_res_handles
#define Thread_Suspend_err_handles kl_core_Thread_Suspend_err_handles
#define Thread_Resume_req_arena_size kl_core_Thread_Resume_req_arena_size
#define Thread_Resume_res_arena_size kl_core_Thread_Resume_res_arena_size
#define Thread_Resume_req_handles kl_core_Thread_Resume_req_handles
#define Thread_Resume_res_handles kl_core_Thread_Resume_res_handles
#define Thread_Resume_err_handles kl_core_Thread_Resume_err_handles
#define Thread_Terminate_req_arena_size kl_core_Thread_Terminate_req_arena_size
#define Thread_Terminate_res_arena_size kl_core_Thread_Terminate_res_arena_size
#define Thread_Terminate_req_handles kl_core_Thread_Terminate_req_handles
#define Thread_Terminate_res_handles kl_core_Thread_Terminate_res_handles
#define Thread_Terminate_err_handles kl_core_Thread_Terminate_err_handles
#define Thread_Exit_req_arena_size kl_core_Thread_Exit_req_arena_size
#define Thread_Exit_res_arena_size kl_core_Thread_Exit_res_arena_size
#define Thread_Exit_req_handles kl_core_Thread_Exit_req_handles
#define Thread_Exit_res_handles kl_core_Thread_Exit_res_handles
#define Thread_Exit_err_handles kl_core_Thread_Exit_err_handles
#define Thread_Wait_req_arena_size kl_core_Thread_Wait_req_arena_size
#define Thread_Wait_res_arena_size kl_core_Thread_Wait_res_arena_size
#define Thread_Wait_req_handles kl_core_Thread_Wait_req_handles
#define Thread_Wait_res_handles kl_core_Thread_Wait_res_handles
#define Thread_Wait_err_handles kl_core_Thread_Wait_err_handles
#define Thread_SetPriority_req_arena_size kl_core_Thread_SetPriority_req_arena_size
#define Thread_SetPriority_res_arena_size kl_core_Thread_SetPriority_res_arena_size
#define Thread_SetPriority_req_handles kl_core_Thread_SetPriority_req_handles
#define Thread_SetPriority_res_handles kl_core_Thread_SetPriority_res_handles
#define Thread_SetPriority_err_handles kl_core_Thread_SetPriority_err_handles
#define Thread_SetTls_req_arena_size kl_core_Thread_SetTls_req_arena_size
#define Thread_SetTls_res_arena_size kl_core_Thread_SetTls_res_arena_size
#define Thread_SetTls_req_handles kl_core_Thread_SetTls_req_handles
#define Thread_SetTls_res_handles kl_core_Thread_SetTls_res_handles
#define Thread_SetTls_err_handles kl_core_Thread_SetTls_err_handles
#define Thread_Sleep_req_arena_size kl_core_Thread_Sleep_req_arena_size
#define Thread_Sleep_res_arena_size kl_core_Thread_Sleep_res_arena_size
#define Thread_Sleep_req_handles kl_core_Thread_Sleep_req_handles
#define Thread_Sleep_res_handles kl_core_Thread_Sleep_res_handles
#define Thread_Sleep_err_handles kl_core_Thread_Sleep_err_handles
#define Thread_GetInfo_req_arena_size kl_core_Thread_GetInfo_req_arena_size
#define Thread_GetInfo_res_arena_size kl_core_Thread_GetInfo_res_arena_size
#define Thread_GetInfo_req_handles kl_core_Thread_GetInfo_req_handles
#define Thread_GetInfo_res_handles kl_core_Thread_GetInfo_res_handles
#define Thread_GetInfo_err_handles kl_core_Thread_GetInfo_err_handles
#define Thread_DetachIrq_req_arena_size kl_core_Thread_DetachIrq_req_arena_size
#define Thread_DetachIrq_res_arena_size kl_core_Thread_DetachIrq_res_arena_size
#define Thread_DetachIrq_req_handles kl_core_Thread_DetachIrq_req_handles
#define Thread_DetachIrq_res_handles kl_core_Thread_DetachIrq_res_handles
#define Thread_DetachIrq_err_handles kl_core_Thread_DetachIrq_err_handles
#define Thread_GetAffinity_req_arena_size kl_core_Thread_GetAffinity_req_arena_size
#define Thread_GetAffinity_res_arena_size kl_core_Thread_GetAffinity_res_arena_size
#define Thread_GetAffinity_req_handles kl_core_Thread_GetAffinity_req_handles
#define Thread_GetAffinity_res_handles kl_core_Thread_GetAffinity_res_handles
#define Thread_GetAffinity_err_handles kl_core_Thread_GetAffinity_err_handles
#define Thread_SetAffinity_req_arena_size kl_core_Thread_SetAffinity_req_arena_size
#define Thread_SetAffinity_res_arena_size kl_core_Thread_SetAffinity_res_arena_size
#define Thread_SetAffinity_req_handles kl_core_Thread_SetAffinity_req_handles
#define Thread_SetAffinity_res_handles kl_core_Thread_SetAffinity_res_handles
#define Thread_SetAffinity_err_handles kl_core_Thread_SetAffinity_err_handles
#define Thread_SetSchedPolicy_req_arena_size kl_core_Thread_SetSchedPolicy_req_arena_size
#define Thread_SetSchedPolicy_res_arena_size kl_core_Thread_SetSchedPolicy_res_arena_size
#define Thread_SetSchedPolicy_req_handles kl_core_Thread_SetSchedPolicy_req_handles
#define Thread_SetSchedPolicy_res_handles kl_core_Thread_SetSchedPolicy_res_handles
#define Thread_SetSchedPolicy_err_handles kl_core_Thread_SetSchedPolicy_err_handles
#define Thread_GetSchedPolicy_req_arena_size kl_core_Thread_GetSchedPolicy_req_arena_size
#define Thread_GetSchedPolicy_res_arena_size kl_core_Thread_GetSchedPolicy_res_arena_size
#define Thread_GetSchedPolicy_req_handles kl_core_Thread_GetSchedPolicy_req_handles
#define Thread_GetSchedPolicy_res_handles kl_core_Thread_GetSchedPolicy_res_handles
#define Thread_GetSchedPolicy_err_handles kl_core_Thread_GetSchedPolicy_err_handles
#define Thread_req_arena_size kl_core_Thread_req_arena_size
#define Thread_res_arena_size kl_core_Thread_res_arena_size
#define Thread_req_handles kl_core_Thread_req_handles
#define Thread_res_handles kl_core_Thread_res_handles
#define Thread_err_handles kl_core_Thread_err_handles
#define Thread_Create_req kl_core_Thread_Create_req
#define Thread_Create_res kl_core_Thread_Create_res
#define Thread_OpenCurrent_req kl_core_Thread_OpenCurrent_req
#define Thread_OpenCurrent_res kl_core_Thread_OpenCurrent_res
#define Thread_Attach_req kl_core_Thread_Attach_req
#define Thread_Attach_res kl_core_Thread_Attach_res
#define Thread_Suspend_req kl_core_Thread_Suspend_req
#define Thread_Suspend_res kl_core_Thread_Suspend_res
#define Thread_Resume_req kl_core_Thread_Resume_req
#define Thread_Resume_res kl_core_Thread_Resume_res
#define Thread_Terminate_req kl_core_Thread_Terminate_req
#define Thread_Terminate_res kl_core_Thread_Terminate_res
#define Thread_Exit_req kl_core_Thread_Exit_req
#define Thread_Exit_res kl_core_Thread_Exit_res
#define Thread_Wait_req kl_core_Thread_Wait_req
#define Thread_Wait_res kl_core_Thread_Wait_res
#define Thread_SetPriority_req kl_core_Thread_SetPriority_req
#define Thread_SetPriority_res kl_core_Thread_SetPriority_res
#define Thread_SetTls_req kl_core_Thread_SetTls_req
#define Thread_SetTls_res kl_core_Thread_SetTls_res
#define Thread_Sleep_req kl_core_Thread_Sleep_req
#define Thread_Sleep_res kl_core_Thread_Sleep_res
#define Thread_GetInfo_req kl_core_Thread_GetInfo_req
#define Thread_GetInfo_res kl_core_Thread_GetInfo_res
#define Thread_DetachIrq_req kl_core_Thread_DetachIrq_req
#define Thread_DetachIrq_res kl_core_Thread_DetachIrq_res
#define Thread_GetAffinity_req kl_core_Thread_GetAffinity_req
#define Thread_GetAffinity_res kl_core_Thread_GetAffinity_res
#define Thread_SetAffinity_req kl_core_Thread_SetAffinity_req
#define Thread_SetAffinity_res kl_core_Thread_SetAffinity_res
#define Thread_SetSchedPolicy_req kl_core_Thread_SetSchedPolicy_req
#define Thread_SetSchedPolicy_res kl_core_Thread_SetSchedPolicy_res
#define Thread_GetSchedPolicy_req kl_core_Thread_GetSchedPolicy_req
#define Thread_GetSchedPolicy_res kl_core_Thread_GetSchedPolicy_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Thread__INTERFACE__ */

#ifndef __kl_core__Time__INTERFACE__
#define __kl_core__Time__INTERFACE__
enum {
    kl_core_Time_SetSystemTime_mid,
    kl_core_Time_SetSystemTimeAdj_mid,
    kl_core_Time_GetSystemTimeAdj_mid,
    kl_core_Time_mid_max,
};
enum {
    kl_core_Time_SetSystemTime_req_arena_size = 0,
    kl_core_Time_SetSystemTime_res_arena_size = 0,
    kl_core_Time_SetSystemTime_req_handles = 0,
    kl_core_Time_SetSystemTime_res_handles = 0,
    kl_core_Time_SetSystemTime_err_handles = 0,
    kl_core_Time_SetSystemTimeAdj_req_arena_size =
    0,
    kl_core_Time_SetSystemTimeAdj_res_arena_size =
    0,
    kl_core_Time_SetSystemTimeAdj_req_handles = 0,
    kl_core_Time_SetSystemTimeAdj_res_handles = 0,
    kl_core_Time_SetSystemTimeAdj_err_handles = 0,
    kl_core_Time_GetSystemTimeAdj_req_arena_size =
    0,
    kl_core_Time_GetSystemTimeAdj_res_arena_size =
    0,
    kl_core_Time_GetSystemTimeAdj_req_handles = 0,
    kl_core_Time_GetSystemTimeAdj_res_handles = 0,
    kl_core_Time_GetSystemTimeAdj_err_handles = 0,
    kl_core_Time_req_arena_size = 0,
    kl_core_Time_res_arena_size = 0,
    kl_core_Time_req_handles = 0,
    kl_core_Time_res_handles = 0,
    kl_core_Time_err_handles = 0,
};
typedef struct __nk_packed kl_core_Time_SetSystemTime_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_sint64_t secs;
            __nk_alignas(4) nk_uint32_t nsecs;
        } kl_core_Time_SetSystemTime_req;
nk_static_assert(sizeof(kl_core_Time_SetSystemTime_req) == 40, bad_kl_core_Time_SetSystemTime_req_size);
nk_static_assert(nk_offsetof(kl_core_Time_SetSystemTime_req, base_) == 0, bad_kl_core_Time_SetSystemTime_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Time_SetSystemTime_req, secs) == 24, bad_kl_core_Time_SetSystemTime_req_secs_offset);
nk_static_assert(nk_offsetof(kl_core_Time_SetSystemTime_req, nsecs) == 32, bad_kl_core_Time_SetSystemTime_req_nsecs_offset);
#pragma pack(push, 8) /* kl_core_Time_SetSystemTime_res */
typedef struct kl_core_Time_SetSystemTime_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Time_SetSystemTime_err;
nk_static_assert(sizeof(kl_core_Time_SetSystemTime_err) == 24, bad_kl_core_Time_SetSystemTime_err_size);
nk_static_assert(nk_offsetof(kl_core_Time_SetSystemTime_err, base_) == 0, bad_kl_core_Time_SetSystemTime_err_base__offset);
typedef struct kl_core_Time_SetSystemTime_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Time_SetSystemTime_err err_;
            };
        } kl_core_Time_SetSystemTime_res;
nk_static_assert(sizeof(kl_core_Time_SetSystemTime_res) == 32, bad_kl_core_Time_SetSystemTime_res_size);
nk_static_assert(nk_offsetof(kl_core_Time_SetSystemTime_res, base_) == 0, bad_kl_core_Time_SetSystemTime_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Time_SetSystemTime_res, rc) == 24, bad_kl_core_Time_SetSystemTime_res_rc_offset);
#pragma pack(pop) /* kl_core_Time_SetSystemTime_res */
typedef struct __nk_packed kl_core_Time_SetSystemTimeAdj_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8)
            struct kl_core_Types_TimeSpec adj;
            __nk_alignas(4) nk_uint32_t slew;
        } kl_core_Time_SetSystemTimeAdj_req;
nk_static_assert(sizeof(kl_core_Time_SetSystemTimeAdj_req) == 48, bad_kl_core_Time_SetSystemTimeAdj_req_size);
nk_static_assert(nk_offsetof(kl_core_Time_SetSystemTimeAdj_req, base_) == 0, bad_kl_core_Time_SetSystemTimeAdj_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_Time_SetSystemTimeAdj_req, adj) == 24, bad_kl_core_Time_SetSystemTimeAdj_req_adj_offset);
nk_static_assert(nk_offsetof(kl_core_Time_SetSystemTimeAdj_req, slew) == 40, bad_kl_core_Time_SetSystemTimeAdj_req_slew_offset);
#pragma pack(push, 8) /* kl_core_Time_SetSystemTimeAdj_res */
typedef struct kl_core_Time_SetSystemTimeAdj_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Time_SetSystemTimeAdj_err;
nk_static_assert(sizeof(kl_core_Time_SetSystemTimeAdj_err) == 24, bad_kl_core_Time_SetSystemTimeAdj_err_size);
nk_static_assert(nk_offsetof(kl_core_Time_SetSystemTimeAdj_err, base_) == 0, bad_kl_core_Time_SetSystemTimeAdj_err_base__offset);
typedef struct kl_core_Time_SetSystemTimeAdj_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    struct kl_core_Types_TimeSpec prev;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    struct kl_core_Types_TimeSpec prev;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Time_SetSystemTimeAdj_err err_;
            };
        } kl_core_Time_SetSystemTimeAdj_res;
nk_static_assert(sizeof(kl_core_Time_SetSystemTimeAdj_res) == 48, bad_kl_core_Time_SetSystemTimeAdj_res_size);
nk_static_assert(nk_offsetof(kl_core_Time_SetSystemTimeAdj_res, base_) == 0, bad_kl_core_Time_SetSystemTimeAdj_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Time_SetSystemTimeAdj_res, prev) == 24, bad_kl_core_Time_SetSystemTimeAdj_res_prev_offset);
nk_static_assert(nk_offsetof(kl_core_Time_SetSystemTimeAdj_res, rc) == 40, bad_kl_core_Time_SetSystemTimeAdj_res_rc_offset);
#pragma pack(pop) /* kl_core_Time_SetSystemTimeAdj_res */
typedef struct __nk_packed kl_core_Time_GetSystemTimeAdj_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Time_GetSystemTimeAdj_req;
nk_static_assert(sizeof(kl_core_Time_GetSystemTimeAdj_req) == 24, bad_kl_core_Time_GetSystemTimeAdj_req_size);
nk_static_assert(nk_offsetof(kl_core_Time_GetSystemTimeAdj_req, base_) == 0, bad_kl_core_Time_GetSystemTimeAdj_req_base__offset);
#pragma pack(push, 8) /* kl_core_Time_GetSystemTimeAdj_res */
typedef struct kl_core_Time_GetSystemTimeAdj_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_Time_GetSystemTimeAdj_err;
nk_static_assert(sizeof(kl_core_Time_GetSystemTimeAdj_err) == 24, bad_kl_core_Time_GetSystemTimeAdj_err_size);
nk_static_assert(nk_offsetof(kl_core_Time_GetSystemTimeAdj_err, base_) == 0, bad_kl_core_Time_GetSystemTimeAdj_err_base__offset);
typedef struct kl_core_Time_GetSystemTimeAdj_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    struct kl_core_Types_TimeSpec adj;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    struct kl_core_Types_TimeSpec adj;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_Time_GetSystemTimeAdj_err err_;
            };
        } kl_core_Time_GetSystemTimeAdj_res;
nk_static_assert(sizeof(kl_core_Time_GetSystemTimeAdj_res) == 48, bad_kl_core_Time_GetSystemTimeAdj_res_size);
nk_static_assert(nk_offsetof(kl_core_Time_GetSystemTimeAdj_res, base_) == 0, bad_kl_core_Time_GetSystemTimeAdj_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_Time_GetSystemTimeAdj_res, adj) == 24, bad_kl_core_Time_GetSystemTimeAdj_res_adj_offset);
nk_static_assert(nk_offsetof(kl_core_Time_GetSystemTimeAdj_res, rc) == 40, bad_kl_core_Time_GetSystemTimeAdj_res_rc_offset);
#pragma pack(pop) /* kl_core_Time_GetSystemTimeAdj_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Time_SetSystemTime_mid kl_core_Time_SetSystemTime_mid
#define Time_SetSystemTimeAdj_mid kl_core_Time_SetSystemTimeAdj_mid
#define Time_GetSystemTimeAdj_mid kl_core_Time_GetSystemTimeAdj_mid
#define Time_mid_max kl_core_Time_mid_max
#define Time_SetSystemTime_req_arena_size kl_core_Time_SetSystemTime_req_arena_size
#define Time_SetSystemTime_res_arena_size kl_core_Time_SetSystemTime_res_arena_size
#define Time_SetSystemTime_req_handles kl_core_Time_SetSystemTime_req_handles
#define Time_SetSystemTime_res_handles kl_core_Time_SetSystemTime_res_handles
#define Time_SetSystemTime_err_handles kl_core_Time_SetSystemTime_err_handles
#define Time_SetSystemTimeAdj_req_arena_size kl_core_Time_SetSystemTimeAdj_req_arena_size
#define Time_SetSystemTimeAdj_res_arena_size kl_core_Time_SetSystemTimeAdj_res_arena_size
#define Time_SetSystemTimeAdj_req_handles kl_core_Time_SetSystemTimeAdj_req_handles
#define Time_SetSystemTimeAdj_res_handles kl_core_Time_SetSystemTimeAdj_res_handles
#define Time_SetSystemTimeAdj_err_handles kl_core_Time_SetSystemTimeAdj_err_handles
#define Time_GetSystemTimeAdj_req_arena_size kl_core_Time_GetSystemTimeAdj_req_arena_size
#define Time_GetSystemTimeAdj_res_arena_size kl_core_Time_GetSystemTimeAdj_res_arena_size
#define Time_GetSystemTimeAdj_req_handles kl_core_Time_GetSystemTimeAdj_req_handles
#define Time_GetSystemTimeAdj_res_handles kl_core_Time_GetSystemTimeAdj_res_handles
#define Time_GetSystemTimeAdj_err_handles kl_core_Time_GetSystemTimeAdj_err_handles
#define Time_req_arena_size kl_core_Time_req_arena_size
#define Time_res_arena_size kl_core_Time_res_arena_size
#define Time_req_handles kl_core_Time_req_handles
#define Time_res_handles kl_core_Time_res_handles
#define Time_err_handles kl_core_Time_err_handles
#define Time_SetSystemTime_req kl_core_Time_SetSystemTime_req
#define Time_SetSystemTime_res kl_core_Time_SetSystemTime_res
#define Time_SetSystemTimeAdj_req kl_core_Time_SetSystemTimeAdj_req
#define Time_SetSystemTimeAdj_res kl_core_Time_SetSystemTimeAdj_res
#define Time_GetSystemTimeAdj_req kl_core_Time_GetSystemTimeAdj_req
#define Time_GetSystemTimeAdj_res kl_core_Time_GetSystemTimeAdj_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Time__INTERFACE__ */

#ifndef __kl_core__VMM__INTERFACE__
#define __kl_core__VMM__INTERFACE__
enum {
    kl_core_VMM_Allocate_mid,
    kl_core_VMM_Commit_mid,
    kl_core_VMM_Decommit_mid,
    kl_core_VMM_Protect_mid,
    kl_core_VMM_Free_mid,
    kl_core_VMM_Query_mid,
    kl_core_VMM_Reset_mid,
    kl_core_VMM_MdlCreate_mid,
    kl_core_VMM_MdlCreateFromVm_mid,
    kl_core_VMM_MdlGetSize_mid,
    kl_core_VMM_MdlMap_mid,
    kl_core_VMM_MdlClone_mid,
    kl_core_VMM_mid_max,
};
enum {
    kl_core_VMM_Allocate_req_arena_size = 0,
    kl_core_VMM_Allocate_res_arena_size = 0,
    kl_core_VMM_Allocate_req_handles = 0,
    kl_core_VMM_Allocate_res_handles = 0,
    kl_core_VMM_Allocate_err_handles = 0,
    kl_core_VMM_Commit_req_arena_size = 0,
    kl_core_VMM_Commit_res_arena_size = 0,
    kl_core_VMM_Commit_req_handles = 0,
    kl_core_VMM_Commit_res_handles = 0,
    kl_core_VMM_Commit_err_handles = 0,
    kl_core_VMM_Decommit_req_arena_size = 0,
    kl_core_VMM_Decommit_res_arena_size = 0,
    kl_core_VMM_Decommit_req_handles = 0,
    kl_core_VMM_Decommit_res_handles = 0,
    kl_core_VMM_Decommit_err_handles = 0,
    kl_core_VMM_Protect_req_arena_size = 0,
    kl_core_VMM_Protect_res_arena_size = 0,
    kl_core_VMM_Protect_req_handles = 0,
    kl_core_VMM_Protect_res_handles = 0,
    kl_core_VMM_Protect_err_handles = 0,
    kl_core_VMM_Free_req_arena_size = 0,
    kl_core_VMM_Free_res_arena_size = 0,
    kl_core_VMM_Free_req_handles = 0,
    kl_core_VMM_Free_res_handles = 0,
    kl_core_VMM_Free_err_handles = 0,
    kl_core_VMM_Query_res_info_size = 128,
    kl_core_VMM_Query_req_arena_size = 0,
    kl_core_VMM_Query_res_arena_size = 128,
    kl_core_VMM_Query_req_handles = 0,
    kl_core_VMM_Query_res_handles = 0,
    kl_core_VMM_Query_err_handles = 0,
    kl_core_VMM_Reset_req_arena_size = 0,
    kl_core_VMM_Reset_res_arena_size = 0,
    kl_core_VMM_Reset_req_handles = 0,
    kl_core_VMM_Reset_res_handles = 0,
    kl_core_VMM_Reset_err_handles = 0,
    kl_core_VMM_MdlCreate_req_arena_size = 0,
    kl_core_VMM_MdlCreate_res_arena_size = 0,
    kl_core_VMM_MdlCreate_req_handles = 0,
    kl_core_VMM_MdlCreate_res_handles = 1,
    kl_core_VMM_MdlCreate_err_handles = 0,
    kl_core_VMM_MdlCreateFromVm_req_arena_size =
    0,
    kl_core_VMM_MdlCreateFromVm_res_arena_size =
    0,
    kl_core_VMM_MdlCreateFromVm_req_handles = 0,
    kl_core_VMM_MdlCreateFromVm_res_handles = 1,
    kl_core_VMM_MdlCreateFromVm_err_handles = 0,
    kl_core_VMM_MdlGetSize_req_arena_size = 0,
    kl_core_VMM_MdlGetSize_res_arena_size = 0,
    kl_core_VMM_MdlGetSize_req_handles = 1,
    kl_core_VMM_MdlGetSize_res_handles = 0,
    kl_core_VMM_MdlGetSize_err_handles = 0,
    kl_core_VMM_MdlMap_req_arena_size = 0,
    kl_core_VMM_MdlMap_res_arena_size = 0,
    kl_core_VMM_MdlMap_req_handles = 1,
    kl_core_VMM_MdlMap_res_handles = 0,
    kl_core_VMM_MdlMap_err_handles = 0,
    kl_core_VMM_MdlClone_req_arena_size = 0,
    kl_core_VMM_MdlClone_res_arena_size = 0,
    kl_core_VMM_MdlClone_req_handles = 1,
    kl_core_VMM_MdlClone_res_handles = 1,
    kl_core_VMM_MdlClone_err_handles = 0,
    kl_core_VMM_req_arena_size = 0,
    kl_core_VMM_res_arena_size = 128,
    kl_core_VMM_req_handles = 1,
    kl_core_VMM_res_handles = 1,
    kl_core_VMM_err_handles = 0,
};
typedef struct __nk_packed kl_core_VMM_Allocate_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t addr;
            __nk_alignas(8) nk_uint64_t size;
            __nk_alignas(4) nk_uint32_t flags;
        } kl_core_VMM_Allocate_req;
nk_static_assert(sizeof(kl_core_VMM_Allocate_req) == 48, bad_kl_core_VMM_Allocate_req_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Allocate_req, base_) == 0, bad_kl_core_VMM_Allocate_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Allocate_req, addr) == 24, bad_kl_core_VMM_Allocate_req_addr_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Allocate_req, size) == 32, bad_kl_core_VMM_Allocate_req_size_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Allocate_req, flags) == 40, bad_kl_core_VMM_Allocate_req_flags_offset);
#pragma pack(push, 8) /* kl_core_VMM_Allocate_res */
typedef struct kl_core_VMM_Allocate_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_VMM_Allocate_err;
nk_static_assert(sizeof(kl_core_VMM_Allocate_err) == 24, bad_kl_core_VMM_Allocate_err_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Allocate_err, base_) == 0, bad_kl_core_VMM_Allocate_err_base__offset);
typedef struct kl_core_VMM_Allocate_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t va;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t va;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_VMM_Allocate_err err_;
            };
        } kl_core_VMM_Allocate_res;
nk_static_assert(sizeof(kl_core_VMM_Allocate_res) == 40, bad_kl_core_VMM_Allocate_res_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Allocate_res, base_) == 0, bad_kl_core_VMM_Allocate_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Allocate_res, va) == 24, bad_kl_core_VMM_Allocate_res_va_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Allocate_res, rc) == 32, bad_kl_core_VMM_Allocate_res_rc_offset);
#pragma pack(pop) /* kl_core_VMM_Allocate_res */
typedef struct __nk_packed kl_core_VMM_Commit_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t va;
            __nk_alignas(8) nk_uint64_t size;
        } kl_core_VMM_Commit_req;
nk_static_assert(sizeof(kl_core_VMM_Commit_req) == 40, bad_kl_core_VMM_Commit_req_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Commit_req, base_) == 0, bad_kl_core_VMM_Commit_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Commit_req, va) == 24, bad_kl_core_VMM_Commit_req_va_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Commit_req, size) == 32, bad_kl_core_VMM_Commit_req_size_offset);
#pragma pack(push, 8) /* kl_core_VMM_Commit_res */
typedef struct kl_core_VMM_Commit_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_VMM_Commit_err;
nk_static_assert(sizeof(kl_core_VMM_Commit_err) == 24, bad_kl_core_VMM_Commit_err_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Commit_err, base_) == 0, bad_kl_core_VMM_Commit_err_base__offset);
typedef struct kl_core_VMM_Commit_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_VMM_Commit_err err_;
            };
        } kl_core_VMM_Commit_res;
nk_static_assert(sizeof(kl_core_VMM_Commit_res) == 32, bad_kl_core_VMM_Commit_res_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Commit_res, base_) == 0, bad_kl_core_VMM_Commit_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Commit_res, rc) == 24, bad_kl_core_VMM_Commit_res_rc_offset);
#pragma pack(pop) /* kl_core_VMM_Commit_res */
typedef struct __nk_packed kl_core_VMM_Decommit_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t va;
            __nk_alignas(8) nk_uint64_t size;
        } kl_core_VMM_Decommit_req;
nk_static_assert(sizeof(kl_core_VMM_Decommit_req) == 40, bad_kl_core_VMM_Decommit_req_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Decommit_req, base_) == 0, bad_kl_core_VMM_Decommit_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Decommit_req, va) == 24, bad_kl_core_VMM_Decommit_req_va_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Decommit_req, size) == 32, bad_kl_core_VMM_Decommit_req_size_offset);
#pragma pack(push, 8) /* kl_core_VMM_Decommit_res */
typedef struct kl_core_VMM_Decommit_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_VMM_Decommit_err;
nk_static_assert(sizeof(kl_core_VMM_Decommit_err) == 24, bad_kl_core_VMM_Decommit_err_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Decommit_err, base_) == 0, bad_kl_core_VMM_Decommit_err_base__offset);
typedef struct kl_core_VMM_Decommit_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_VMM_Decommit_err err_;
            };
        } kl_core_VMM_Decommit_res;
nk_static_assert(sizeof(kl_core_VMM_Decommit_res) == 32, bad_kl_core_VMM_Decommit_res_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Decommit_res, base_) == 0, bad_kl_core_VMM_Decommit_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Decommit_res, rc) == 24, bad_kl_core_VMM_Decommit_res_rc_offset);
#pragma pack(pop) /* kl_core_VMM_Decommit_res */
typedef struct __nk_packed kl_core_VMM_Protect_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t va;
            __nk_alignas(8) nk_uint64_t size;
            __nk_alignas(4) nk_uint32_t flags;
        } kl_core_VMM_Protect_req;
nk_static_assert(sizeof(kl_core_VMM_Protect_req) == 48, bad_kl_core_VMM_Protect_req_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Protect_req, base_) == 0, bad_kl_core_VMM_Protect_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Protect_req, va) == 24, bad_kl_core_VMM_Protect_req_va_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Protect_req, size) == 32, bad_kl_core_VMM_Protect_req_size_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Protect_req, flags) == 40, bad_kl_core_VMM_Protect_req_flags_offset);
#pragma pack(push, 8) /* kl_core_VMM_Protect_res */
typedef struct kl_core_VMM_Protect_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_VMM_Protect_err;
nk_static_assert(sizeof(kl_core_VMM_Protect_err) == 24, bad_kl_core_VMM_Protect_err_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Protect_err, base_) == 0, bad_kl_core_VMM_Protect_err_base__offset);
typedef struct kl_core_VMM_Protect_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_VMM_Protect_err err_;
            };
        } kl_core_VMM_Protect_res;
nk_static_assert(sizeof(kl_core_VMM_Protect_res) == 32, bad_kl_core_VMM_Protect_res_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Protect_res, base_) == 0, bad_kl_core_VMM_Protect_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Protect_res, rc) == 24, bad_kl_core_VMM_Protect_res_rc_offset);
#pragma pack(pop) /* kl_core_VMM_Protect_res */
typedef struct __nk_packed kl_core_VMM_Free_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t va;
            __nk_alignas(8) nk_uint64_t size;
        } kl_core_VMM_Free_req;
nk_static_assert(sizeof(kl_core_VMM_Free_req) == 40, bad_kl_core_VMM_Free_req_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Free_req, base_) == 0, bad_kl_core_VMM_Free_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Free_req, va) == 24, bad_kl_core_VMM_Free_req_va_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Free_req, size) == 32, bad_kl_core_VMM_Free_req_size_offset);
#pragma pack(push, 8) /* kl_core_VMM_Free_res */
typedef struct kl_core_VMM_Free_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_VMM_Free_err;
nk_static_assert(sizeof(kl_core_VMM_Free_err) == 24, bad_kl_core_VMM_Free_err_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Free_err, base_) == 0, bad_kl_core_VMM_Free_err_base__offset);
typedef struct kl_core_VMM_Free_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_VMM_Free_err err_;
            };
        } kl_core_VMM_Free_res;
nk_static_assert(sizeof(kl_core_VMM_Free_res) == 32, bad_kl_core_VMM_Free_res_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Free_res, base_) == 0, bad_kl_core_VMM_Free_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Free_res, rc) == 24, bad_kl_core_VMM_Free_res_rc_offset);
#pragma pack(pop) /* kl_core_VMM_Free_res */
typedef struct __nk_packed kl_core_VMM_Query_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t addr;
        } kl_core_VMM_Query_req;
nk_static_assert(sizeof(kl_core_VMM_Query_req) == 32, bad_kl_core_VMM_Query_req_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Query_req, base_) == 0, bad_kl_core_VMM_Query_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Query_req, addr) == 24, bad_kl_core_VMM_Query_req_addr_offset);
#pragma pack(push, 8) /* kl_core_VMM_Query_res */
typedef struct kl_core_VMM_Query_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_VMM_Query_err;
nk_static_assert(sizeof(kl_core_VMM_Query_err) == 24, bad_kl_core_VMM_Query_err_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Query_err, base_) == 0, bad_kl_core_VMM_Query_err_base__offset);
typedef struct kl_core_VMM_Query_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t info;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4) nk_ptr_t info;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_VMM_Query_err err_;
            };
        } kl_core_VMM_Query_res;
nk_static_assert(sizeof(kl_core_VMM_Query_res) == 40, bad_kl_core_VMM_Query_res_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Query_res, base_) == 0, bad_kl_core_VMM_Query_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Query_res, info) == 24, bad_kl_core_VMM_Query_res_info_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Query_res, rc) == 32, bad_kl_core_VMM_Query_res_rc_offset);
#pragma pack(pop) /* kl_core_VMM_Query_res */
typedef struct __nk_packed kl_core_VMM_Reset_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t va;
            __nk_alignas(8) nk_uint64_t size;
        } kl_core_VMM_Reset_req;
nk_static_assert(sizeof(kl_core_VMM_Reset_req) == 40, bad_kl_core_VMM_Reset_req_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Reset_req, base_) == 0, bad_kl_core_VMM_Reset_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Reset_req, va) == 24, bad_kl_core_VMM_Reset_req_va_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Reset_req, size) == 32, bad_kl_core_VMM_Reset_req_size_offset);
#pragma pack(push, 8) /* kl_core_VMM_Reset_res */
typedef struct kl_core_VMM_Reset_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_VMM_Reset_err;
nk_static_assert(sizeof(kl_core_VMM_Reset_err) == 24, bad_kl_core_VMM_Reset_err_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Reset_err, base_) == 0, bad_kl_core_VMM_Reset_err_base__offset);
typedef struct kl_core_VMM_Reset_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_VMM_Reset_err err_;
            };
        } kl_core_VMM_Reset_res;
nk_static_assert(sizeof(kl_core_VMM_Reset_res) == 32, bad_kl_core_VMM_Reset_res_size);
nk_static_assert(nk_offsetof(kl_core_VMM_Reset_res, base_) == 0, bad_kl_core_VMM_Reset_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_Reset_res, rc) == 24, bad_kl_core_VMM_Reset_res_rc_offset);
#pragma pack(pop) /* kl_core_VMM_Reset_res */
typedef struct __nk_packed kl_core_VMM_MdlCreate_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t size;
            __nk_alignas(4) nk_uint32_t prot;
        } kl_core_VMM_MdlCreate_req;
nk_static_assert(sizeof(kl_core_VMM_MdlCreate_req) == 40, bad_kl_core_VMM_MdlCreate_req_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreate_req, base_) == 0, bad_kl_core_VMM_MdlCreate_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreate_req, size) == 24, bad_kl_core_VMM_MdlCreate_req_size_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreate_req, prot) == 32, bad_kl_core_VMM_MdlCreate_req_prot_offset);
#pragma pack(push, 8) /* kl_core_VMM_MdlCreate_res */
typedef struct kl_core_VMM_MdlCreate_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_VMM_MdlCreate_err;
nk_static_assert(sizeof(kl_core_VMM_MdlCreate_err) == 24, bad_kl_core_VMM_MdlCreate_err_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreate_err, base_) == 0, bad_kl_core_VMM_MdlCreate_err_base__offset);
typedef struct kl_core_VMM_MdlCreate_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_VMM_MdlCreate_err err_;
            };
        } kl_core_VMM_MdlCreate_res;
nk_static_assert(sizeof(kl_core_VMM_MdlCreate_res) == 48, bad_kl_core_VMM_MdlCreate_res_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreate_res, base_) == 0, bad_kl_core_VMM_MdlCreate_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreate_res, handle) == 24, bad_kl_core_VMM_MdlCreate_res_handle_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreate_res, rc) == 40, bad_kl_core_VMM_MdlCreate_res_rc_offset);
#pragma pack(pop) /* kl_core_VMM_MdlCreate_res */
typedef struct __nk_packed kl_core_VMM_MdlCreateFromVm_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(8) nk_uint64_t va;
            __nk_alignas(8) nk_uint64_t size;
            __nk_alignas(4) nk_uint32_t flags;
        } kl_core_VMM_MdlCreateFromVm_req;
nk_static_assert(sizeof(kl_core_VMM_MdlCreateFromVm_req) == 48, bad_kl_core_VMM_MdlCreateFromVm_req_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreateFromVm_req, base_) == 0, bad_kl_core_VMM_MdlCreateFromVm_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreateFromVm_req, va) == 24, bad_kl_core_VMM_MdlCreateFromVm_req_va_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreateFromVm_req, size) == 32, bad_kl_core_VMM_MdlCreateFromVm_req_size_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreateFromVm_req, flags) == 40, bad_kl_core_VMM_MdlCreateFromVm_req_flags_offset);
#pragma pack(push, 8) /* kl_core_VMM_MdlCreateFromVm_res */
typedef struct kl_core_VMM_MdlCreateFromVm_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_VMM_MdlCreateFromVm_err;
nk_static_assert(sizeof(kl_core_VMM_MdlCreateFromVm_err) == 24, bad_kl_core_VMM_MdlCreateFromVm_err_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreateFromVm_err, base_) == 0, bad_kl_core_VMM_MdlCreateFromVm_err_base__offset);
typedef struct kl_core_VMM_MdlCreateFromVm_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_VMM_MdlCreateFromVm_err err_;
            };
        } kl_core_VMM_MdlCreateFromVm_res;
nk_static_assert(sizeof(kl_core_VMM_MdlCreateFromVm_res) == 48, bad_kl_core_VMM_MdlCreateFromVm_res_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreateFromVm_res, base_) == 0, bad_kl_core_VMM_MdlCreateFromVm_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreateFromVm_res, handle) == 24, bad_kl_core_VMM_MdlCreateFromVm_res_handle_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlCreateFromVm_res, rc) == 40, bad_kl_core_VMM_MdlCreateFromVm_res_rc_offset);
#pragma pack(pop) /* kl_core_VMM_MdlCreateFromVm_res */
typedef struct __nk_packed kl_core_VMM_MdlGetSize_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
        } kl_core_VMM_MdlGetSize_req;
nk_static_assert(sizeof(kl_core_VMM_MdlGetSize_req) == 40, bad_kl_core_VMM_MdlGetSize_req_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlGetSize_req, base_) == 0, bad_kl_core_VMM_MdlGetSize_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlGetSize_req, handle) == 24, bad_kl_core_VMM_MdlGetSize_req_handle_offset);
#pragma pack(push, 8) /* kl_core_VMM_MdlGetSize_res */
typedef struct kl_core_VMM_MdlGetSize_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_VMM_MdlGetSize_err;
nk_static_assert(sizeof(kl_core_VMM_MdlGetSize_err) == 24, bad_kl_core_VMM_MdlGetSize_err_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlGetSize_err, base_) == 0, bad_kl_core_VMM_MdlGetSize_err_base__offset);
typedef struct kl_core_VMM_MdlGetSize_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t size;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t size;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_VMM_MdlGetSize_err err_;
            };
        } kl_core_VMM_MdlGetSize_res;
nk_static_assert(sizeof(kl_core_VMM_MdlGetSize_res) == 40, bad_kl_core_VMM_MdlGetSize_res_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlGetSize_res, base_) == 0, bad_kl_core_VMM_MdlGetSize_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlGetSize_res, size) == 24, bad_kl_core_VMM_MdlGetSize_res_size_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlGetSize_res, rc) == 32, bad_kl_core_VMM_MdlGetSize_res_rc_offset);
#pragma pack(pop) /* kl_core_VMM_MdlGetSize_res */
typedef struct __nk_packed kl_core_VMM_MdlMap_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t handle;
            __nk_alignas(8) nk_uint64_t offset;
            __nk_alignas(8) nk_uint64_t length;
            __nk_alignas(8) nk_uint64_t hint;
            __nk_alignas(4) nk_uint32_t prot;
        } kl_core_VMM_MdlMap_req;
nk_static_assert(sizeof(kl_core_VMM_MdlMap_req) == 72, bad_kl_core_VMM_MdlMap_req_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlMap_req, base_) == 0, bad_kl_core_VMM_MdlMap_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlMap_req, handle) == 24, bad_kl_core_VMM_MdlMap_req_handle_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlMap_req, offset) == 40, bad_kl_core_VMM_MdlMap_req_offset_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlMap_req, length) == 48, bad_kl_core_VMM_MdlMap_req_length_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlMap_req, hint) == 56, bad_kl_core_VMM_MdlMap_req_hint_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlMap_req, prot) == 64, bad_kl_core_VMM_MdlMap_req_prot_offset);
#pragma pack(push, 8) /* kl_core_VMM_MdlMap_res */
typedef struct kl_core_VMM_MdlMap_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_VMM_MdlMap_err;
nk_static_assert(sizeof(kl_core_VMM_MdlMap_err) == 24, bad_kl_core_VMM_MdlMap_err_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlMap_err, base_) == 0, bad_kl_core_VMM_MdlMap_err_base__offset);
typedef struct kl_core_VMM_MdlMap_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t address;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(8)
                    nk_uint64_t address;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_VMM_MdlMap_err err_;
            };
        } kl_core_VMM_MdlMap_res;
nk_static_assert(sizeof(kl_core_VMM_MdlMap_res) == 40, bad_kl_core_VMM_MdlMap_res_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlMap_res, base_) == 0, bad_kl_core_VMM_MdlMap_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlMap_res, address) == 24, bad_kl_core_VMM_MdlMap_res_address_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlMap_res, rc) == 32, bad_kl_core_VMM_MdlMap_res_rc_offset);
#pragma pack(pop) /* kl_core_VMM_MdlMap_res */
typedef struct __nk_packed kl_core_VMM_MdlClone_req {
            __nk_alignas(8)
            struct nk_message base_;
            __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t originHandle;
            __nk_alignas(8) nk_uint64_t offset;
            __nk_alignas(8) nk_uint64_t length;
        } kl_core_VMM_MdlClone_req;
nk_static_assert(sizeof(kl_core_VMM_MdlClone_req) == 56, bad_kl_core_VMM_MdlClone_req_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlClone_req, base_) == 0, bad_kl_core_VMM_MdlClone_req_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlClone_req, originHandle) == 24, bad_kl_core_VMM_MdlClone_req_originHandle_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlClone_req, offset) == 40, bad_kl_core_VMM_MdlClone_req_offset_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlClone_req, length) == 48, bad_kl_core_VMM_MdlClone_req_length_offset);
#pragma pack(push, 8) /* kl_core_VMM_MdlClone_res */
typedef struct kl_core_VMM_MdlClone_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_VMM_MdlClone_err;
nk_static_assert(sizeof(kl_core_VMM_MdlClone_err) == 24, bad_kl_core_VMM_MdlClone_err_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlClone_err, base_) == 0, bad_kl_core_VMM_MdlClone_err_base__offset);
typedef struct kl_core_VMM_MdlClone_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t cloneHandle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(nk_alignof(nk_handle_desc_t)) nk_handle_desc_t cloneHandle;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_VMM_MdlClone_err err_;
            };
        } kl_core_VMM_MdlClone_res;
nk_static_assert(sizeof(kl_core_VMM_MdlClone_res) == 48, bad_kl_core_VMM_MdlClone_res_size);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlClone_res, base_) == 0, bad_kl_core_VMM_MdlClone_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlClone_res, cloneHandle) == 24, bad_kl_core_VMM_MdlClone_res_cloneHandle_offset);
nk_static_assert(nk_offsetof(kl_core_VMM_MdlClone_res, rc) == 40, bad_kl_core_VMM_MdlClone_res_rc_offset);
#pragma pack(pop) /* kl_core_VMM_MdlClone_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define VMM_Allocate_mid kl_core_VMM_Allocate_mid
#define VMM_Commit_mid kl_core_VMM_Commit_mid
#define VMM_Decommit_mid kl_core_VMM_Decommit_mid
#define VMM_Protect_mid kl_core_VMM_Protect_mid
#define VMM_Free_mid kl_core_VMM_Free_mid
#define VMM_Query_mid kl_core_VMM_Query_mid
#define VMM_Reset_mid kl_core_VMM_Reset_mid
#define VMM_MdlCreate_mid kl_core_VMM_MdlCreate_mid
#define VMM_MdlCreateFromVm_mid kl_core_VMM_MdlCreateFromVm_mid
#define VMM_MdlGetSize_mid kl_core_VMM_MdlGetSize_mid
#define VMM_MdlMap_mid kl_core_VMM_MdlMap_mid
#define VMM_MdlClone_mid kl_core_VMM_MdlClone_mid
#define VMM_mid_max kl_core_VMM_mid_max
#define VMM_Allocate_req_arena_size kl_core_VMM_Allocate_req_arena_size
#define VMM_Allocate_res_arena_size kl_core_VMM_Allocate_res_arena_size
#define VMM_Allocate_req_handles kl_core_VMM_Allocate_req_handles
#define VMM_Allocate_res_handles kl_core_VMM_Allocate_res_handles
#define VMM_Allocate_err_handles kl_core_VMM_Allocate_err_handles
#define VMM_Commit_req_arena_size kl_core_VMM_Commit_req_arena_size
#define VMM_Commit_res_arena_size kl_core_VMM_Commit_res_arena_size
#define VMM_Commit_req_handles kl_core_VMM_Commit_req_handles
#define VMM_Commit_res_handles kl_core_VMM_Commit_res_handles
#define VMM_Commit_err_handles kl_core_VMM_Commit_err_handles
#define VMM_Decommit_req_arena_size kl_core_VMM_Decommit_req_arena_size
#define VMM_Decommit_res_arena_size kl_core_VMM_Decommit_res_arena_size
#define VMM_Decommit_req_handles kl_core_VMM_Decommit_req_handles
#define VMM_Decommit_res_handles kl_core_VMM_Decommit_res_handles
#define VMM_Decommit_err_handles kl_core_VMM_Decommit_err_handles
#define VMM_Protect_req_arena_size kl_core_VMM_Protect_req_arena_size
#define VMM_Protect_res_arena_size kl_core_VMM_Protect_res_arena_size
#define VMM_Protect_req_handles kl_core_VMM_Protect_req_handles
#define VMM_Protect_res_handles kl_core_VMM_Protect_res_handles
#define VMM_Protect_err_handles kl_core_VMM_Protect_err_handles
#define VMM_Free_req_arena_size kl_core_VMM_Free_req_arena_size
#define VMM_Free_res_arena_size kl_core_VMM_Free_res_arena_size
#define VMM_Free_req_handles kl_core_VMM_Free_req_handles
#define VMM_Free_res_handles kl_core_VMM_Free_res_handles
#define VMM_Free_err_handles kl_core_VMM_Free_err_handles
#define VMM_Query_res_info_size kl_core_VMM_Query_res_info_size
#define VMM_Query_req_arena_size kl_core_VMM_Query_req_arena_size
#define VMM_Query_res_arena_size kl_core_VMM_Query_res_arena_size
#define VMM_Query_req_handles kl_core_VMM_Query_req_handles
#define VMM_Query_res_handles kl_core_VMM_Query_res_handles
#define VMM_Query_err_handles kl_core_VMM_Query_err_handles
#define VMM_Reset_req_arena_size kl_core_VMM_Reset_req_arena_size
#define VMM_Reset_res_arena_size kl_core_VMM_Reset_res_arena_size
#define VMM_Reset_req_handles kl_core_VMM_Reset_req_handles
#define VMM_Reset_res_handles kl_core_VMM_Reset_res_handles
#define VMM_Reset_err_handles kl_core_VMM_Reset_err_handles
#define VMM_MdlCreate_req_arena_size kl_core_VMM_MdlCreate_req_arena_size
#define VMM_MdlCreate_res_arena_size kl_core_VMM_MdlCreate_res_arena_size
#define VMM_MdlCreate_req_handles kl_core_VMM_MdlCreate_req_handles
#define VMM_MdlCreate_res_handles kl_core_VMM_MdlCreate_res_handles
#define VMM_MdlCreate_err_handles kl_core_VMM_MdlCreate_err_handles
#define VMM_MdlCreateFromVm_req_arena_size kl_core_VMM_MdlCreateFromVm_req_arena_size
#define VMM_MdlCreateFromVm_res_arena_size kl_core_VMM_MdlCreateFromVm_res_arena_size
#define VMM_MdlCreateFromVm_req_handles kl_core_VMM_MdlCreateFromVm_req_handles
#define VMM_MdlCreateFromVm_res_handles kl_core_VMM_MdlCreateFromVm_res_handles
#define VMM_MdlCreateFromVm_err_handles kl_core_VMM_MdlCreateFromVm_err_handles
#define VMM_MdlGetSize_req_arena_size kl_core_VMM_MdlGetSize_req_arena_size
#define VMM_MdlGetSize_res_arena_size kl_core_VMM_MdlGetSize_res_arena_size
#define VMM_MdlGetSize_req_handles kl_core_VMM_MdlGetSize_req_handles
#define VMM_MdlGetSize_res_handles kl_core_VMM_MdlGetSize_res_handles
#define VMM_MdlGetSize_err_handles kl_core_VMM_MdlGetSize_err_handles
#define VMM_MdlMap_req_arena_size kl_core_VMM_MdlMap_req_arena_size
#define VMM_MdlMap_res_arena_size kl_core_VMM_MdlMap_res_arena_size
#define VMM_MdlMap_req_handles kl_core_VMM_MdlMap_req_handles
#define VMM_MdlMap_res_handles kl_core_VMM_MdlMap_res_handles
#define VMM_MdlMap_err_handles kl_core_VMM_MdlMap_err_handles
#define VMM_MdlClone_req_arena_size kl_core_VMM_MdlClone_req_arena_size
#define VMM_MdlClone_res_arena_size kl_core_VMM_MdlClone_res_arena_size
#define VMM_MdlClone_req_handles kl_core_VMM_MdlClone_req_handles
#define VMM_MdlClone_res_handles kl_core_VMM_MdlClone_res_handles
#define VMM_MdlClone_err_handles kl_core_VMM_MdlClone_err_handles
#define VMM_req_arena_size kl_core_VMM_req_arena_size
#define VMM_res_arena_size kl_core_VMM_res_arena_size
#define VMM_req_handles kl_core_VMM_req_handles
#define VMM_res_handles kl_core_VMM_res_handles
#define VMM_err_handles kl_core_VMM_err_handles
#define VMM_Allocate_req kl_core_VMM_Allocate_req
#define VMM_Allocate_res kl_core_VMM_Allocate_res
#define VMM_Commit_req kl_core_VMM_Commit_req
#define VMM_Commit_res kl_core_VMM_Commit_res
#define VMM_Decommit_req kl_core_VMM_Decommit_req
#define VMM_Decommit_res kl_core_VMM_Decommit_res
#define VMM_Protect_req kl_core_VMM_Protect_req
#define VMM_Protect_res kl_core_VMM_Protect_res
#define VMM_Free_req kl_core_VMM_Free_req
#define VMM_Free_res kl_core_VMM_Free_res
#define VMM_Query_req kl_core_VMM_Query_req
#define VMM_Query_res kl_core_VMM_Query_res
#define VMM_Reset_req kl_core_VMM_Reset_req
#define VMM_Reset_res kl_core_VMM_Reset_res
#define VMM_MdlCreate_req kl_core_VMM_MdlCreate_req
#define VMM_MdlCreate_res kl_core_VMM_MdlCreate_res
#define VMM_MdlCreateFromVm_req kl_core_VMM_MdlCreateFromVm_req
#define VMM_MdlCreateFromVm_res kl_core_VMM_MdlCreateFromVm_res
#define VMM_MdlGetSize_req kl_core_VMM_MdlGetSize_req
#define VMM_MdlGetSize_res kl_core_VMM_MdlGetSize_res
#define VMM_MdlMap_req kl_core_VMM_MdlMap_req
#define VMM_MdlMap_res kl_core_VMM_MdlMap_res
#define VMM_MdlClone_req kl_core_VMM_MdlClone_req
#define VMM_MdlClone_res kl_core_VMM_MdlClone_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__VMM__INTERFACE__ */

#ifndef __kl_core__XHCIDBG__INTERFACE__
#define __kl_core__XHCIDBG__INTERFACE__
enum {
    kl_core_XHCIDBG_Start_mid,
    kl_core_XHCIDBG_Stop_mid,
    kl_core_XHCIDBG_mid_max,
};
enum {
    kl_core_XHCIDBG_Start_req_arena_size = 0,
    kl_core_XHCIDBG_Start_res_arena_size = 0,
    kl_core_XHCIDBG_Start_req_handles = 0,
    kl_core_XHCIDBG_Start_res_handles = 0,
    kl_core_XHCIDBG_Start_err_handles = 0,
    kl_core_XHCIDBG_Stop_req_arena_size = 0,
    kl_core_XHCIDBG_Stop_res_arena_size = 0,
    kl_core_XHCIDBG_Stop_req_handles = 0,
    kl_core_XHCIDBG_Stop_res_handles = 0,
    kl_core_XHCIDBG_Stop_err_handles = 0,
    kl_core_XHCIDBG_req_arena_size = 0,
    kl_core_XHCIDBG_res_arena_size = 0,
    kl_core_XHCIDBG_req_handles = 0,
    kl_core_XHCIDBG_res_handles = 0,
    kl_core_XHCIDBG_err_handles = 0,
};
typedef struct __nk_packed kl_core_XHCIDBG_Start_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_XHCIDBG_Start_req;
nk_static_assert(sizeof(kl_core_XHCIDBG_Start_req) == 24, bad_kl_core_XHCIDBG_Start_req_size);
nk_static_assert(nk_offsetof(kl_core_XHCIDBG_Start_req, base_) == 0, bad_kl_core_XHCIDBG_Start_req_base__offset);
#pragma pack(push, 8) /* kl_core_XHCIDBG_Start_res */
typedef struct kl_core_XHCIDBG_Start_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_XHCIDBG_Start_err;
nk_static_assert(sizeof(kl_core_XHCIDBG_Start_err) == 24, bad_kl_core_XHCIDBG_Start_err_size);
nk_static_assert(nk_offsetof(kl_core_XHCIDBG_Start_err, base_) == 0, bad_kl_core_XHCIDBG_Start_err_base__offset);
typedef struct kl_core_XHCIDBG_Start_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_XHCIDBG_Start_err err_;
            };
        } kl_core_XHCIDBG_Start_res;
nk_static_assert(sizeof(kl_core_XHCIDBG_Start_res) == 32, bad_kl_core_XHCIDBG_Start_res_size);
nk_static_assert(nk_offsetof(kl_core_XHCIDBG_Start_res, base_) == 0, bad_kl_core_XHCIDBG_Start_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_XHCIDBG_Start_res, rc) == 24, bad_kl_core_XHCIDBG_Start_res_rc_offset);
#pragma pack(pop) /* kl_core_XHCIDBG_Start_res */
typedef struct __nk_packed kl_core_XHCIDBG_Stop_req {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_XHCIDBG_Stop_req;
nk_static_assert(sizeof(kl_core_XHCIDBG_Stop_req) == 24, bad_kl_core_XHCIDBG_Stop_req_size);
nk_static_assert(nk_offsetof(kl_core_XHCIDBG_Stop_req, base_) == 0, bad_kl_core_XHCIDBG_Stop_req_base__offset);
#pragma pack(push, 8) /* kl_core_XHCIDBG_Stop_res */
typedef struct kl_core_XHCIDBG_Stop_err {
            __nk_alignas(8)
            struct nk_message base_;
        } kl_core_XHCIDBG_Stop_err;
nk_static_assert(sizeof(kl_core_XHCIDBG_Stop_err) == 24, bad_kl_core_XHCIDBG_Stop_err_size);
nk_static_assert(nk_offsetof(kl_core_XHCIDBG_Stop_err, base_) == 0, bad_kl_core_XHCIDBG_Stop_err_base__offset);
typedef struct kl_core_XHCIDBG_Stop_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                    __nk_alignas(4)
                    nk_sint32_t rc;
                } res_;
                struct kl_core_XHCIDBG_Stop_err err_;
            };
        } kl_core_XHCIDBG_Stop_res;
nk_static_assert(sizeof(kl_core_XHCIDBG_Stop_res) == 32, bad_kl_core_XHCIDBG_Stop_res_size);
nk_static_assert(nk_offsetof(kl_core_XHCIDBG_Stop_res, base_) == 0, bad_kl_core_XHCIDBG_Stop_res_base__offset);
nk_static_assert(nk_offsetof(kl_core_XHCIDBG_Stop_res, rc) == 24, bad_kl_core_XHCIDBG_Stop_res_rc_offset);
#pragma pack(pop) /* kl_core_XHCIDBG_Stop_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define XHCIDBG_Start_mid kl_core_XHCIDBG_Start_mid
#define XHCIDBG_Stop_mid kl_core_XHCIDBG_Stop_mid
#define XHCIDBG_mid_max kl_core_XHCIDBG_mid_max
#define XHCIDBG_Start_req_arena_size kl_core_XHCIDBG_Start_req_arena_size
#define XHCIDBG_Start_res_arena_size kl_core_XHCIDBG_Start_res_arena_size
#define XHCIDBG_Start_req_handles kl_core_XHCIDBG_Start_req_handles
#define XHCIDBG_Start_res_handles kl_core_XHCIDBG_Start_res_handles
#define XHCIDBG_Start_err_handles kl_core_XHCIDBG_Start_err_handles
#define XHCIDBG_Stop_req_arena_size kl_core_XHCIDBG_Stop_req_arena_size
#define XHCIDBG_Stop_res_arena_size kl_core_XHCIDBG_Stop_res_arena_size
#define XHCIDBG_Stop_req_handles kl_core_XHCIDBG_Stop_req_handles
#define XHCIDBG_Stop_res_handles kl_core_XHCIDBG_Stop_res_handles
#define XHCIDBG_Stop_err_handles kl_core_XHCIDBG_Stop_err_handles
#define XHCIDBG_req_arena_size kl_core_XHCIDBG_req_arena_size
#define XHCIDBG_res_arena_size kl_core_XHCIDBG_res_arena_size
#define XHCIDBG_req_handles kl_core_XHCIDBG_req_handles
#define XHCIDBG_res_handles kl_core_XHCIDBG_res_handles
#define XHCIDBG_err_handles kl_core_XHCIDBG_err_handles
#define XHCIDBG_Start_req kl_core_XHCIDBG_Start_req
#define XHCIDBG_Start_res kl_core_XHCIDBG_Start_res
#define XHCIDBG_Stop_req kl_core_XHCIDBG_Stop_req
#define XHCIDBG_Stop_res kl_core_XHCIDBG_Stop_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__XHCIDBG__INTERFACE__ */

#ifndef __nk__Execute__INTERFACE__
#define __nk__Execute__INTERFACE__
enum {
    nk_Execute_run_mid,
    nk_Execute_mid_max,
};
enum {
    nk_Execute_run_req_arena_size = 0,
    nk_Execute_run_res_arena_size = 0,
    nk_Execute_run_req_handles = 0,
    nk_Execute_run_res_handles = 0,
    nk_Execute_run_err_handles = 0,
    nk_Execute_req_arena_size = 0,
    nk_Execute_res_arena_size = 0,
    nk_Execute_req_handles = 0,
    nk_Execute_res_handles = 0,
    nk_Execute_err_handles = 0,
};
typedef struct __nk_packed nk_Execute_run_req {
            __nk_alignas(8)
            struct nk_message base_;
        } nk_Execute_run_req;
nk_static_assert(sizeof(nk_Execute_run_req) == 24, bad_nk_Execute_run_req_size);
nk_static_assert(nk_offsetof(nk_Execute_run_req, base_) == 0, bad_nk_Execute_run_req_base__offset);
#pragma pack(push, 8) /* nk_Execute_run_res */
typedef struct nk_Execute_run_err {
            __nk_alignas(8)
            struct nk_message base_;
        } nk_Execute_run_err;
nk_static_assert(sizeof(nk_Execute_run_err) == 24, bad_nk_Execute_run_err_size);
nk_static_assert(nk_offsetof(nk_Execute_run_err, base_) == 0, bad_nk_Execute_run_err_base__offset);
typedef struct nk_Execute_run_res {
            union {
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                };
                struct {
                    __nk_alignas(8)
                    struct nk_message base_;
                } res_;
                struct nk_Execute_run_err err_;
            };
        } nk_Execute_run_res;
nk_static_assert(sizeof(nk_Execute_run_res) == 24, bad_nk_Execute_run_res_size);
nk_static_assert(nk_offsetof(nk_Execute_run_res, base_) == 0, bad_nk_Execute_run_res_base__offset);
#pragma pack(pop) /* nk_Execute_run_res */
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Execute_run_mid nk_Execute_run_mid
#define Execute_mid_max nk_Execute_mid_max
#define Execute_run_req_arena_size nk_Execute_run_req_arena_size
#define Execute_run_res_arena_size nk_Execute_run_res_arena_size
#define Execute_run_req_handles nk_Execute_run_req_handles
#define Execute_run_res_handles nk_Execute_run_res_handles
#define Execute_run_err_handles nk_Execute_run_err_handles
#define Execute_req_arena_size nk_Execute_req_arena_size
#define Execute_res_arena_size nk_Execute_res_arena_size
#define Execute_req_handles nk_Execute_req_handles
#define Execute_res_handles nk_Execute_res_handles
#define Execute_err_handles nk_Execute_err_handles
#define Execute_run_req nk_Execute_run_req
#define Execute_run_res nk_Execute_run_res
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __nk__Execute__INTERFACE__ */

#ifndef ____Einit__COMPONENT_ENDPOINTS__
#define ____Einit__COMPONENT_ENDPOINTS__
enum {
    Einit_iidMax,
};
enum {
    Einit_iidOffset = 0,
};
enum {
    Einit_securityIidMax,
};
enum {
    Einit_component_req_arena_size = 0,
    Einit_component_res_arena_size = 0,
    Einit_component_req_handles = 0,
    Einit_component_res_handles = 0,
    Einit_component_err_handles = 0,
};

#endif /* ____Einit__COMPONENT_ENDPOINTS__ */

#ifndef ____Hello__COMPONENT_ENDPOINTS__
#define ____Hello__COMPONENT_ENDPOINTS__
enum {
    Hello_iidMax,
};
enum {
    Hello_iidOffset = 0,
};
enum {
    Hello_securityIidMax,
};
enum {
    Hello_component_req_arena_size = 0,
    Hello_component_res_arena_size = 0,
    Hello_component_req_handles = 0,
    Hello_component_res_handles = 0,
    Hello_component_err_handles = 0,
};

#endif /* ____Hello__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__Audit__COMPONENT_ENDPOINTS__
#define __kl_core__Audit__COMPONENT_ENDPOINTS__
enum {
    kl_core_Audit_Audit_iid,
    kl_core_Audit_iidMax,
};
enum {
    kl_core_Audit_iidOffset = 0,
};
enum {
    kl_core_Audit_securityIidMax,
};
enum {
    kl_core_Audit_component_req_arena_size = 1024,
    kl_core_Audit_component_res_arena_size = 512,
    kl_core_Audit_component_req_handles = 1,
    kl_core_Audit_component_res_handles = 1,
    kl_core_Audit_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Audit_Audit_iid kl_core_Audit_Audit_iid
#define Audit_iidMax kl_core_Audit_iidMax
#define Audit_iidOffset kl_core_Audit_iidOffset
#define Audit_securityIidMax kl_core_Audit_securityIidMax
#define Audit_component_req_arena_size kl_core_Audit_component_req_arena_size
#define Audit_component_res_arena_size kl_core_Audit_component_res_arena_size
#define Audit_component_req_handles kl_core_Audit_component_req_handles
#define Audit_component_res_handles kl_core_Audit_component_res_handles
#define Audit_component_err_handles kl_core_Audit_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Audit__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__CM__COMPONENT_ENDPOINTS__
#define __kl_core__CM__COMPONENT_ENDPOINTS__
enum {
    kl_core_CM_CM_iid,
    kl_core_CM_iidMax,
};
enum {
    kl_core_CM_iidOffset = 0,
};
enum {
    kl_core_CM_securityIidMax,
};
enum {
    kl_core_CM_component_req_arena_size = 2048,
    kl_core_CM_component_res_arena_size = 2048,
    kl_core_CM_component_req_handles = 1,
    kl_core_CM_component_res_handles = 1,
    kl_core_CM_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define CM_CM_iid kl_core_CM_CM_iid
#define CM_iidMax kl_core_CM_iidMax
#define CM_iidOffset kl_core_CM_iidOffset
#define CM_securityIidMax kl_core_CM_securityIidMax
#define CM_component_req_arena_size kl_core_CM_component_req_arena_size
#define CM_component_res_arena_size kl_core_CM_component_res_arena_size
#define CM_component_req_handles kl_core_CM_component_req_handles
#define CM_component_res_handles kl_core_CM_component_res_handles
#define CM_component_err_handles kl_core_CM_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__CM__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__Core__COMPONENT_ENDPOINTS__
#define __kl_core__Core__COMPONENT_ENDPOINTS__
enum {
    kl_core_Core_vmm_VMM_iid,
    kl_core_Core_io_IO_iid,
    kl_core_Core_thread_Thread_iid,
    kl_core_Core_handle_Handle_iid,
    kl_core_Core_task_Task_iid,
    kl_core_Core_task_TaskDebug_iid,
    kl_core_Core_sync_Sync_iid,
    kl_core_Core_fs_FS_iid,
    kl_core_Core_fs_FSUnsafe_iid,
    kl_core_Core_time_Time_iid,
    kl_core_Core_hal_HAL_iid,
    kl_core_Core_xhcidbg_XHCIDBG_iid,
    kl_core_Core_audit_Audit_iid,
    kl_core_Core_profiler_Profiler_iid,
    kl_core_Core_iommu_IOMMU_iid,
    kl_core_Core_cm_CM_iid,
    kl_core_Core_pm_PM_iid,
    kl_core_Core_notice_Notice_iid,
    kl_core_Core_ipc_IPC_iid,
    kl_core_Core_log_Log_iid,
    kl_core_Core_efi_Efi_iid,
    kl_core_Core_iidMax,
};
enum {
    kl_core_Core_iidOffset = 0,
    kl_core_Core_vmm_iidOffset = 0,
    kl_core_Core_io_iidOffset = 1,
    kl_core_Core_thread_iidOffset = 2,
    kl_core_Core_handle_iidOffset = 3,
    kl_core_Core_task_iidOffset = 4,
    kl_core_Core_sync_iidOffset = 6,
    kl_core_Core_fs_iidOffset = 7,
    kl_core_Core_time_iidOffset = 9,
    kl_core_Core_hal_iidOffset = 10,
    kl_core_Core_xhcidbg_iidOffset = 11,
    kl_core_Core_audit_iidOffset = 12,
    kl_core_Core_profiler_iidOffset = 13,
    kl_core_Core_iommu_iidOffset = 14,
    kl_core_Core_cm_iidOffset = 15,
    kl_core_Core_pm_iidOffset = 16,
    kl_core_Core_notice_iidOffset = 17,
    kl_core_Core_ipc_iidOffset = 18,
    kl_core_Core_log_iidOffset = 19,
    kl_core_Core_efi_iidOffset = 20,
};
enum {
    kl_core_Core_securityIidMax,
};
enum {
    kl_core_Core_component_req_arena_size =
    131072,
    kl_core_Core_component_res_arena_size =
    17180000252,
    kl_core_Core_component_req_handles = 3,
    kl_core_Core_component_res_handles = 1,
    kl_core_Core_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Core_vmm_VMM_iid kl_core_Core_vmm_VMM_iid
#define Core_io_IO_iid kl_core_Core_io_IO_iid
#define Core_thread_Thread_iid kl_core_Core_thread_Thread_iid
#define Core_handle_Handle_iid kl_core_Core_handle_Handle_iid
#define Core_task_Task_iid kl_core_Core_task_Task_iid
#define Core_task_TaskDebug_iid kl_core_Core_task_TaskDebug_iid
#define Core_sync_Sync_iid kl_core_Core_sync_Sync_iid
#define Core_fs_FS_iid kl_core_Core_fs_FS_iid
#define Core_fs_FSUnsafe_iid kl_core_Core_fs_FSUnsafe_iid
#define Core_time_Time_iid kl_core_Core_time_Time_iid
#define Core_hal_HAL_iid kl_core_Core_hal_HAL_iid
#define Core_xhcidbg_XHCIDBG_iid kl_core_Core_xhcidbg_XHCIDBG_iid
#define Core_audit_Audit_iid kl_core_Core_audit_Audit_iid
#define Core_profiler_Profiler_iid kl_core_Core_profiler_Profiler_iid
#define Core_iommu_IOMMU_iid kl_core_Core_iommu_IOMMU_iid
#define Core_cm_CM_iid kl_core_Core_cm_CM_iid
#define Core_pm_PM_iid kl_core_Core_pm_PM_iid
#define Core_notice_Notice_iid kl_core_Core_notice_Notice_iid
#define Core_ipc_IPC_iid kl_core_Core_ipc_IPC_iid
#define Core_log_Log_iid kl_core_Core_log_Log_iid
#define Core_efi_Efi_iid kl_core_Core_efi_Efi_iid
#define Core_iidMax kl_core_Core_iidMax
#define Core_iidOffset kl_core_Core_iidOffset
#define Core_vmm_iidOffset kl_core_Core_vmm_iidOffset
#define Core_io_iidOffset kl_core_Core_io_iidOffset
#define Core_thread_iidOffset kl_core_Core_thread_iidOffset
#define Core_handle_iidOffset kl_core_Core_handle_iidOffset
#define Core_task_iidOffset kl_core_Core_task_iidOffset
#define Core_sync_iidOffset kl_core_Core_sync_iidOffset
#define Core_fs_iidOffset kl_core_Core_fs_iidOffset
#define Core_time_iidOffset kl_core_Core_time_iidOffset
#define Core_hal_iidOffset kl_core_Core_hal_iidOffset
#define Core_xhcidbg_iidOffset kl_core_Core_xhcidbg_iidOffset
#define Core_audit_iidOffset kl_core_Core_audit_iidOffset
#define Core_profiler_iidOffset kl_core_Core_profiler_iidOffset
#define Core_iommu_iidOffset kl_core_Core_iommu_iidOffset
#define Core_cm_iidOffset kl_core_Core_cm_iidOffset
#define Core_pm_iidOffset kl_core_Core_pm_iidOffset
#define Core_notice_iidOffset kl_core_Core_notice_iidOffset
#define Core_ipc_iidOffset kl_core_Core_ipc_iidOffset
#define Core_log_iidOffset kl_core_Core_log_iidOffset
#define Core_efi_iidOffset kl_core_Core_efi_iidOffset
#define Core_securityIidMax kl_core_Core_securityIidMax
#define Core_component_req_arena_size kl_core_Core_component_req_arena_size
#define Core_component_res_arena_size kl_core_Core_component_res_arena_size
#define Core_component_req_handles kl_core_Core_component_req_handles
#define Core_component_res_handles kl_core_Core_component_res_handles
#define Core_component_err_handles kl_core_Core_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Core__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__Efi__COMPONENT_ENDPOINTS__
#define __kl_core__Efi__COMPONENT_ENDPOINTS__
enum {
    kl_core_Efi_Efi_iid,
    kl_core_Efi_iidMax,
};
enum {
    kl_core_Efi_iidOffset = 0,
};
enum {
    kl_core_Efi_securityIidMax,
};
enum {
    kl_core_Efi_component_req_arena_size = 18432,
    kl_core_Efi_component_res_arena_size = 16384,
    kl_core_Efi_component_req_handles = 0,
    kl_core_Efi_component_res_handles = 0,
    kl_core_Efi_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Efi_Efi_iid kl_core_Efi_Efi_iid
#define Efi_iidMax kl_core_Efi_iidMax
#define Efi_iidOffset kl_core_Efi_iidOffset
#define Efi_securityIidMax kl_core_Efi_securityIidMax
#define Efi_component_req_arena_size kl_core_Efi_component_req_arena_size
#define Efi_component_res_arena_size kl_core_Efi_component_res_arena_size
#define Efi_component_req_handles kl_core_Efi_component_req_handles
#define Efi_component_res_handles kl_core_Efi_component_res_handles
#define Efi_component_err_handles kl_core_Efi_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Efi__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__FS__COMPONENT_ENDPOINTS__
#define __kl_core__FS__COMPONENT_ENDPOINTS__
enum {
    kl_core_FS_FS_iid,
    kl_core_FS_FSUnsafe_iid,
    kl_core_FS_iidMax,
};
enum {
    kl_core_FS_iidOffset = 0,
};
enum {
    kl_core_FS_securityIidMax,
};
enum {
    kl_core_FS_component_req_arena_size = 1024,
    kl_core_FS_component_res_arena_size = 4096,
    kl_core_FS_component_req_handles = 1,
    kl_core_FS_component_res_handles = 1,
    kl_core_FS_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define FS_FS_iid kl_core_FS_FS_iid
#define FS_FSUnsafe_iid kl_core_FS_FSUnsafe_iid
#define FS_iidMax kl_core_FS_iidMax
#define FS_iidOffset kl_core_FS_iidOffset
#define FS_securityIidMax kl_core_FS_securityIidMax
#define FS_component_req_arena_size kl_core_FS_component_req_arena_size
#define FS_component_res_arena_size kl_core_FS_component_res_arena_size
#define FS_component_req_handles kl_core_FS_component_req_handles
#define FS_component_res_handles kl_core_FS_component_res_handles
#define FS_component_err_handles kl_core_FS_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__FS__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__HAL__COMPONENT_ENDPOINTS__
#define __kl_core__HAL__COMPONENT_ENDPOINTS__
enum {
    kl_core_HAL_HAL_iid,
    kl_core_HAL_iidMax,
};
enum {
    kl_core_HAL_iidOffset = 0,
};
enum {
    kl_core_HAL_securityIidMax,
};
enum {
    kl_core_HAL_component_req_arena_size = 1024,
    kl_core_HAL_component_res_arena_size = 1024,
    kl_core_HAL_component_req_handles = 0,
    kl_core_HAL_component_res_handles = 0,
    kl_core_HAL_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define HAL_HAL_iid kl_core_HAL_HAL_iid
#define HAL_iidMax kl_core_HAL_iidMax
#define HAL_iidOffset kl_core_HAL_iidOffset
#define HAL_securityIidMax kl_core_HAL_securityIidMax
#define HAL_component_req_arena_size kl_core_HAL_component_req_arena_size
#define HAL_component_res_arena_size kl_core_HAL_component_res_arena_size
#define HAL_component_req_handles kl_core_HAL_component_req_handles
#define HAL_component_res_handles kl_core_HAL_component_res_handles
#define HAL_component_err_handles kl_core_HAL_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__HAL__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__Handle__COMPONENT_ENDPOINTS__
#define __kl_core__Handle__COMPONENT_ENDPOINTS__
enum {
    kl_core_Handle_Handle_iid,
    kl_core_Handle_iidMax,
};
enum {
    kl_core_Handle_iidOffset = 0,
};
enum {
    kl_core_Handle_securityIidMax,
};
enum {
    kl_core_Handle_component_req_arena_size = 0,
    kl_core_Handle_component_res_arena_size = 0,
    kl_core_Handle_component_req_handles = 2,
    kl_core_Handle_component_res_handles = 1,
    kl_core_Handle_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Handle_Handle_iid kl_core_Handle_Handle_iid
#define Handle_iidMax kl_core_Handle_iidMax
#define Handle_iidOffset kl_core_Handle_iidOffset
#define Handle_securityIidMax kl_core_Handle_securityIidMax
#define Handle_component_req_arena_size kl_core_Handle_component_req_arena_size
#define Handle_component_res_arena_size kl_core_Handle_component_res_arena_size
#define Handle_component_req_handles kl_core_Handle_component_req_handles
#define Handle_component_res_handles kl_core_Handle_component_res_handles
#define Handle_component_err_handles kl_core_Handle_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Handle__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__IOMMU__COMPONENT_ENDPOINTS__
#define __kl_core__IOMMU__COMPONENT_ENDPOINTS__
enum {
    kl_core_IOMMU_IOMMU_iid,
    kl_core_IOMMU_iidMax,
};
enum {
    kl_core_IOMMU_iidOffset = 0,
};
enum {
    kl_core_IOMMU_securityIidMax,
};
enum {
    kl_core_IOMMU_component_req_arena_size = 0,
    kl_core_IOMMU_component_res_arena_size = 0,
    kl_core_IOMMU_component_req_handles = 1,
    kl_core_IOMMU_component_res_handles = 1,
    kl_core_IOMMU_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define IOMMU_IOMMU_iid kl_core_IOMMU_IOMMU_iid
#define IOMMU_iidMax kl_core_IOMMU_iidMax
#define IOMMU_iidOffset kl_core_IOMMU_iidOffset
#define IOMMU_securityIidMax kl_core_IOMMU_securityIidMax
#define IOMMU_component_req_arena_size kl_core_IOMMU_component_req_arena_size
#define IOMMU_component_res_arena_size kl_core_IOMMU_component_res_arena_size
#define IOMMU_component_req_handles kl_core_IOMMU_component_req_handles
#define IOMMU_component_res_handles kl_core_IOMMU_component_res_handles
#define IOMMU_component_err_handles kl_core_IOMMU_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__IOMMU__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__IO__COMPONENT_ENDPOINTS__
#define __kl_core__IO__COMPONENT_ENDPOINTS__
enum {
    kl_core_IO_IO_iid,
    kl_core_IO_iidMax,
};
enum {
    kl_core_IO_iidOffset = 0,
};
enum {
    kl_core_IO_securityIidMax,
};
enum {
    kl_core_IO_component_req_arena_size = 0,
    kl_core_IO_component_res_arena_size = 512,
    kl_core_IO_component_req_handles = 2,
    kl_core_IO_component_res_handles = 1,
    kl_core_IO_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define IO_IO_iid kl_core_IO_IO_iid
#define IO_iidMax kl_core_IO_iidMax
#define IO_iidOffset kl_core_IO_iidOffset
#define IO_securityIidMax kl_core_IO_securityIidMax
#define IO_component_req_arena_size kl_core_IO_component_req_arena_size
#define IO_component_res_arena_size kl_core_IO_component_res_arena_size
#define IO_component_req_handles kl_core_IO_component_req_handles
#define IO_component_res_handles kl_core_IO_component_res_handles
#define IO_component_err_handles kl_core_IO_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__IO__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__IPC__COMPONENT_ENDPOINTS__
#define __kl_core__IPC__COMPONENT_ENDPOINTS__
enum {
    kl_core_IPC_IPC_iid,
    kl_core_IPC_iidMax,
};
enum {
    kl_core_IPC_iidOffset = 0,
};
enum {
    kl_core_IPC_securityIidMax,
};
enum {
    kl_core_IPC_component_req_arena_size = 0,
    kl_core_IPC_component_res_arena_size = 0,
    kl_core_IPC_component_req_handles = 1,
    kl_core_IPC_component_res_handles = 1,
    kl_core_IPC_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define IPC_IPC_iid kl_core_IPC_IPC_iid
#define IPC_iidMax kl_core_IPC_iidMax
#define IPC_iidOffset kl_core_IPC_iidOffset
#define IPC_securityIidMax kl_core_IPC_securityIidMax
#define IPC_component_req_arena_size kl_core_IPC_component_req_arena_size
#define IPC_component_res_arena_size kl_core_IPC_component_res_arena_size
#define IPC_component_req_handles kl_core_IPC_component_req_handles
#define IPC_component_res_handles kl_core_IPC_component_res_handles
#define IPC_component_err_handles kl_core_IPC_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__IPC__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__Log__COMPONENT_ENDPOINTS__
#define __kl_core__Log__COMPONENT_ENDPOINTS__
enum {
    kl_core_Log_Log_iid,
    kl_core_Log_iidMax,
};
enum {
    kl_core_Log_iidOffset = 0,
};
enum {
    kl_core_Log_securityIidMax,
};
enum {
    kl_core_Log_component_req_arena_size = 0,
    kl_core_Log_component_res_arena_size = 65536,
    kl_core_Log_component_req_handles = 0,
    kl_core_Log_component_res_handles = 1,
    kl_core_Log_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Log_Log_iid kl_core_Log_Log_iid
#define Log_iidMax kl_core_Log_iidMax
#define Log_iidOffset kl_core_Log_iidOffset
#define Log_securityIidMax kl_core_Log_securityIidMax
#define Log_component_req_arena_size kl_core_Log_component_req_arena_size
#define Log_component_res_arena_size kl_core_Log_component_res_arena_size
#define Log_component_req_handles kl_core_Log_component_req_handles
#define Log_component_res_handles kl_core_Log_component_res_handles
#define Log_component_err_handles kl_core_Log_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Log__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__Notice__COMPONENT_ENDPOINTS__
#define __kl_core__Notice__COMPONENT_ENDPOINTS__
enum {
    kl_core_Notice_Notice_iid,
    kl_core_Notice_iidMax,
};
enum {
    kl_core_Notice_iidOffset = 0,
};
enum {
    kl_core_Notice_securityIidMax,
};
enum {
    kl_core_Notice_component_req_arena_size = 0,
    kl_core_Notice_component_res_arena_size =
    2048,
    kl_core_Notice_component_req_handles = 2,
    kl_core_Notice_component_res_handles = 1,
    kl_core_Notice_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Notice_Notice_iid kl_core_Notice_Notice_iid
#define Notice_iidMax kl_core_Notice_iidMax
#define Notice_iidOffset kl_core_Notice_iidOffset
#define Notice_securityIidMax kl_core_Notice_securityIidMax
#define Notice_component_req_arena_size kl_core_Notice_component_req_arena_size
#define Notice_component_res_arena_size kl_core_Notice_component_res_arena_size
#define Notice_component_req_handles kl_core_Notice_component_req_handles
#define Notice_component_res_handles kl_core_Notice_component_res_handles
#define Notice_component_err_handles kl_core_Notice_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Notice__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__PM__COMPONENT_ENDPOINTS__
#define __kl_core__PM__COMPONENT_ENDPOINTS__
enum {
    kl_core_PM_PM_iid,
    kl_core_PM_iidMax,
};
enum {
    kl_core_PM_iidOffset = 0,
};
enum {
    kl_core_PM_securityIidMax,
};
enum {
    kl_core_PM_component_req_arena_size = 0,
    kl_core_PM_component_res_arena_size = 0,
    kl_core_PM_component_req_handles = 0,
    kl_core_PM_component_res_handles = 0,
    kl_core_PM_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define PM_PM_iid kl_core_PM_PM_iid
#define PM_iidMax kl_core_PM_iidMax
#define PM_iidOffset kl_core_PM_iidOffset
#define PM_securityIidMax kl_core_PM_securityIidMax
#define PM_component_req_arena_size kl_core_PM_component_req_arena_size
#define PM_component_res_arena_size kl_core_PM_component_res_arena_size
#define PM_component_req_handles kl_core_PM_component_req_handles
#define PM_component_res_handles kl_core_PM_component_res_handles
#define PM_component_err_handles kl_core_PM_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__PM__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__Profiler__COMPONENT_ENDPOINTS__
#define __kl_core__Profiler__COMPONENT_ENDPOINTS__
enum {
    kl_core_Profiler_Profiler_iid,
    kl_core_Profiler_iidMax,
};
enum {
    kl_core_Profiler_iidOffset = 0,
};
enum {
    kl_core_Profiler_securityIidMax,
};
enum {
    kl_core_Profiler_component_req_arena_size =
    9728,
    kl_core_Profiler_component_res_arena_size =
    66560,
    kl_core_Profiler_component_req_handles = 1,
    kl_core_Profiler_component_res_handles = 0,
    kl_core_Profiler_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Profiler_Profiler_iid kl_core_Profiler_Profiler_iid
#define Profiler_iidMax kl_core_Profiler_iidMax
#define Profiler_iidOffset kl_core_Profiler_iidOffset
#define Profiler_securityIidMax kl_core_Profiler_securityIidMax
#define Profiler_component_req_arena_size kl_core_Profiler_component_req_arena_size
#define Profiler_component_res_arena_size kl_core_Profiler_component_res_arena_size
#define Profiler_component_req_handles kl_core_Profiler_component_req_handles
#define Profiler_component_res_handles kl_core_Profiler_component_res_handles
#define Profiler_component_err_handles kl_core_Profiler_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Profiler__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__Sync__COMPONENT_ENDPOINTS__
#define __kl_core__Sync__COMPONENT_ENDPOINTS__
enum {
    kl_core_Sync_Sync_iid,
    kl_core_Sync_iidMax,
};
enum {
    kl_core_Sync_iidOffset = 0,
};
enum {
    kl_core_Sync_securityIidMax,
};
enum {
    kl_core_Sync_component_req_arena_size = 0,
    kl_core_Sync_component_res_arena_size = 0,
    kl_core_Sync_component_req_handles = 0,
    kl_core_Sync_component_res_handles = 0,
    kl_core_Sync_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Sync_Sync_iid kl_core_Sync_Sync_iid
#define Sync_iidMax kl_core_Sync_iidMax
#define Sync_iidOffset kl_core_Sync_iidOffset
#define Sync_securityIidMax kl_core_Sync_securityIidMax
#define Sync_component_req_arena_size kl_core_Sync_component_req_arena_size
#define Sync_component_res_arena_size kl_core_Sync_component_res_arena_size
#define Sync_component_req_handles kl_core_Sync_component_req_handles
#define Sync_component_res_handles kl_core_Sync_component_res_handles
#define Sync_component_err_handles kl_core_Sync_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Sync__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__Task__COMPONENT_ENDPOINTS__
#define __kl_core__Task__COMPONENT_ENDPOINTS__
enum {
    kl_core_Task_Task_iid,
    kl_core_Task_TaskDebug_iid,
    kl_core_Task_iidMax,
};
enum {
    kl_core_Task_iidOffset = 0,
};
enum {
    kl_core_Task_securityIidMax,
};
enum {
    kl_core_Task_component_req_arena_size =
    131072,
    kl_core_Task_component_res_arena_size =
    17180000252,
    kl_core_Task_component_req_handles = 3,
    kl_core_Task_component_res_handles = 1,
    kl_core_Task_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Task_Task_iid kl_core_Task_Task_iid
#define Task_TaskDebug_iid kl_core_Task_TaskDebug_iid
#define Task_iidMax kl_core_Task_iidMax
#define Task_iidOffset kl_core_Task_iidOffset
#define Task_securityIidMax kl_core_Task_securityIidMax
#define Task_component_req_arena_size kl_core_Task_component_req_arena_size
#define Task_component_res_arena_size kl_core_Task_component_res_arena_size
#define Task_component_req_handles kl_core_Task_component_req_handles
#define Task_component_res_handles kl_core_Task_component_res_handles
#define Task_component_err_handles kl_core_Task_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Task__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__Thread__COMPONENT_ENDPOINTS__
#define __kl_core__Thread__COMPONENT_ENDPOINTS__
enum {
    kl_core_Thread_Thread_iid,
    kl_core_Thread_iidMax,
};
enum {
    kl_core_Thread_iidOffset = 0,
};
enum {
    kl_core_Thread_securityIidMax,
};
enum {
    kl_core_Thread_component_req_arena_size = 0,
    kl_core_Thread_component_res_arena_size = 0,
    kl_core_Thread_component_req_handles = 1,
    kl_core_Thread_component_res_handles = 1,
    kl_core_Thread_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Thread_Thread_iid kl_core_Thread_Thread_iid
#define Thread_iidMax kl_core_Thread_iidMax
#define Thread_iidOffset kl_core_Thread_iidOffset
#define Thread_securityIidMax kl_core_Thread_securityIidMax
#define Thread_component_req_arena_size kl_core_Thread_component_req_arena_size
#define Thread_component_res_arena_size kl_core_Thread_component_res_arena_size
#define Thread_component_req_handles kl_core_Thread_component_req_handles
#define Thread_component_res_handles kl_core_Thread_component_res_handles
#define Thread_component_err_handles kl_core_Thread_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Thread__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__Time__COMPONENT_ENDPOINTS__
#define __kl_core__Time__COMPONENT_ENDPOINTS__
enum {
    kl_core_Time_Time_iid,
    kl_core_Time_iidMax,
};
enum {
    kl_core_Time_iidOffset = 0,
};
enum {
    kl_core_Time_securityIidMax,
};
enum {
    kl_core_Time_component_req_arena_size = 0,
    kl_core_Time_component_res_arena_size = 0,
    kl_core_Time_component_req_handles = 0,
    kl_core_Time_component_res_handles = 0,
    kl_core_Time_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Time_Time_iid kl_core_Time_Time_iid
#define Time_iidMax kl_core_Time_iidMax
#define Time_iidOffset kl_core_Time_iidOffset
#define Time_securityIidMax kl_core_Time_securityIidMax
#define Time_component_req_arena_size kl_core_Time_component_req_arena_size
#define Time_component_res_arena_size kl_core_Time_component_res_arena_size
#define Time_component_req_handles kl_core_Time_component_req_handles
#define Time_component_res_handles kl_core_Time_component_res_handles
#define Time_component_err_handles kl_core_Time_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Time__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__VMM__COMPONENT_ENDPOINTS__
#define __kl_core__VMM__COMPONENT_ENDPOINTS__
enum {
    kl_core_VMM_VMM_iid,
    kl_core_VMM_iidMax,
};
enum {
    kl_core_VMM_iidOffset = 0,
};
enum {
    kl_core_VMM_securityIidMax,
};
enum {
    kl_core_VMM_component_req_arena_size = 0,
    kl_core_VMM_component_res_arena_size = 128,
    kl_core_VMM_component_req_handles = 1,
    kl_core_VMM_component_res_handles = 1,
    kl_core_VMM_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define VMM_VMM_iid kl_core_VMM_VMM_iid
#define VMM_iidMax kl_core_VMM_iidMax
#define VMM_iidOffset kl_core_VMM_iidOffset
#define VMM_securityIidMax kl_core_VMM_securityIidMax
#define VMM_component_req_arena_size kl_core_VMM_component_req_arena_size
#define VMM_component_res_arena_size kl_core_VMM_component_res_arena_size
#define VMM_component_req_handles kl_core_VMM_component_req_handles
#define VMM_component_res_handles kl_core_VMM_component_res_handles
#define VMM_component_err_handles kl_core_VMM_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__VMM__COMPONENT_ENDPOINTS__ */

#ifndef __kl_core__XHCIDBG__COMPONENT_ENDPOINTS__
#define __kl_core__XHCIDBG__COMPONENT_ENDPOINTS__
enum {
    kl_core_XHCIDBG_XHCIDBG_iid,
    kl_core_XHCIDBG_iidMax,
};
enum {
    kl_core_XHCIDBG_iidOffset = 0,
};
enum {
    kl_core_XHCIDBG_securityIidMax,
};
enum {
    kl_core_XHCIDBG_component_req_arena_size = 0,
    kl_core_XHCIDBG_component_res_arena_size = 0,
    kl_core_XHCIDBG_component_req_handles = 0,
    kl_core_XHCIDBG_component_res_handles = 0,
    kl_core_XHCIDBG_component_err_handles = 0,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define XHCIDBG_XHCIDBG_iid kl_core_XHCIDBG_XHCIDBG_iid
#define XHCIDBG_iidMax kl_core_XHCIDBG_iidMax
#define XHCIDBG_iidOffset kl_core_XHCIDBG_iidOffset
#define XHCIDBG_securityIidMax kl_core_XHCIDBG_securityIidMax
#define XHCIDBG_component_req_arena_size kl_core_XHCIDBG_component_req_arena_size
#define XHCIDBG_component_res_arena_size kl_core_XHCIDBG_component_res_arena_size
#define XHCIDBG_component_req_handles kl_core_XHCIDBG_component_req_handles
#define XHCIDBG_component_res_handles kl_core_XHCIDBG_component_res_handles
#define XHCIDBG_component_err_handles kl_core_XHCIDBG_component_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__XHCIDBG__COMPONENT_ENDPOINTS__ */

#ifndef ____Einit__TASK_ENDPOINTS__
#define ____Einit__TASK_ENDPOINTS__
enum {
    Einit_entity_req_arena_size =
    Einit_component_req_arena_size,
    Einit_entity_res_arena_size =
    Einit_component_res_arena_size,
    Einit_entity_req_handles =
    Einit_component_req_handles,
    Einit_entity_res_handles =
    Einit_component_res_handles,
    Einit_entity_err_handles =
    Einit_component_err_handles,
};

#endif /* ____Einit__TASK_ENDPOINTS__ */

#ifndef ____Hello__TASK_ENDPOINTS__
#define ____Hello__TASK_ENDPOINTS__
enum {
    Hello_entity_req_arena_size =
    Hello_component_req_arena_size,
    Hello_entity_res_arena_size =
    Hello_component_res_arena_size,
    Hello_entity_req_handles =
    Hello_component_req_handles,
    Hello_entity_res_handles =
    Hello_component_res_handles,
    Hello_entity_err_handles =
    Hello_component_err_handles,
};

#endif /* ____Hello__TASK_ENDPOINTS__ */

#ifndef __kl_core__Core__TASK_ENDPOINTS__
#define __kl_core__Core__TASK_ENDPOINTS__
enum {
    kl_core_Core_entity_req_arena_size =
    kl_core_Core_component_req_arena_size,
    kl_core_Core_entity_res_arena_size =
    kl_core_Core_component_res_arena_size,
    kl_core_Core_entity_req_handles =
    kl_core_Core_component_req_handles,
    kl_core_Core_entity_res_handles =
    kl_core_Core_component_res_handles,
    kl_core_Core_entity_err_handles =
    kl_core_Core_component_err_handles,
};
#ifdef NK_USE_UNQUALIFIED_NAMES
#define Core_entity_req_arena_size kl_core_Core_entity_req_arena_size
#define Core_entity_res_arena_size kl_core_Core_entity_res_arena_size
#define Core_entity_req_handles kl_core_Core_entity_req_handles
#define Core_entity_res_handles kl_core_Core_entity_res_handles
#define Core_entity_err_handles kl_core_Core_entity_err_handles
#endif /* NK_USE_UNQUALIFIED_NAMES */

#endif /* __kl_core__Core__TASK_ENDPOINTS__ */

#ifdef __cplusplus
    }
#endif


#ifdef ENABLE_AUDIT_LOG_TO_CORE_DEBUG_CONSOLE
  #include "kss/audit-gen-api.h"
  // The do while(0) part is a way to wrap a macro to behave nicely.
  #define AUDIT_LOG_TO_CORE_DEBUG_CONSOLE(header, msg_buf) do { \
    const char msg_pfx[] = "[KSMA] "; \
    const nk_size_t msg_pfx_len = sizeof(msg_pfx) - 1; \
    const nk_size_t buf_len = 1024 + msg_pfx_len; \
    char buffer[1024 + sizeof(msg_pfx) - 1] = {0}; \
    memcpy(buffer, msg_pfx, msg_pfx_len); \
    nk_err_t rc = __kss_audit_decode(&(header), (msg_buf), buffer + msg_pfx_len, sizeof(buffer) - msg_pfx_len - 1); \
    if (rc == NK_EOK) { \
      const nk_size_t printk_chunk_size = 255; \
      for (nk_size_t pos = 0; pos < (buf_len - 1) && (buffer[pos] != '\0'); pos += printk_chunk_size) { \
        PSL_PRINT_FN("%.*s", (int)printk_chunk_size, &buffer[pos]); \
      } \
      PSL_PRINT_FN("\n"); \
    } else { \
      PSL_PRINT_FN("[KSMA] Audit decoder failed with error code %d\n", rc); \
    } \
  } while(0)
#else
  #define AUDIT_LOG_TO_CORE_DEBUG_CONSOLE(header, msg_buf) do {} while(0)
#endif
    

#ifdef PSL_ENABLE_TRACE
  #define CLS_PSL            "\033[0;37m"
  #define CLS_ERROR          "\033[0;31m"
  #define CLS_CRIT           "\033[1;31m"

  #define CLS_KSS            "\033[0;35m"
  #define CLS_KSS_GRANTED    "\033[0;34m"
  #define CLS_KSS_DENIED     "\033[0;33m"

  #define CLS_AUDIT          "\033[0;90m"
  #define CLS_AUDIT_MSG      "\033[1;37m"

  #define CLS_PROVIDER       "\033[0;36m"
  #define CLS_PROVIDER_ERROR "\033[0;31m"

  #define CLS_TEST           "\033[0;37m"
  #define CLS_TEST_ERROR     "\033[0;31m"

  #define                         \
    PSL_TRACE(cls, sys, fmt, ...) \
      PSL_PRINT_FN(               \
        cls                       \
        sys                       \
        "\t[ %s | %d ]\t"         \
        fmt                       \
        "\033[0m\n",              \
        __func__, __LINE__,       \
        ##__VA_ARGS__             \
      )
#else
  #define PSL_TRACE(cls, fmt, ...) \
    ((void)0)
#endif
  
#define GLOBAL_SID NK_SID_C(0)
nk_uint8_t rt_audit_level = 0U;
static nk_bool_t psl_audit_log(kss_call_id callId, kss_audit_tag tag,
                               kss_audit_profile_t kss_profile,
                               kss_decision_t *decision, const void *args,
                               nk_uint16_t argsSize)
{
    PSL_TRACE(CLS_AUDIT, "Audit",
              "callId: %u, tag: %d, size: %u, profile: %d, decision: %d, args: %p",
              callId, tag, argsSize, kss_profile, *decision, args);
    if ((kss_profile & KSS_AUDIT_DENIED && *decision == KSS_DENY) ||
        (kss_profile & KSS_AUDIT_GRANTED && *decision == KSS_GRANT)) {
        kss_audit_header header = {.callId =callId, .tag =tag, .size =argsSize};
        
        AUDIT_LOG_TO_CORE_DEBUG_CONSOLE(header, args);
        kss_audit_log(&header, sizeof(header), args, header.size);
        return NK_TRUE;
    } else {
        PSL_TRACE(CLS_AUDIT, "Audit", "silenced by KSS profile for decision");
        return NK_FALSE;
    }
}
void __kss_fini(void)
{
    PSL_TRACE(CLS_KSS, "KSS", "Fini");
    PSL_TRACE(CLS_KSS, "KSS", "Fini done");
}
nk_err_t __kss_init(void)
{
    kss_slot_t currentSlotId = 0;
    
    nk_unused(currentSlotId);
    PSL_TRACE(CLS_KSS, "KSS", "Init");
    PSL_TRACE(CLS_KSS, "KSS", "Init done");
    return NK_EOK;
}
static const char *eiids[] = {"Einit", "Hello", "kl.core.Core"};
static const char *execute_names(nk_mid_t mid)
{
    static const char *names[] = {"run"};
    
    if (mid < nk_array_size(names))
        return names[mid];
    return NK_NULL;
}
static inline nk_bool_t kl_core_Audit_Close_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Audit_Close_err *msg = (const
                                                 struct kl_core_Audit_Close_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Audit_Close_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Audit_Close_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Audit_Close_req *msg = (const
                                                 struct kl_core_Audit_Close_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Audit_Close_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Audit_Close_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Audit_Close_res *msg = (const
                                                 struct kl_core_Audit_Close_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Audit_Close_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Audit_Open_val_err(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Audit_Open_err *msg = (const
                                                struct kl_core_Audit_Open_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Audit_Open_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Audit_Open_val_req(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Audit_Open_req *msg = (const
                                                struct kl_core_Audit_Open_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Audit_Open_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->name;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Audit_Open_val_res(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Audit_Open_res *msg = (const
                                                struct kl_core_Audit_Open_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Audit_Open_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Audit_Read_val_err(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Audit_Read_err *msg = (const
                                                struct kl_core_Audit_Read_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Audit_Read_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Audit_Read_val_req(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Audit_Read_req *msg = (const
                                                struct kl_core_Audit_Read_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Audit_Read_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Audit_Read_val_res(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Audit_Read_res *msg = (const
                                                struct kl_core_Audit_Read_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Audit_Read_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->msg;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 512)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_CM_Accept_val_err(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_CM_Accept_err *msg = (const
                                               struct kl_core_CM_Accept_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_CM_Accept_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_CM_Accept_val_req(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_CM_Accept_req *msg = (const
                                               struct kl_core_CM_Accept_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_CM_Accept_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->client;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    
    const nk_ptr_t *string3 = &msg->service;
    
    if (nk_arena_validate(nk_uint8_t, arena, string3) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size4 = 0;
    const nk_uint8_t *items5 = nk_arena_get(nk_uint8_t, arena, string3, &size4);
    
    if (size4 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items5, size4) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_CM_Accept_val_res(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_CM_Accept_res *msg = (const
                                               struct kl_core_CM_Accept_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_CM_Accept_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_CM_Connect_val_err(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_CM_Connect_err *msg = (const
                                                struct kl_core_CM_Connect_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_CM_Connect_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_CM_Connect_val_req(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_CM_Connect_req *msg = (const
                                                struct kl_core_CM_Connect_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_CM_Connect_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->server;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    
    const nk_ptr_t *string3 = &msg->service;
    
    if (nk_arena_validate(nk_uint8_t, arena, string3) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size4 = 0;
    const nk_uint8_t *items5 = nk_arena_get(nk_uint8_t, arena, string3, &size4);
    
    if (size4 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items5, size4) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_CM_Connect_val_res(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_CM_Connect_res *msg = (const
                                                struct kl_core_CM_Connect_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_CM_Connect_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_CM_Drop_val_err(const struct nk_message *msg0,
                                                const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_CM_Drop_err *msg = (const
                                             struct kl_core_CM_Drop_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_CM_Drop_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_CM_Drop_val_req(const struct nk_message *msg0,
                                                const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_CM_Drop_req *msg = (const
                                             struct kl_core_CM_Drop_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_CM_Drop_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->client;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    
    const nk_ptr_t *string3 = &msg->service;
    
    if (nk_arena_validate(nk_uint8_t, arena, string3) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size4 = 0;
    const nk_uint8_t *items5 = nk_arena_get(nk_uint8_t, arena, string3, &size4);
    
    if (size4 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items5, size4) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_CM_Drop_val_res(const struct nk_message *msg0,
                                                const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_CM_Drop_res *msg = (const
                                             struct kl_core_CM_Drop_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_CM_Drop_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_CM_Listen_val_err(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_CM_Listen_err *msg = (const
                                               struct kl_core_CM_Listen_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_CM_Listen_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_CM_Listen_val_req(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_CM_Listen_req *msg = (const
                                               struct kl_core_CM_Listen_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_CM_Listen_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->filter;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_CM_Listen_val_res(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_CM_Listen_res *msg = (const
                                               struct kl_core_CM_Listen_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_CM_Listen_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->client;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    
    const nk_ptr_t *string3 = &msg->service;
    
    if (nk_arena_validate(nk_uint8_t, arena, string3) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size4 = 0;
    const nk_uint8_t *items5 = nk_arena_get(nk_uint8_t, arena, string3, &size4);
    
    if (size4 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items5, size4) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_GetNextVariableName_val_err(const
                                                                struct nk_message *msg0,
                                                                const
                                                                struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_GetNextVariableName_err *msg = (const
                                                             struct kl_core_Efi_GetNextVariableName_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_GetNextVariableName_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_GetNextVariableName_val_req(const
                                                                struct nk_message *msg0,
                                                                const
                                                                struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_GetNextVariableName_req *msg = (const
                                                             struct kl_core_Efi_GetNextVariableName_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_GetNextVariableName_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->variableNamePrev;
    
    if (nk_arena_validate(nk_uint16_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint16_t *items2 = nk_arena_get(nk_uint16_t, arena, sequence0,
                                             &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (((nk_uintptr_t) items2 & (nk_alignof(nk_uint16_t) - 1)) != 0)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_GetNextVariableName_val_res(const
                                                                struct nk_message *msg0,
                                                                const
                                                                struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_GetNextVariableName_res *msg = (const
                                                             struct kl_core_Efi_GetNextVariableName_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Efi_GetNextVariableName_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->variableNameNext;
    
    if (nk_arena_validate(nk_uint16_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint16_t *items2 = nk_arena_get(nk_uint16_t, arena, sequence0,
                                             &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (((nk_uintptr_t) items2 & (nk_alignof(nk_uint16_t) - 1)) != 0)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_GetTime_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_GetTime_err *msg = (const
                                                 struct kl_core_Efi_GetTime_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_GetTime_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_GetTime_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_GetTime_req *msg = (const
                                                 struct kl_core_Efi_GetTime_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_GetTime_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_GetTime_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_GetTime_res *msg = (const
                                                 struct kl_core_Efi_GetTime_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Efi_GetTime_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_GetVariable_val_err(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_GetVariable_err *msg = (const
                                                     struct kl_core_Efi_GetVariable_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_GetVariable_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_GetVariable_val_req(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_GetVariable_req *msg = (const
                                                     struct kl_core_Efi_GetVariable_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_GetVariable_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->variableName;
    
    if (nk_arena_validate(nk_uint16_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint16_t *items2 = nk_arena_get(nk_uint16_t, arena, sequence0,
                                             &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (((nk_uintptr_t) items2 & (nk_alignof(nk_uint16_t) - 1)) != 0)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_GetVariable_val_res(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_GetVariable_res *msg = (const
                                                     struct kl_core_Efi_GetVariable_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Efi_GetVariable_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->data;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 16384)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_QueryVariableInfo_val_err(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_QueryVariableInfo_err *msg = (const
                                                           struct kl_core_Efi_QueryVariableInfo_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_QueryVariableInfo_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_QueryVariableInfo_val_req(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_QueryVariableInfo_req *msg = (const
                                                           struct kl_core_Efi_QueryVariableInfo_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_QueryVariableInfo_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_QueryVariableInfo_val_res(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_QueryVariableInfo_res *msg = (const
                                                           struct kl_core_Efi_QueryVariableInfo_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Efi_QueryVariableInfo_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_ResetSystem_val_err(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_ResetSystem_err *msg = (const
                                                     struct kl_core_Efi_ResetSystem_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_ResetSystem_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_ResetSystem_val_req(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_ResetSystem_req *msg = (const
                                                     struct kl_core_Efi_ResetSystem_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_ResetSystem_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->resetData;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 2048)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_ResetSystem_val_res(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_ResetSystem_res *msg = (const
                                                     struct kl_core_Efi_ResetSystem_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Efi_ResetSystem_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_SetTime_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_SetTime_err *msg = (const
                                                 struct kl_core_Efi_SetTime_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_SetTime_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_SetTime_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_SetTime_req *msg = (const
                                                 struct kl_core_Efi_SetTime_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_SetTime_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_SetTime_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_SetTime_res *msg = (const
                                                 struct kl_core_Efi_SetTime_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Efi_SetTime_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_SetVariable_val_err(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_SetVariable_err *msg = (const
                                                     struct kl_core_Efi_SetVariable_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_SetVariable_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_SetVariable_val_req(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_SetVariable_req *msg = (const
                                                     struct kl_core_Efi_SetVariable_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Efi_SetVariable_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->variableName;
    
    if (nk_arena_validate(nk_uint16_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint16_t *items2 = nk_arena_get(nk_uint16_t, arena, sequence0,
                                             &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (((nk_uintptr_t) items2 & (nk_alignof(nk_uint16_t) - 1)) != 0)
        return NK_FALSE;
    nk_unused(items2);
    
    const nk_ptr_t *sequence7 = &msg->data;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence7) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size8 = 0;
    const nk_uint8_t *items9 = nk_arena_get(nk_uint8_t, arena, sequence7,
                                            &size8);
    
    if (size8 > 16384)
        return NK_FALSE;
    nk_unused(items9);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Efi_SetVariable_val_res(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Efi_SetVariable_res *msg = (const
                                                     struct kl_core_Efi_SetVariable_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Efi_SetVariable_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FSUnsafe_Change_val_err(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FSUnsafe_Change_err *msg = (const
                                                     struct kl_core_FSUnsafe_Change_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FSUnsafe_Change_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FSUnsafe_Change_val_req(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FSUnsafe_Change_req *msg = (const
                                                     struct kl_core_FSUnsafe_Change_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FSUnsafe_Change_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FSUnsafe_Change_val_res(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FSUnsafe_Change_res *msg = (const
                                                     struct kl_core_FSUnsafe_Change_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_FSUnsafe_Change_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_Close_val_err(const struct nk_message *msg0,
                                                 const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_Close_err *msg = (const
                                              struct kl_core_FS_Close_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_Close_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_Close_val_req(const struct nk_message *msg0,
                                                 const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_Close_req *msg = (const
                                              struct kl_core_FS_Close_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_Close_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_Close_val_res(const struct nk_message *msg0,
                                                 const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_Close_res *msg = (const
                                              struct kl_core_FS_Close_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_FS_Close_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_Count_val_err(const struct nk_message *msg0,
                                                 const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_Count_err *msg = (const
                                              struct kl_core_FS_Count_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_Count_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_Count_val_req(const struct nk_message *msg0,
                                                 const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_Count_req *msg = (const
                                              struct kl_core_FS_Count_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_Count_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_Count_val_res(const struct nk_message *msg0,
                                                 const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_Count_res *msg = (const
                                              struct kl_core_FS_Count_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_FS_Count_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_GetFsSize_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_GetFsSize_err *msg = (const
                                                  struct kl_core_FS_GetFsSize_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_GetFsSize_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_GetFsSize_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_GetFsSize_req *msg = (const
                                                  struct kl_core_FS_GetFsSize_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_GetFsSize_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_GetFsSize_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_GetFsSize_res *msg = (const
                                                  struct kl_core_FS_GetFsSize_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_FS_GetFsSize_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_GetId_val_err(const struct nk_message *msg0,
                                                 const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_GetId_err *msg = (const
                                              struct kl_core_FS_GetId_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_GetId_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_GetId_val_req(const struct nk_message *msg0,
                                                 const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_GetId_req *msg = (const
                                              struct kl_core_FS_GetId_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_GetId_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_GetId_val_res(const struct nk_message *msg0,
                                                 const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_GetId_res *msg = (const
                                              struct kl_core_FS_GetId_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_FS_GetId_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_GetInfo_val_err(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_GetInfo_err *msg = (const
                                                struct kl_core_FS_GetInfo_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_GetInfo_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_GetInfo_val_req(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_GetInfo_req *msg = (const
                                                struct kl_core_FS_GetInfo_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_GetInfo_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_GetInfo_val_res(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_GetInfo_res *msg = (const
                                                struct kl_core_FS_GetInfo_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_FS_GetInfo_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->name;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_GetSize_val_err(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_GetSize_err *msg = (const
                                                struct kl_core_FS_GetSize_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_GetSize_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_GetSize_val_req(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_GetSize_req *msg = (const
                                                struct kl_core_FS_GetSize_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_GetSize_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_GetSize_val_res(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_GetSize_res *msg = (const
                                                struct kl_core_FS_GetSize_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_FS_GetSize_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_Open_val_err(const struct nk_message *msg0,
                                                const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_Open_err *msg = (const
                                             struct kl_core_FS_Open_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_Open_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_Open_val_req(const struct nk_message *msg0,
                                                const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_Open_req *msg = (const
                                             struct kl_core_FS_Open_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_Open_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->name;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_Open_val_res(const struct nk_message *msg0,
                                                const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_Open_res *msg = (const
                                             struct kl_core_FS_Open_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_FS_Open_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_Read_val_err(const struct nk_message *msg0,
                                                const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_Read_err *msg = (const
                                             struct kl_core_FS_Read_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_Read_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_Read_val_req(const struct nk_message *msg0,
                                                const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_Read_req *msg = (const
                                             struct kl_core_FS_Read_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_FS_Read_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_FS_Read_val_res(const struct nk_message *msg0,
                                                const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_FS_Read_res *msg = (const
                                             struct kl_core_FS_Read_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_FS_Read_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->data;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 4096)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_DebugWrite_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_DebugWrite_err *msg = (const
                                                    struct kl_core_HAL_DebugWrite_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_DebugWrite_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_DebugWrite_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_DebugWrite_req *msg = (const
                                                    struct kl_core_HAL_DebugWrite_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_DebugWrite_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->data;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_DebugWrite_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_DebugWrite_res *msg = (const
                                                    struct kl_core_HAL_DebugWrite_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_HAL_DebugWrite_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_FlushCache_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_FlushCache_err *msg = (const
                                                    struct kl_core_HAL_FlushCache_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_FlushCache_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_FlushCache_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_FlushCache_req *msg = (const
                                                    struct kl_core_HAL_FlushCache_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_FlushCache_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_FlushCache_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_FlushCache_res *msg = (const
                                                    struct kl_core_HAL_FlushCache_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_HAL_FlushCache_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_GetEntropy_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_GetEntropy_err *msg = (const
                                                    struct kl_core_HAL_GetEntropy_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_GetEntropy_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_GetEntropy_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_GetEntropy_req *msg = (const
                                                    struct kl_core_HAL_GetEntropy_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_GetEntropy_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_GetEntropy_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_GetEntropy_res *msg = (const
                                                    struct kl_core_HAL_GetEntropy_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_HAL_GetEntropy_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->buffer;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 32)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_GetEnv_val_err(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_GetEnv_err *msg = (const
                                                struct kl_core_HAL_GetEnv_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_GetEnv_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_GetEnv_val_req(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_GetEnv_req *msg = (const
                                                struct kl_core_HAL_GetEnv_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_GetEnv_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->name;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_GetEnv_val_res(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_GetEnv_res *msg = (const
                                                struct kl_core_HAL_GetEnv_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_HAL_GetEnv_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->value;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_GetPrivRegRange_val_err(const
                                                            struct nk_message *msg0,
                                                            const
                                                            struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_GetPrivRegRange_err *msg = (const
                                                         struct kl_core_HAL_GetPrivRegRange_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_GetPrivRegRange_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_GetPrivRegRange_val_req(const
                                                            struct nk_message *msg0,
                                                            const
                                                            struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_GetPrivRegRange_req *msg = (const
                                                         struct kl_core_HAL_GetPrivRegRange_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_GetPrivRegRange_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->regRange;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_GetPrivRegRange_val_res(const
                                                            struct nk_message *msg0,
                                                            const
                                                            struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_GetPrivRegRange_res *msg = (const
                                                         struct kl_core_HAL_GetPrivRegRange_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_HAL_GetPrivRegRange_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_GetPrivReg_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_GetPrivReg_err *msg = (const
                                                    struct kl_core_HAL_GetPrivReg_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_GetPrivReg_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_GetPrivReg_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_GetPrivReg_req *msg = (const
                                                    struct kl_core_HAL_GetPrivReg_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_GetPrivReg_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->reg;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_GetPrivReg_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_GetPrivReg_res *msg = (const
                                                    struct kl_core_HAL_GetPrivReg_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_HAL_GetPrivReg_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_SetPrivRegRange_val_err(const
                                                            struct nk_message *msg0,
                                                            const
                                                            struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_SetPrivRegRange_err *msg = (const
                                                         struct kl_core_HAL_SetPrivRegRange_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_SetPrivRegRange_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_SetPrivRegRange_val_req(const
                                                            struct nk_message *msg0,
                                                            const
                                                            struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_SetPrivRegRange_req *msg = (const
                                                         struct kl_core_HAL_SetPrivRegRange_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_SetPrivRegRange_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->regRange;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_SetPrivRegRange_val_res(const
                                                            struct nk_message *msg0,
                                                            const
                                                            struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_SetPrivRegRange_res *msg = (const
                                                         struct kl_core_HAL_SetPrivRegRange_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_HAL_SetPrivRegRange_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_SetPrivReg_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_SetPrivReg_err *msg = (const
                                                    struct kl_core_HAL_SetPrivReg_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_SetPrivReg_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_SetPrivReg_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_SetPrivReg_req *msg = (const
                                                    struct kl_core_HAL_SetPrivReg_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_HAL_SetPrivReg_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->reg;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_HAL_SetPrivReg_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_HAL_SetPrivReg_res *msg = (const
                                                    struct kl_core_HAL_SetPrivReg_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_HAL_SetPrivReg_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Alloc_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Alloc_err *msg = (const
                                                  struct kl_core_Handle_Alloc_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Alloc_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Alloc_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Alloc_req *msg = (const
                                                  struct kl_core_Handle_Alloc_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Alloc_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Alloc_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Alloc_res *msg = (const
                                                  struct kl_core_Handle_Alloc_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Alloc_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Close_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Close_err *msg = (const
                                                  struct kl_core_Handle_Close_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Close_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Close_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Close_req *msg = (const
                                                  struct kl_core_Handle_Close_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Close_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Close_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Close_res *msg = (const
                                                  struct kl_core_Handle_Close_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Close_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Connect_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Connect_err *msg = (const
                                                    struct kl_core_Handle_Connect_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Connect_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Connect_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Connect_req *msg = (const
                                                    struct kl_core_Handle_Connect_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Connect_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Connect_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Connect_res *msg = (const
                                                    struct kl_core_Handle_Connect_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Connect_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Copy_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Copy_err *msg = (const
                                                 struct kl_core_Handle_Copy_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Copy_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Copy_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Copy_req *msg = (const
                                                 struct kl_core_Handle_Copy_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Copy_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Copy_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Copy_res *msg = (const
                                                 struct kl_core_Handle_Copy_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Copy_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_CreateBadge_val_err(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_CreateBadge_err *msg = (const
                                                        struct kl_core_Handle_CreateBadge_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_CreateBadge_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_CreateBadge_val_req(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_CreateBadge_req *msg = (const
                                                        struct kl_core_Handle_CreateBadge_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_CreateBadge_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_CreateBadge_val_res(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_CreateBadge_res *msg = (const
                                                        struct kl_core_Handle_CreateBadge_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_CreateBadge_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_CreateUserObject_val_err(const
                                                                struct nk_message *msg0,
                                                                const
                                                                struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_CreateUserObject_err *msg = (const
                                                             struct kl_core_Handle_CreateUserObject_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_CreateUserObject_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_CreateUserObject_val_req(const
                                                                struct nk_message *msg0,
                                                                const
                                                                struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_CreateUserObject_req *msg = (const
                                                             struct kl_core_Handle_CreateUserObject_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_CreateUserObject_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_CreateUserObject_val_res(const
                                                                struct nk_message *msg0,
                                                                const
                                                                struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_CreateUserObject_res *msg = (const
                                                             struct kl_core_Handle_CreateUserObject_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_CreateUserObject_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Disconnect_val_err(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Disconnect_err *msg = (const
                                                       struct kl_core_Handle_Disconnect_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Disconnect_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Disconnect_val_req(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Disconnect_req *msg = (const
                                                       struct kl_core_Handle_Disconnect_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Disconnect_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Disconnect_val_res(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Disconnect_res *msg = (const
                                                       struct kl_core_Handle_Disconnect_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Disconnect_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Fini_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Fini_err *msg = (const
                                                 struct kl_core_Handle_Fini_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Fini_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Fini_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Fini_req *msg = (const
                                                 struct kl_core_Handle_Fini_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Fini_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Fini_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Fini_res *msg = (const
                                                 struct kl_core_Handle_Fini_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Fini_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Free_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Free_err *msg = (const
                                                 struct kl_core_Handle_Free_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Free_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Free_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Free_req *msg = (const
                                                 struct kl_core_Handle_Free_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Free_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Free_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Free_res *msg = (const
                                                 struct kl_core_Handle_Free_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Free_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_GetSidByHandle_val_err(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_GetSidByHandle_err *msg = (const
                                                           struct kl_core_Handle_GetSidByHandle_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_GetSidByHandle_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_GetSidByHandle_val_req(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_GetSidByHandle_req *msg = (const
                                                           struct kl_core_Handle_GetSidByHandle_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_GetSidByHandle_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_GetSidByHandle_val_res(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_GetSidByHandle_res *msg = (const
                                                           struct kl_core_Handle_GetSidByHandle_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_GetSidByHandle_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Init_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Init_err *msg = (const
                                                 struct kl_core_Handle_Init_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Init_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Init_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Init_req *msg = (const
                                                 struct kl_core_Handle_Init_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Init_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Init_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Init_res *msg = (const
                                                 struct kl_core_Handle_Init_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Init_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_RevokeSubtree_val_err(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_RevokeSubtree_err *msg = (const
                                                          struct kl_core_Handle_RevokeSubtree_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_RevokeSubtree_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_RevokeSubtree_val_req(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_RevokeSubtree_req *msg = (const
                                                          struct kl_core_Handle_RevokeSubtree_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_RevokeSubtree_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_RevokeSubtree_val_res(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_RevokeSubtree_res *msg = (const
                                                          struct kl_core_Handle_RevokeSubtree_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_RevokeSubtree_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Revoke_val_err(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Revoke_err *msg = (const
                                                   struct kl_core_Handle_Revoke_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Revoke_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Revoke_val_req(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Revoke_req *msg = (const
                                                   struct kl_core_Handle_Revoke_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Revoke_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_Revoke_val_res(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_Revoke_res *msg = (const
                                                   struct kl_core_Handle_Revoke_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_Revoke_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_SecurityConnect_val_err(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_SecurityConnect_err *msg = (const
                                                            struct kl_core_Handle_SecurityConnect_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_SecurityConnect_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_SecurityConnect_val_req(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_SecurityConnect_req *msg = (const
                                                            struct kl_core_Handle_SecurityConnect_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_SecurityConnect_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_SecurityConnect_val_res(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_SecurityConnect_res *msg = (const
                                                            struct kl_core_Handle_SecurityConnect_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_SecurityConnect_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_UidAlloc_val_err(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_UidAlloc_err *msg = (const
                                                     struct kl_core_Handle_UidAlloc_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_UidAlloc_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_UidAlloc_val_req(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_UidAlloc_req *msg = (const
                                                     struct kl_core_Handle_UidAlloc_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_UidAlloc_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_UidAlloc_val_res(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_UidAlloc_res *msg = (const
                                                     struct kl_core_Handle_UidAlloc_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_UidAlloc_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_UidFree_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_UidFree_err *msg = (const
                                                    struct kl_core_Handle_UidFree_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_UidFree_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_UidFree_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_UidFree_req *msg = (const
                                                    struct kl_core_Handle_UidFree_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Handle_UidFree_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Handle_UidFree_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Handle_UidFree_res *msg = (const
                                                    struct kl_core_Handle_UidFree_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Handle_UidFree_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_AttachToDomain_val_err(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_AttachToDomain_err *msg = (const
                                                          struct kl_core_IOMMU_AttachToDomain_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_AttachToDomain_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_AttachToDomain_val_req(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_AttachToDomain_req *msg = (const
                                                          struct kl_core_IOMMU_AttachToDomain_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_AttachToDomain_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_AttachToDomain_val_res(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_AttachToDomain_res *msg = (const
                                                          struct kl_core_IOMMU_AttachToDomain_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_AttachToDomain_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_Attach_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_Attach_err *msg = (const
                                                  struct kl_core_IOMMU_Attach_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_Attach_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_Attach_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_Attach_req *msg = (const
                                                  struct kl_core_IOMMU_Attach_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_Attach_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_Attach_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_Attach_res *msg = (const
                                                  struct kl_core_IOMMU_Attach_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_Attach_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_CreateDomain_val_err(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_CreateDomain_err *msg = (const
                                                        struct kl_core_IOMMU_CreateDomain_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_CreateDomain_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_CreateDomain_val_req(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_CreateDomain_req *msg = (const
                                                        struct kl_core_IOMMU_CreateDomain_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_CreateDomain_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_CreateDomain_val_res(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_CreateDomain_res *msg = (const
                                                        struct kl_core_IOMMU_CreateDomain_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_CreateDomain_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_DetachFromDomain_val_err(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_DetachFromDomain_err *msg = (const
                                                            struct kl_core_IOMMU_DetachFromDomain_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_DetachFromDomain_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_DetachFromDomain_val_req(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_DetachFromDomain_req *msg = (const
                                                            struct kl_core_IOMMU_DetachFromDomain_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_DetachFromDomain_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_DetachFromDomain_val_res(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_DetachFromDomain_res *msg = (const
                                                            struct kl_core_IOMMU_DetachFromDomain_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_DetachFromDomain_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_Detach_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_Detach_err *msg = (const
                                                  struct kl_core_IOMMU_Detach_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_Detach_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_Detach_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_Detach_req *msg = (const
                                                  struct kl_core_IOMMU_Detach_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_Detach_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IOMMU_Detach_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IOMMU_Detach_res *msg = (const
                                                  struct kl_core_IOMMU_Detach_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IOMMU_Detach_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_AttachIrq_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_AttachIrq_err *msg = (const
                                                  struct kl_core_IO_AttachIrq_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_AttachIrq_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_AttachIrq_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_AttachIrq_req *msg = (const
                                                  struct kl_core_IO_AttachIrq_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_AttachIrq_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_AttachIrq_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_AttachIrq_res *msg = (const
                                                  struct kl_core_IO_AttachIrq_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_AttachIrq_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_BeginDma_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_BeginDma_err *msg = (const
                                                 struct kl_core_IO_BeginDma_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_BeginDma_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_BeginDma_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_BeginDma_req *msg = (const
                                                 struct kl_core_IO_BeginDma_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_BeginDma_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_BeginDma_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_BeginDma_res *msg = (const
                                                 struct kl_core_IO_BeginDma_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_BeginDma_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_DetachIrq_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_DetachIrq_err *msg = (const
                                                  struct kl_core_IO_DetachIrq_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_DetachIrq_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_DetachIrq_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_DetachIrq_req *msg = (const
                                                  struct kl_core_IO_DetachIrq_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_DetachIrq_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_DetachIrq_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_DetachIrq_res *msg = (const
                                                  struct kl_core_IO_DetachIrq_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_DetachIrq_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_DisableIrq_val_err(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_DisableIrq_err *msg = (const
                                                   struct kl_core_IO_DisableIrq_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_DisableIrq_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_DisableIrq_val_req(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_DisableIrq_req *msg = (const
                                                   struct kl_core_IO_DisableIrq_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_DisableIrq_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_DisableIrq_val_res(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_DisableIrq_res *msg = (const
                                                   struct kl_core_IO_DisableIrq_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_DisableIrq_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_DmaGetInfo_val_err(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_DmaGetInfo_err *msg = (const
                                                   struct kl_core_IO_DmaGetInfo_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_DmaGetInfo_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_DmaGetInfo_val_req(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_DmaGetInfo_req *msg = (const
                                                   struct kl_core_IO_DmaGetInfo_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_DmaGetInfo_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_DmaGetInfo_val_res(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_DmaGetInfo_res *msg = (const
                                                   struct kl_core_IO_DmaGetInfo_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_DmaGetInfo_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->frames;
    
    if (nk_arena_validate(struct kl_core_IO_DmaFrame, arena, sequence0) !=
        NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const struct kl_core_IO_DmaFrame *items2 =
                                     nk_arena_get(struct kl_core_IO_DmaFrame,
                                                  arena, sequence0, &size1);
    
    if (size1 > 32)
        return NK_FALSE;
    if (((nk_uintptr_t) items2 & (nk_alignof(struct kl_core_IO_DmaFrame) -
                                  1)) != 0)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_DmaGetPhysInfo_val_err(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_DmaGetPhysInfo_err *msg = (const
                                                       struct kl_core_IO_DmaGetPhysInfo_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_DmaGetPhysInfo_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_DmaGetPhysInfo_val_req(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_DmaGetPhysInfo_req *msg = (const
                                                       struct kl_core_IO_DmaGetPhysInfo_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_DmaGetPhysInfo_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_DmaGetPhysInfo_val_res(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_DmaGetPhysInfo_res *msg = (const
                                                       struct kl_core_IO_DmaGetPhysInfo_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_DmaGetPhysInfo_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->frames;
    
    if (nk_arena_validate(struct kl_core_IO_DmaFrame, arena, sequence0) !=
        NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const struct kl_core_IO_DmaFrame *items2 =
                                     nk_arena_get(struct kl_core_IO_DmaFrame,
                                                  arena, sequence0, &size1);
    
    if (size1 > 32)
        return NK_FALSE;
    if (((nk_uintptr_t) items2 & (nk_alignof(struct kl_core_IO_DmaFrame) -
                                  1)) != 0)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_EnableIrq_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_EnableIrq_err *msg = (const
                                                  struct kl_core_IO_EnableIrq_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_EnableIrq_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_EnableIrq_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_EnableIrq_req *msg = (const
                                                  struct kl_core_IO_EnableIrq_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_EnableIrq_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_EnableIrq_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_EnableIrq_res *msg = (const
                                                  struct kl_core_IO_EnableIrq_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_EnableIrq_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_MapDma_val_err(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_MapDma_err *msg = (const
                                               struct kl_core_IO_MapDma_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_MapDma_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_MapDma_val_req(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_MapDma_req *msg = (const
                                               struct kl_core_IO_MapDma_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_MapDma_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_MapDma_val_res(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_MapDma_res *msg = (const
                                               struct kl_core_IO_MapDma_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_MapDma_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_MapMem_val_err(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_MapMem_err *msg = (const
                                               struct kl_core_IO_MapMem_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_MapMem_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_MapMem_val_req(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_MapMem_req *msg = (const
                                               struct kl_core_IO_MapMem_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_MapMem_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_MapMem_val_res(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_MapMem_res *msg = (const
                                               struct kl_core_IO_MapMem_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_MapMem_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_ModifyDma_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_ModifyDma_err *msg = (const
                                                  struct kl_core_IO_ModifyDma_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_ModifyDma_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_ModifyDma_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_ModifyDma_req *msg = (const
                                                  struct kl_core_IO_ModifyDma_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_ModifyDma_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_ModifyDma_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_ModifyDma_res *msg = (const
                                                  struct kl_core_IO_ModifyDma_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_ModifyDma_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_PermitPort_val_err(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_PermitPort_err *msg = (const
                                                   struct kl_core_IO_PermitPort_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_PermitPort_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_PermitPort_val_req(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_PermitPort_req *msg = (const
                                                   struct kl_core_IO_PermitPort_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_PermitPort_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_PermitPort_val_res(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_PermitPort_res *msg = (const
                                                   struct kl_core_IO_PermitPort_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_PermitPort_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RegisterDma_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RegisterDma_err *msg = (const
                                                    struct kl_core_IO_RegisterDma_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_RegisterDma_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RegisterDma_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RegisterDma_req *msg = (const
                                                    struct kl_core_IO_RegisterDma_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_RegisterDma_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RegisterDma_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RegisterDma_res *msg = (const
                                                    struct kl_core_IO_RegisterDma_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_RegisterDma_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RegisterIrq_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RegisterIrq_err *msg = (const
                                                    struct kl_core_IO_RegisterIrq_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_RegisterIrq_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RegisterIrq_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RegisterIrq_req *msg = (const
                                                    struct kl_core_IO_RegisterIrq_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_RegisterIrq_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RegisterIrq_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RegisterIrq_res *msg = (const
                                                    struct kl_core_IO_RegisterIrq_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_RegisterIrq_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RegisterMmio_val_err(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RegisterMmio_err *msg = (const
                                                     struct kl_core_IO_RegisterMmio_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_RegisterMmio_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RegisterMmio_val_req(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RegisterMmio_req *msg = (const
                                                     struct kl_core_IO_RegisterMmio_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_RegisterMmio_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RegisterMmio_val_res(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RegisterMmio_res *msg = (const
                                                     struct kl_core_IO_RegisterMmio_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_RegisterMmio_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RegisterPort_val_err(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RegisterPort_err *msg = (const
                                                     struct kl_core_IO_RegisterPort_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_RegisterPort_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RegisterPort_val_req(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RegisterPort_req *msg = (const
                                                     struct kl_core_IO_RegisterPort_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_RegisterPort_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RegisterPort_val_res(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RegisterPort_res *msg = (const
                                                     struct kl_core_IO_RegisterPort_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_RegisterPort_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RevokeResource_val_err(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RevokeResource_err *msg = (const
                                                       struct kl_core_IO_RevokeResource_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_RevokeResource_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RevokeResource_val_req(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RevokeResource_req *msg = (const
                                                       struct kl_core_IO_RevokeResource_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IO_RevokeResource_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IO_RevokeResource_val_res(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IO_RevokeResource_res *msg = (const
                                                       struct kl_core_IO_RevokeResource_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IO_RevokeResource_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IPC_ClearInterrupt_val_err(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IPC_ClearInterrupt_err *msg = (const
                                                        struct kl_core_IPC_ClearInterrupt_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IPC_ClearInterrupt_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IPC_ClearInterrupt_val_req(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IPC_ClearInterrupt_req *msg = (const
                                                        struct kl_core_IPC_ClearInterrupt_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IPC_ClearInterrupt_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IPC_ClearInterrupt_val_res(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IPC_ClearInterrupt_res *msg = (const
                                                        struct kl_core_IPC_ClearInterrupt_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IPC_ClearInterrupt_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IPC_CreateSyncObject_val_err(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IPC_CreateSyncObject_err *msg = (const
                                                          struct kl_core_IPC_CreateSyncObject_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IPC_CreateSyncObject_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IPC_CreateSyncObject_val_req(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IPC_CreateSyncObject_req *msg = (const
                                                          struct kl_core_IPC_CreateSyncObject_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IPC_CreateSyncObject_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IPC_CreateSyncObject_val_res(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IPC_CreateSyncObject_res *msg = (const
                                                          struct kl_core_IPC_CreateSyncObject_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IPC_CreateSyncObject_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IPC_SetInterrupt_val_err(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IPC_SetInterrupt_err *msg = (const
                                                      struct kl_core_IPC_SetInterrupt_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IPC_SetInterrupt_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IPC_SetInterrupt_val_req(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IPC_SetInterrupt_req *msg = (const
                                                      struct kl_core_IPC_SetInterrupt_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_IPC_SetInterrupt_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_IPC_SetInterrupt_val_res(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_IPC_SetInterrupt_res *msg = (const
                                                      struct kl_core_IPC_SetInterrupt_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_IPC_SetInterrupt_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Log_FetchMessages_val_err(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Log_FetchMessages_err *msg = (const
                                                       struct kl_core_Log_FetchMessages_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Log_FetchMessages_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Log_FetchMessages_val_req(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Log_FetchMessages_req *msg = (const
                                                       struct kl_core_Log_FetchMessages_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Log_FetchMessages_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Log_FetchMessages_val_res(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Log_FetchMessages_res *msg = (const
                                                       struct kl_core_Log_FetchMessages_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Log_FetchMessages_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->data;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 65536)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Log_GetMessagesHandle_val_err(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Log_GetMessagesHandle_err *msg = (const
                                                           struct kl_core_Log_GetMessagesHandle_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Log_GetMessagesHandle_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Log_GetMessagesHandle_val_req(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Log_GetMessagesHandle_req *msg = (const
                                                           struct kl_core_Log_GetMessagesHandle_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Log_GetMessagesHandle_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Log_GetMessagesHandle_val_res(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Log_GetMessagesHandle_res *msg = (const
                                                           struct kl_core_Log_GetMessagesHandle_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Log_GetMessagesHandle_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Log_Handoff_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Log_Handoff_err *msg = (const
                                                 struct kl_core_Log_Handoff_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Log_Handoff_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Log_Handoff_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Log_Handoff_req *msg = (const
                                                 struct kl_core_Log_Handoff_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Log_Handoff_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Log_Handoff_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Log_Handoff_res *msg = (const
                                                 struct kl_core_Log_Handoff_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Log_Handoff_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_Create_val_err(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_Create_err *msg = (const
                                                   struct kl_core_Notice_Create_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_Create_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_Create_val_req(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_Create_req *msg = (const
                                                   struct kl_core_Notice_Create_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_Create_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_Create_val_res(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_Create_res *msg = (const
                                                   struct kl_core_Notice_Create_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Notice_Create_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_DropAndWake_val_err(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_DropAndWake_err *msg = (const
                                                        struct kl_core_Notice_DropAndWake_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_DropAndWake_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_DropAndWake_val_req(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_DropAndWake_req *msg = (const
                                                        struct kl_core_Notice_DropAndWake_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_DropAndWake_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_DropAndWake_val_res(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_DropAndWake_res *msg = (const
                                                        struct kl_core_Notice_DropAndWake_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Notice_DropAndWake_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_GetEvent_val_err(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_GetEvent_err *msg = (const
                                                     struct kl_core_Notice_GetEvent_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_GetEvent_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_GetEvent_val_req(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_GetEvent_req *msg = (const
                                                     struct kl_core_Notice_GetEvent_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_GetEvent_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_GetEvent_val_res(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_GetEvent_res *msg = (const
                                                     struct kl_core_Notice_GetEvent_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Notice_GetEvent_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->events;
    
    if (nk_arena_validate(struct kl_core_Notice_EventDescr, arena, sequence0) !=
        NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const struct kl_core_Notice_EventDescr *items2 =
                                           nk_arena_get(struct kl_core_Notice_EventDescr,
                                                        arena, sequence0,
                                                        &size1);
    
    if (size1 > 128)
        return NK_FALSE;
    if (((nk_uintptr_t) items2 & (nk_alignof(struct kl_core_Notice_EventDescr) -
                                  1)) != 0)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_SetObjectEvent_val_err(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_SetObjectEvent_err *msg = (const
                                                           struct kl_core_Notice_SetObjectEvent_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_SetObjectEvent_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_SetObjectEvent_val_req(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_SetObjectEvent_req *msg = (const
                                                           struct kl_core_Notice_SetObjectEvent_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_SetObjectEvent_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_SetObjectEvent_val_res(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_SetObjectEvent_res *msg = (const
                                                           struct kl_core_Notice_SetObjectEvent_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Notice_SetObjectEvent_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_SubscribeToObject_val_err(const
                                                                 struct nk_message *msg0,
                                                                 const
                                                                 struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_SubscribeToObject_err *msg = (const
                                                              struct kl_core_Notice_SubscribeToObject_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_SubscribeToObject_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_SubscribeToObject_val_req(const
                                                                 struct nk_message *msg0,
                                                                 const
                                                                 struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_SubscribeToObject_req *msg = (const
                                                              struct kl_core_Notice_SubscribeToObject_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_SubscribeToObject_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_SubscribeToObject_val_res(const
                                                                 struct nk_message *msg0,
                                                                 const
                                                                 struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_SubscribeToObject_res *msg = (const
                                                              struct kl_core_Notice_SubscribeToObject_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Notice_SubscribeToObject_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_UnsubscribeFromEvent_val_err(const
                                                                    struct nk_message *msg0,
                                                                    const
                                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_UnsubscribeFromEvent_err *msg = (const
                                                                 struct kl_core_Notice_UnsubscribeFromEvent_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_UnsubscribeFromEvent_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_UnsubscribeFromEvent_val_req(const
                                                                    struct nk_message *msg0,
                                                                    const
                                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_UnsubscribeFromEvent_req *msg = (const
                                                                 struct kl_core_Notice_UnsubscribeFromEvent_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_UnsubscribeFromEvent_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_UnsubscribeFromEvent_val_res(const
                                                                    struct nk_message *msg0,
                                                                    const
                                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_UnsubscribeFromEvent_res *msg = (const
                                                                 struct kl_core_Notice_UnsubscribeFromEvent_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Notice_UnsubscribeFromEvent_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_UnsubscribeFromObject_val_err(const
                                                                     struct nk_message *msg0,
                                                                     const
                                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_UnsubscribeFromObject_err *msg = (const
                                                                  struct kl_core_Notice_UnsubscribeFromObject_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_UnsubscribeFromObject_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_UnsubscribeFromObject_val_req(const
                                                                     struct nk_message *msg0,
                                                                     const
                                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_UnsubscribeFromObject_req *msg = (const
                                                                  struct kl_core_Notice_UnsubscribeFromObject_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Notice_UnsubscribeFromObject_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Notice_UnsubscribeFromObject_val_res(const
                                                                     struct nk_message *msg0,
                                                                     const
                                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Notice_UnsubscribeFromObject_res *msg = (const
                                                                  struct kl_core_Notice_UnsubscribeFromObject_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Notice_UnsubscribeFromObject_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_PM_GetCpusOnline_val_err(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_PM_GetCpusOnline_err *msg = (const
                                                      struct kl_core_PM_GetCpusOnline_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_PM_GetCpusOnline_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_PM_GetCpusOnline_val_req(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_PM_GetCpusOnline_req *msg = (const
                                                      struct kl_core_PM_GetCpusOnline_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_PM_GetCpusOnline_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_PM_GetCpusOnline_val_res(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_PM_GetCpusOnline_res *msg = (const
                                                      struct kl_core_PM_GetCpusOnline_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_PM_GetCpusOnline_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_PM_Request_val_err(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_PM_Request_err *msg = (const
                                                struct kl_core_PM_Request_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_PM_Request_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_PM_Request_val_req(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_PM_Request_req *msg = (const
                                                struct kl_core_PM_Request_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_PM_Request_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_PM_Request_val_res(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_PM_Request_res *msg = (const
                                                struct kl_core_PM_Request_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_PM_Request_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_PM_SetCpusOnline_val_err(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_PM_SetCpusOnline_err *msg = (const
                                                      struct kl_core_PM_SetCpusOnline_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_PM_SetCpusOnline_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_PM_SetCpusOnline_val_req(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_PM_SetCpusOnline_req *msg = (const
                                                      struct kl_core_PM_SetCpusOnline_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_PM_SetCpusOnline_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_PM_SetCpusOnline_val_res(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_PM_SetCpusOnline_res *msg = (const
                                                      struct kl_core_PM_SetCpusOnline_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_PM_SetCpusOnline_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_FlushGcovFile_val_err(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_FlushGcovFile_err *msg = (const
                                                            struct kl_core_Profiler_FlushGcovFile_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_FlushGcovFile_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_FlushGcovFile_val_req(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_FlushGcovFile_req *msg = (const
                                                            struct kl_core_Profiler_FlushGcovFile_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_FlushGcovFile_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->name;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_FlushGcovFile_val_res(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_FlushGcovFile_res *msg = (const
                                                            struct kl_core_Profiler_FlushGcovFile_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_FlushGcovFile_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_FlushGcov_val_err(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_FlushGcov_err *msg = (const
                                                        struct kl_core_Profiler_FlushGcov_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_FlushGcov_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_FlushGcov_val_req(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_FlushGcov_req *msg = (const
                                                        struct kl_core_Profiler_FlushGcov_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_FlushGcov_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_FlushGcov_val_res(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_FlushGcov_res *msg = (const
                                                        struct kl_core_Profiler_FlushGcov_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_FlushGcov_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_GetCounters_val_err(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_GetCounters_err *msg = (const
                                                          struct kl_core_Profiler_GetCounters_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_GetCounters_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_GetCounters_val_req(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_GetCounters_req *msg = (const
                                                          struct kl_core_Profiler_GetCounters_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_GetCounters_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->prefix;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    
    const nk_ptr_t *sequence3 = &msg->names;
    
    if (nk_arena_validate(nk_ptr_t, arena, sequence3) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size4 = 0;
    const nk_ptr_t *items5 = nk_arena_get(nk_ptr_t, arena, sequence3, &size4);
    
    if (size4 > 64)
        return NK_FALSE;
    if (((nk_uintptr_t) items5 & (nk_alignof(nk_ptr_t) - 1)) != 0)
        return NK_FALSE;
    for (nk_size_t i6 = 0; i6 < size4; i6++) {
        const nk_ptr_t *string7 = items5 + i6;
        
        if (nk_arena_validate(nk_uint8_t, arena, string7) != NK_EOK)
            return NK_FALSE;
        
        nk_size_t size8 = 0;
        const nk_uint8_t *items9 = nk_arena_get(nk_uint8_t, arena, string7,
                                                &size8);
        
        if (size8 > 128)
            return NK_FALSE;
        if (kss_validate_utf8(items9, size8) != NK_TRUE)
            return NK_FALSE;
    }
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_GetCounters_val_res(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_GetCounters_res *msg = (const
                                                          struct kl_core_Profiler_GetCounters_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_GetCounters_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->values;
    
    if (nk_arena_validate(struct kl_core_Profiler_PerfCounterValue, arena,
                          sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const struct kl_core_Profiler_PerfCounterValue *items2 =
                                                   nk_arena_get(struct kl_core_Profiler_PerfCounterValue,
                                                                arena,
                                                                sequence0,
                                                                &size1);
    
    if (size1 > 64)
        return NK_FALSE;
    if (((nk_uintptr_t) items2 &
         (nk_alignof(struct kl_core_Profiler_PerfCounterValue) - 1)) != 0)
        return NK_FALSE;
    for (nk_size_t i3 = 0; i3 < size1; i3++) {
        const struct kl_core_Profiler_PerfCounterValue *union4 = items2 + i3;
        
        if (union4->tag >= kl_core_Profiler_PerfCounterValue_tag_max)
            return NK_FALSE;
    }
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_GetCoverageData_val_err(const
                                                                 struct nk_message *msg0,
                                                                 const
                                                                 struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_GetCoverageData_err *msg = (const
                                                              struct kl_core_Profiler_GetCoverageData_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_GetCoverageData_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_GetCoverageData_val_req(const
                                                                 struct nk_message *msg0,
                                                                 const
                                                                 struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_GetCoverageData_req *msg = (const
                                                              struct kl_core_Profiler_GetCoverageData_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_GetCoverageData_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_GetCoverageData_val_res(const
                                                                 struct nk_message *msg0,
                                                                 const
                                                                 struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_GetCoverageData_res *msg = (const
                                                              struct kl_core_Profiler_GetCoverageData_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_GetCoverageData_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->buf;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 65536)
        return NK_FALSE;
    nk_unused(items2);
    
    const nk_ptr_t *string4 = &msg->name;
    
    if (nk_arena_validate(nk_uint8_t, arena, string4) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size5 = 0;
    const nk_uint8_t *items6 = nk_arena_get(nk_uint8_t, arena, string4, &size5);
    
    if (size5 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items6, size5) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_KcovAlloc_val_err(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_KcovAlloc_err *msg = (const
                                                        struct kl_core_Profiler_KcovAlloc_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_KcovAlloc_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_KcovAlloc_val_req(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_KcovAlloc_req *msg = (const
                                                        struct kl_core_Profiler_KcovAlloc_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_KcovAlloc_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_KcovAlloc_val_res(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_KcovAlloc_res *msg = (const
                                                        struct kl_core_Profiler_KcovAlloc_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_KcovAlloc_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_KcovFree_val_err(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_KcovFree_err *msg = (const
                                                       struct kl_core_Profiler_KcovFree_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_KcovFree_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_KcovFree_val_req(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_KcovFree_req *msg = (const
                                                       struct kl_core_Profiler_KcovFree_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_KcovFree_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_KcovFree_val_res(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_KcovFree_res *msg = (const
                                                       struct kl_core_Profiler_KcovFree_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_KcovFree_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_KcovStart_val_err(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_KcovStart_err *msg = (const
                                                        struct kl_core_Profiler_KcovStart_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_KcovStart_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_KcovStart_val_req(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_KcovStart_req *msg = (const
                                                        struct kl_core_Profiler_KcovStart_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_KcovStart_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_KcovStart_val_res(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_KcovStart_res *msg = (const
                                                        struct kl_core_Profiler_KcovStart_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_KcovStart_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_KcovStop_val_err(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_KcovStop_err *msg = (const
                                                       struct kl_core_Profiler_KcovStop_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_KcovStop_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_KcovStop_val_req(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_KcovStop_req *msg = (const
                                                       struct kl_core_Profiler_KcovStop_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_KcovStop_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_KcovStop_val_res(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_KcovStop_res *msg = (const
                                                       struct kl_core_Profiler_KcovStop_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_KcovStop_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_LoadSegInfo_val_err(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_LoadSegInfo_err *msg = (const
                                                          struct kl_core_Profiler_LoadSegInfo_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_LoadSegInfo_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_LoadSegInfo_val_req(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_LoadSegInfo_req *msg = (const
                                                          struct kl_core_Profiler_LoadSegInfo_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_LoadSegInfo_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->buildId;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 20)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_LoadSegInfo_val_res(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_LoadSegInfo_res *msg = (const
                                                          struct kl_core_Profiler_LoadSegInfo_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_LoadSegInfo_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_ObjectGetStat_val_err(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_ObjectGetStat_err *msg = (const
                                                            struct kl_core_Profiler_ObjectGetStat_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_ObjectGetStat_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_ObjectGetStat_val_req(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_ObjectGetStat_req *msg = (const
                                                            struct kl_core_Profiler_ObjectGetStat_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_ObjectGetStat_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->names;
    
    if (nk_arena_validate(nk_ptr_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_ptr_t *items2 = nk_arena_get(nk_ptr_t, arena, sequence0, &size1);
    
    if (size1 > 64)
        return NK_FALSE;
    if (((nk_uintptr_t) items2 & (nk_alignof(nk_ptr_t) - 1)) != 0)
        return NK_FALSE;
    for (nk_size_t i3 = 0; i3 < size1; i3++) {
        const nk_ptr_t *string4 = items2 + i3;
        
        if (nk_arena_validate(nk_uint8_t, arena, string4) != NK_EOK)
            return NK_FALSE;
        
        nk_size_t size5 = 0;
        const nk_uint8_t *items6 = nk_arena_get(nk_uint8_t, arena, string4,
                                                &size5);
        
        if (size5 > 128)
            return NK_FALSE;
        if (kss_validate_utf8(items6, size5) != NK_TRUE)
            return NK_FALSE;
    }
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_ObjectGetStat_val_res(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_ObjectGetStat_res *msg = (const
                                                            struct kl_core_Profiler_ObjectGetStat_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_ObjectGetStat_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->values;
    
    if (nk_arena_validate(struct kl_core_Profiler_PerfCounterValue, arena,
                          sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const struct kl_core_Profiler_PerfCounterValue *items2 =
                                                   nk_arena_get(struct kl_core_Profiler_PerfCounterValue,
                                                                arena,
                                                                sequence0,
                                                                &size1);
    
    if (size1 > 64)
        return NK_FALSE;
    if (((nk_uintptr_t) items2 &
         (nk_alignof(struct kl_core_Profiler_PerfCounterValue) - 1)) != 0)
        return NK_FALSE;
    for (nk_size_t i3 = 0; i3 < size1; i3++) {
        const struct kl_core_Profiler_PerfCounterValue *union4 = items2 + i3;
        
        if (union4->tag >= kl_core_Profiler_PerfCounterValue_tag_max)
            return NK_FALSE;
    }
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingAddPidToList_val_err(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingAddPidToList_err *msg = (const
                                                                   struct kl_core_Profiler_SamplingAddPidToList_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingAddPidToList_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingAddPidToList_val_req(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingAddPidToList_req *msg = (const
                                                                   struct kl_core_Profiler_SamplingAddPidToList_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingAddPidToList_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingAddPidToList_val_res(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingAddPidToList_res *msg = (const
                                                                   struct kl_core_Profiler_SamplingAddPidToList_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingAddPidToList_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingClearPidList_val_err(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingClearPidList_err *msg = (const
                                                                   struct kl_core_Profiler_SamplingClearPidList_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingClearPidList_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingClearPidList_val_req(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingClearPidList_req *msg = (const
                                                                   struct kl_core_Profiler_SamplingClearPidList_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingClearPidList_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingClearPidList_val_res(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingClearPidList_res *msg = (const
                                                                   struct kl_core_Profiler_SamplingClearPidList_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingClearPidList_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingRead_val_err(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingRead_err *msg = (const
                                                           struct kl_core_Profiler_SamplingRead_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingRead_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingRead_val_req(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingRead_req *msg = (const
                                                           struct kl_core_Profiler_SamplingRead_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingRead_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingRead_val_res(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingRead_res *msg = (const
                                                           struct kl_core_Profiler_SamplingRead_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingRead_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingStart_val_err(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingStart_err *msg = (const
                                                            struct kl_core_Profiler_SamplingStart_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingStart_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingStart_val_req(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingStart_req *msg = (const
                                                            struct kl_core_Profiler_SamplingStart_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingStart_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->cpus;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 128)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingStart_val_res(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingStart_res *msg = (const
                                                            struct kl_core_Profiler_SamplingStart_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingStart_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingStop_val_err(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingStop_err *msg = (const
                                                           struct kl_core_Profiler_SamplingStop_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingStop_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingStop_val_req(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingStop_req *msg = (const
                                                           struct kl_core_Profiler_SamplingStop_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingStop_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_SamplingStop_val_res(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_SamplingStop_res *msg = (const
                                                           struct kl_core_Profiler_SamplingStop_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_SamplingStop_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_UnloadSegInfo_val_err(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_UnloadSegInfo_err *msg = (const
                                                            struct kl_core_Profiler_UnloadSegInfo_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_UnloadSegInfo_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_UnloadSegInfo_val_req(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_UnloadSegInfo_req *msg = (const
                                                            struct kl_core_Profiler_UnloadSegInfo_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_UnloadSegInfo_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Profiler_UnloadSegInfo_val_res(const
                                                               struct nk_message *msg0,
                                                               const
                                                               struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Profiler_UnloadSegInfo_res *msg = (const
                                                            struct kl_core_Profiler_UnloadSegInfo_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Profiler_UnloadSegInfo_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Sync_Wait_val_err(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Sync_Wait_err *msg = (const
                                               struct kl_core_Sync_Wait_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Sync_Wait_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Sync_Wait_val_req(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Sync_Wait_req *msg = (const
                                               struct kl_core_Sync_Wait_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Sync_Wait_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Sync_Wait_val_res(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Sync_Wait_res *msg = (const
                                               struct kl_core_Sync_Wait_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Sync_Wait_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Sync_Wake_val_err(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Sync_Wake_err *msg = (const
                                               struct kl_core_Sync_Wake_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Sync_Wake_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Sync_Wake_val_req(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Sync_Wake_req *msg = (const
                                               struct kl_core_Sync_Wake_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Sync_Wake_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Sync_Wake_val_res(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Sync_Wake_res *msg = (const
                                               struct kl_core_Sync_Wake_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Sync_Wake_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_DisableHandleTracing_val_err(const
                                                                       struct nk_message *msg0,
                                                                       const
                                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_DisableHandleTracing_err *msg = (const
                                                                    struct kl_core_TaskDebug_DisableHandleTracing_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_DisableHandleTracing_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_DisableHandleTracing_val_req(const
                                                                       struct nk_message *msg0,
                                                                       const
                                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_DisableHandleTracing_req *msg = (const
                                                                    struct kl_core_TaskDebug_DisableHandleTracing_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_DisableHandleTracing_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_DisableHandleTracing_val_res(const
                                                                       struct nk_message *msg0,
                                                                       const
                                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_DisableHandleTracing_res *msg = (const
                                                                    struct kl_core_TaskDebug_DisableHandleTracing_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_DisableHandleTracing_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_EnableHandleTracing_val_err(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_EnableHandleTracing_err *msg = (const
                                                                   struct kl_core_TaskDebug_EnableHandleTracing_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_EnableHandleTracing_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_EnableHandleTracing_val_req(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_EnableHandleTracing_req *msg = (const
                                                                   struct kl_core_TaskDebug_EnableHandleTracing_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_EnableHandleTracing_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_EnableHandleTracing_val_res(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_EnableHandleTracing_res *msg = (const
                                                                   struct kl_core_TaskDebug_EnableHandleTracing_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_EnableHandleTracing_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_GetHandleInfo_val_err(const
                                                                struct nk_message *msg0,
                                                                const
                                                                struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_GetHandleInfo_err *msg = (const
                                                             struct kl_core_TaskDebug_GetHandleInfo_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_GetHandleInfo_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_GetHandleInfo_val_req(const
                                                                struct nk_message *msg0,
                                                                const
                                                                struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_GetHandleInfo_req *msg = (const
                                                             struct kl_core_TaskDebug_GetHandleInfo_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_GetHandleInfo_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_GetHandleInfo_val_res(const
                                                                struct nk_message *msg0,
                                                                const
                                                                struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_GetHandleInfo_res *msg = (const
                                                             struct kl_core_TaskDebug_GetHandleInfo_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_GetHandleInfo_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const struct kl_core_TaskDebug_HandleInfo *struct0 = &msg->info;
    const nk_ptr_t *string2 = &struct0->owner;
    
    if (nk_arena_validate(nk_uint8_t, arena, string2) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size3 = 0;
    const nk_uint8_t *items4 = nk_arena_get(nk_uint8_t, arena, string2, &size3);
    
    if (size3 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items4, size3) != NK_TRUE)
        return NK_FALSE;
    
    const nk_ptr_t *sequence5 = &struct0->traceBuf;
    
    if (nk_arena_validate(nk_uint64_t, arena, sequence5) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size6 = 0;
    const nk_uint64_t *items7 = nk_arena_get(nk_uint64_t, arena, sequence5,
                                             &size6);
    
    if (size6 > 1024)
        return NK_FALSE;
    if (((nk_uintptr_t) items7 & (nk_alignof(nk_uint64_t) - 1)) != 0)
        return NK_FALSE;
    nk_unused(items7);
    
    const nk_ptr_t *string9 = &struct0->traceCreator;
    
    if (nk_arena_validate(nk_uint8_t, arena, string9) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size10 = 0;
    const nk_uint8_t *items11 = nk_arena_get(nk_uint8_t, arena, string9,
                                             &size10);
    
    if (size10 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items11, size10) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_GetHandlesCount_val_err(const
                                                                  struct nk_message *msg0,
                                                                  const
                                                                  struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_GetHandlesCount_err *msg = (const
                                                               struct kl_core_TaskDebug_GetHandlesCount_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_GetHandlesCount_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_GetHandlesCount_val_req(const
                                                                  struct nk_message *msg0,
                                                                  const
                                                                  struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_GetHandlesCount_req *msg = (const
                                                               struct kl_core_TaskDebug_GetHandlesCount_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_GetHandlesCount_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_GetHandlesCount_val_res(const
                                                                  struct nk_message *msg0,
                                                                  const
                                                                  struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_GetHandlesCount_res *msg = (const
                                                               struct kl_core_TaskDebug_GetHandlesCount_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_GetHandlesCount_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_GetHandles_val_err(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_GetHandles_err *msg = (const
                                                          struct kl_core_TaskDebug_GetHandles_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_GetHandles_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_GetHandles_val_req(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_GetHandles_req *msg = (const
                                                          struct kl_core_TaskDebug_GetHandles_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_GetHandles_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_TaskDebug_GetHandles_val_res(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_TaskDebug_GetHandles_res *msg = (const
                                                          struct kl_core_TaskDebug_GetHandles_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_TaskDebug_GetHandles_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_Create_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_Create_err *msg = (const
                                                 struct kl_core_Task_Create_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_Create_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_Create_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_Create_req *msg = (const
                                                 struct kl_core_Task_Create_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_Create_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->name;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    
    const nk_ptr_t *string3 = &msg->eiid;
    
    if (nk_arena_validate(nk_uint8_t, arena, string3) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size4 = 0;
    const nk_uint8_t *items5 = nk_arena_get(nk_uint8_t, arena, string3, &size4);
    
    if (size4 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items5, size4) != NK_TRUE)
        return NK_FALSE;
    
    const nk_ptr_t *string6 = &msg->path;
    
    if (nk_arena_validate(nk_uint8_t, arena, string6) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size7 = 0;
    const nk_uint8_t *items8 = nk_arena_get(nk_uint8_t, arena, string6, &size7);
    
    if (size7 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items8, size7) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_Create_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_Create_res *msg = (const
                                                 struct kl_core_Task_Create_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_Create_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_Exit_val_err(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_Exit_err *msg = (const
                                               struct kl_core_Task_Exit_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_Exit_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_Exit_val_req(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_Exit_req *msg = (const
                                               struct kl_core_Task_Exit_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_Exit_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_Exit_val_res(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_Exit_res *msg = (const
                                               struct kl_core_Task_Exit_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_Exit_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_FreeSelfEnv_val_err(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_FreeSelfEnv_err *msg = (const
                                                      struct kl_core_Task_FreeSelfEnv_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_FreeSelfEnv_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_FreeSelfEnv_val_req(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_FreeSelfEnv_req *msg = (const
                                                      struct kl_core_Task_FreeSelfEnv_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_FreeSelfEnv_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_FreeSelfEnv_val_res(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_FreeSelfEnv_res *msg = (const
                                                      struct kl_core_Task_FreeSelfEnv_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_FreeSelfEnv_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetElfSyms_val_err(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetElfSyms_err *msg = (const
                                                     struct kl_core_Task_GetElfSyms_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetElfSyms_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetElfSyms_val_req(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetElfSyms_req *msg = (const
                                                     struct kl_core_Task_GetElfSyms_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetElfSyms_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetElfSyms_val_res(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetElfSyms_res *msg = (const
                                                     struct kl_core_Task_GetElfSyms_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetElfSyms_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetExitInfo_val_err(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetExitInfo_err *msg = (const
                                                      struct kl_core_Task_GetExitInfo_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetExitInfo_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetExitInfo_val_req(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetExitInfo_req *msg = (const
                                                      struct kl_core_Task_GetExitInfo_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetExitInfo_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetExitInfo_val_res(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetExitInfo_res *msg = (const
                                                      struct kl_core_Task_GetExitInfo_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetExitInfo_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const struct kl_core_Task_ExitInfo *union0 = &msg->info;
    
    switch (union0->tag) {
        
      case kl_core_Task_ExitInfo_code_tag:
        {
            break;
        }
        
      case kl_core_Task_ExitInfo_exc_tag:
        {
            const struct kl_core_Task_ExceptionInfo *struct1 =
                                                    &union0->data.exc;
            const nk_ptr_t *sequence2 = &struct1->frame;
            
            if (nk_arena_validate(nk_uint8_t, arena, sequence2) != NK_EOK)
                return NK_FALSE;
            
            nk_size_t size3 = 0;
            const nk_uint8_t *items4 = nk_arena_get(nk_uint8_t, arena,
                                                    sequence2, &size3);
            
            if (size3 > 1024)
                return NK_FALSE;
            nk_unused(items4);
            break;
        }
        
      default:
        return NK_FALSE;
    }
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetInitialThreadPriority_val_err(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetInitialThreadPriority_err *msg = (const
                                                                   struct kl_core_Task_GetInitialThreadPriority_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetInitialThreadPriority_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetInitialThreadPriority_val_req(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetInitialThreadPriority_req *msg = (const
                                                                   struct kl_core_Task_GetInitialThreadPriority_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetInitialThreadPriority_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetInitialThreadPriority_val_res(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetInitialThreadPriority_res *msg = (const
                                                                   struct kl_core_Task_GetInitialThreadPriority_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetInitialThreadPriority_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetName_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetName_err *msg = (const
                                                  struct kl_core_Task_GetName_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetName_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetName_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetName_req *msg = (const
                                                  struct kl_core_Task_GetName_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetName_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetName_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetName_res *msg = (const
                                                  struct kl_core_Task_GetName_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetName_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->name;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetNextVmRegion_val_err(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetNextVmRegion_err *msg = (const
                                                          struct kl_core_Task_GetNextVmRegion_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetNextVmRegion_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetNextVmRegion_val_req(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetNextVmRegion_req *msg = (const
                                                          struct kl_core_Task_GetNextVmRegion_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetNextVmRegion_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetNextVmRegion_val_res(const
                                                             struct nk_message *msg0,
                                                             const
                                                             struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetNextVmRegion_res *msg = (const
                                                          struct kl_core_Task_GetNextVmRegion_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetNextVmRegion_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetPath_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetPath_err *msg = (const
                                                  struct kl_core_Task_GetPath_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetPath_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetPath_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetPath_req *msg = (const
                                                  struct kl_core_Task_GetPath_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetPath_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetPath_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetPath_res *msg = (const
                                                  struct kl_core_Task_GetPath_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetPath_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *string0 = &msg->path;
    
    if (nk_arena_validate(nk_uint8_t, arena, string0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, string0, &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    if (kss_validate_utf8(items2, size1) != NK_TRUE)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetPid_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetPid_err *msg = (const
                                                 struct kl_core_Task_GetPid_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetPid_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetPid_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetPid_req *msg = (const
                                                 struct kl_core_Task_GetPid_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetPid_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetPid_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetPid_res *msg = (const
                                                 struct kl_core_Task_GetPid_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetPid_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetTasksList_val_err(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetTasksList_err *msg = (const
                                                       struct kl_core_Task_GetTasksList_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetTasksList_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetTasksList_val_req(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetTasksList_req *msg = (const
                                                       struct kl_core_Task_GetTasksList_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetTasksList_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetTasksList_val_res(const
                                                          struct nk_message *msg0,
                                                          const
                                                          struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetTasksList_res *msg = (const
                                                       struct kl_core_Task_GetTasksList_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetTasksList_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->strings;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 131072)
        return NK_FALSE;
    nk_unused(items2);
    
    const nk_ptr_t *sequence4 = &msg->pids;
    
    if (nk_arena_validate(nk_uint32_t, arena, sequence4) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size5 = 0;
    const nk_uint32_t *items6 = nk_arena_get(nk_uint32_t, arena, sequence4,
                                             &size5);
    
    if (size5 > 4294967295)
        return NK_FALSE;
    if (((nk_uintptr_t) items6 & (nk_alignof(nk_uint32_t) - 1)) != 0)
        return NK_FALSE;
    nk_unused(items6);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetThreadContext_val_err(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetThreadContext_err *msg = (const
                                                           struct kl_core_Task_GetThreadContext_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetThreadContext_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetThreadContext_val_req(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetThreadContext_req *msg = (const
                                                           struct kl_core_Task_GetThreadContext_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetThreadContext_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_GetThreadContext_val_res(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_GetThreadContext_res *msg = (const
                                                           struct kl_core_Task_GetThreadContext_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_GetThreadContext_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const struct kl_core_Task_ThreadContext *struct0 = &msg->context;
    const nk_ptr_t *sequence1 = &struct0->frame;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence1) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size2 = 0;
    const nk_uint8_t *items3 = nk_arena_get(nk_uint8_t, arena, sequence1,
                                            &size2);
    
    if (size2 > 1024)
        return NK_FALSE;
    nk_unused(items3);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_LoadElfHdr_val_err(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_LoadElfHdr_err *msg = (const
                                                     struct kl_core_Task_LoadElfHdr_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_LoadElfHdr_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_LoadElfHdr_val_req(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_LoadElfHdr_req *msg = (const
                                                     struct kl_core_Task_LoadElfHdr_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_LoadElfHdr_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->hdrData;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 1024)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_LoadElfHdr_val_res(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_LoadElfHdr_res *msg = (const
                                                     struct kl_core_Task_LoadElfHdr_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_LoadElfHdr_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_LoadElfSyms_val_err(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_LoadElfSyms_err *msg = (const
                                                      struct kl_core_Task_LoadElfSyms_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_LoadElfSyms_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_LoadElfSyms_val_req(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_LoadElfSyms_req *msg = (const
                                                      struct kl_core_Task_LoadElfSyms_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_LoadElfSyms_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_LoadElfSyms_val_res(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_LoadElfSyms_res *msg = (const
                                                      struct kl_core_Task_LoadElfSyms_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_LoadElfSyms_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_LoadSeg_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_LoadSeg_err *msg = (const
                                                  struct kl_core_Task_LoadSeg_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_LoadSeg_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_LoadSeg_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_LoadSeg_req *msg = (const
                                                  struct kl_core_Task_LoadSeg_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_LoadSeg_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_LoadSeg_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_LoadSeg_res *msg = (const
                                                  struct kl_core_Task_LoadSeg_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_LoadSeg_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_ReseedAslr_val_err(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_ReseedAslr_err *msg = (const
                                                     struct kl_core_Task_ReseedAslr_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_ReseedAslr_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_ReseedAslr_val_req(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_ReseedAslr_req *msg = (const
                                                     struct kl_core_Task_ReseedAslr_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_ReseedAslr_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->seed;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 32)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_ReseedAslr_val_res(const
                                                        struct nk_message *msg0,
                                                        const
                                                        struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_ReseedAslr_res *msg = (const
                                                     struct kl_core_Task_ReseedAslr_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_ReseedAslr_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_Resume_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_Resume_err *msg = (const
                                                 struct kl_core_Task_Resume_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_Resume_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_Resume_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_Resume_req *msg = (const
                                                 struct kl_core_Task_Resume_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_Resume_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_Resume_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_Resume_res *msg = (const
                                                 struct kl_core_Task_Resume_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_Resume_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_SetEntry_val_err(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_SetEntry_err *msg = (const
                                                   struct kl_core_Task_SetEntry_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_SetEntry_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_SetEntry_val_req(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_SetEntry_req *msg = (const
                                                   struct kl_core_Task_SetEntry_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_SetEntry_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_SetEntry_val_res(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_SetEntry_res *msg = (const
                                                   struct kl_core_Task_SetEntry_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_SetEntry_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_SetEnv_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_SetEnv_err *msg = (const
                                                 struct kl_core_Task_SetEnv_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_SetEnv_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_SetEnv_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_SetEnv_req *msg = (const
                                                 struct kl_core_Task_SetEnv_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_SetEnv_req_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->env;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 131072)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_SetEnv_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_SetEnv_res *msg = (const
                                                 struct kl_core_Task_SetEnv_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_SetEnv_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_SetInitialThreadPriority_val_err(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_SetInitialThreadPriority_err *msg = (const
                                                                   struct kl_core_Task_SetInitialThreadPriority_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_SetInitialThreadPriority_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_SetInitialThreadPriority_val_req(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_SetInitialThreadPriority_req *msg = (const
                                                                   struct kl_core_Task_SetInitialThreadPriority_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_SetInitialThreadPriority_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_SetInitialThreadPriority_val_res(const
                                                                      struct nk_message *msg0,
                                                                      const
                                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_SetInitialThreadPriority_res *msg = (const
                                                                   struct kl_core_Task_SetInitialThreadPriority_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_SetInitialThreadPriority_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_SetInitialThreadSchedPolicy_val_err(const
                                                                         struct nk_message *msg0,
                                                                         const
                                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_SetInitialThreadSchedPolicy_err *msg = (const
                                                                      struct kl_core_Task_SetInitialThreadSchedPolicy_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_SetInitialThreadSchedPolicy_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_SetInitialThreadSchedPolicy_val_req(const
                                                                         struct nk_message *msg0,
                                                                         const
                                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_SetInitialThreadSchedPolicy_req *msg = (const
                                                                      struct kl_core_Task_SetInitialThreadSchedPolicy_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_SetInitialThreadSchedPolicy_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    
    const struct kl_core_Types_TrSchedParam *union0 = &msg->param;
    
    if (union0->tag >= kl_core_Types_TrSchedParam_tag_max)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_SetInitialThreadSchedPolicy_val_res(const
                                                                         struct nk_message *msg0,
                                                                         const
                                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_SetInitialThreadSchedPolicy_res *msg = (const
                                                                      struct kl_core_Task_SetInitialThreadSchedPolicy_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_SetInitialThreadSchedPolicy_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_TerminateAfterFreezing_val_err(const
                                                                    struct nk_message *msg0,
                                                                    const
                                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_TerminateAfterFreezing_err *msg = (const
                                                                 struct kl_core_Task_TerminateAfterFreezing_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_TerminateAfterFreezing_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_TerminateAfterFreezing_val_req(const
                                                                    struct nk_message *msg0,
                                                                    const
                                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_TerminateAfterFreezing_req *msg = (const
                                                                 struct kl_core_Task_TerminateAfterFreezing_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_TerminateAfterFreezing_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_TerminateAfterFreezing_val_res(const
                                                                    struct nk_message *msg0,
                                                                    const
                                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_TerminateAfterFreezing_res *msg = (const
                                                                 struct kl_core_Task_TerminateAfterFreezing_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_TerminateAfterFreezing_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_Terminate_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_Terminate_err *msg = (const
                                                    struct kl_core_Task_Terminate_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_Terminate_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_Terminate_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_Terminate_req *msg = (const
                                                    struct kl_core_Task_Terminate_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_Terminate_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_Terminate_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_Terminate_res *msg = (const
                                                    struct kl_core_Task_Terminate_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_Terminate_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_TransferHandle_val_err(const
                                                            struct nk_message *msg0,
                                                            const
                                                            struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_TransferHandle_err *msg = (const
                                                         struct kl_core_Task_TransferHandle_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_TransferHandle_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_TransferHandle_val_req(const
                                                            struct nk_message *msg0,
                                                            const
                                                            struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_TransferHandle_req *msg = (const
                                                         struct kl_core_Task_TransferHandle_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_TransferHandle_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_TransferHandle_val_res(const
                                                            struct nk_message *msg0,
                                                            const
                                                            struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_TransferHandle_res *msg = (const
                                                         struct kl_core_Task_TransferHandle_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_TransferHandle_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_VmFree_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_VmFree_err *msg = (const
                                                 struct kl_core_Task_VmFree_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_VmFree_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_VmFree_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_VmFree_req *msg = (const
                                                 struct kl_core_Task_VmFree_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_VmFree_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_VmFree_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_VmFree_res *msg = (const
                                                 struct kl_core_Task_VmFree_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_VmFree_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_VmReserve_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_VmReserve_err *msg = (const
                                                    struct kl_core_Task_VmReserve_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_VmReserve_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_VmReserve_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_VmReserve_req *msg = (const
                                                    struct kl_core_Task_VmReserve_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Task_VmReserve_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Task_VmReserve_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Task_VmReserve_res *msg = (const
                                                    struct kl_core_Task_VmReserve_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Task_VmReserve_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Attach_val_err(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Attach_err *msg = (const
                                                   struct kl_core_Thread_Attach_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Attach_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Attach_val_req(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Attach_req *msg = (const
                                                   struct kl_core_Thread_Attach_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Attach_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Attach_val_res(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Attach_res *msg = (const
                                                   struct kl_core_Thread_Attach_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Attach_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Create_val_err(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Create_err *msg = (const
                                                   struct kl_core_Thread_Create_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Create_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Create_val_req(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Create_req *msg = (const
                                                   struct kl_core_Thread_Create_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Create_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Create_val_res(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Create_res *msg = (const
                                                   struct kl_core_Thread_Create_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Create_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_DetachIrq_val_err(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_DetachIrq_err *msg = (const
                                                      struct kl_core_Thread_DetachIrq_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_DetachIrq_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_DetachIrq_val_req(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_DetachIrq_req *msg = (const
                                                      struct kl_core_Thread_DetachIrq_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_DetachIrq_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_DetachIrq_val_res(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_DetachIrq_res *msg = (const
                                                      struct kl_core_Thread_DetachIrq_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_DetachIrq_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Exit_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Exit_err *msg = (const
                                                 struct kl_core_Thread_Exit_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Exit_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Exit_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Exit_req *msg = (const
                                                 struct kl_core_Thread_Exit_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Exit_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Exit_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Exit_res *msg = (const
                                                 struct kl_core_Thread_Exit_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Exit_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_GetAffinity_val_err(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_GetAffinity_err *msg = (const
                                                        struct kl_core_Thread_GetAffinity_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_GetAffinity_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_GetAffinity_val_req(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_GetAffinity_req *msg = (const
                                                        struct kl_core_Thread_GetAffinity_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_GetAffinity_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_GetAffinity_val_res(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_GetAffinity_res *msg = (const
                                                        struct kl_core_Thread_GetAffinity_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_GetAffinity_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_GetInfo_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_GetInfo_err *msg = (const
                                                    struct kl_core_Thread_GetInfo_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_GetInfo_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_GetInfo_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_GetInfo_req *msg = (const
                                                    struct kl_core_Thread_GetInfo_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_GetInfo_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_GetInfo_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_GetInfo_res *msg = (const
                                                    struct kl_core_Thread_GetInfo_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_GetInfo_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_GetSchedPolicy_val_err(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_GetSchedPolicy_err *msg = (const
                                                           struct kl_core_Thread_GetSchedPolicy_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_GetSchedPolicy_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_GetSchedPolicy_val_req(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_GetSchedPolicy_req *msg = (const
                                                           struct kl_core_Thread_GetSchedPolicy_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_GetSchedPolicy_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_GetSchedPolicy_val_res(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_GetSchedPolicy_res *msg = (const
                                                           struct kl_core_Thread_GetSchedPolicy_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_GetSchedPolicy_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    
    const struct kl_core_Types_TrSchedParam *union0 = &msg->param;
    
    if (union0->tag >= kl_core_Types_TrSchedParam_tag_max)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_OpenCurrent_val_err(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_OpenCurrent_err *msg = (const
                                                        struct kl_core_Thread_OpenCurrent_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_OpenCurrent_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_OpenCurrent_val_req(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_OpenCurrent_req *msg = (const
                                                        struct kl_core_Thread_OpenCurrent_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_OpenCurrent_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_OpenCurrent_val_res(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_OpenCurrent_res *msg = (const
                                                        struct kl_core_Thread_OpenCurrent_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_OpenCurrent_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Resume_val_err(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Resume_err *msg = (const
                                                   struct kl_core_Thread_Resume_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Resume_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Resume_val_req(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Resume_req *msg = (const
                                                   struct kl_core_Thread_Resume_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Resume_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Resume_val_res(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Resume_res *msg = (const
                                                   struct kl_core_Thread_Resume_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Resume_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_SetAffinity_val_err(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_SetAffinity_err *msg = (const
                                                        struct kl_core_Thread_SetAffinity_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_SetAffinity_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_SetAffinity_val_req(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_SetAffinity_req *msg = (const
                                                        struct kl_core_Thread_SetAffinity_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_SetAffinity_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_SetAffinity_val_res(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_SetAffinity_res *msg = (const
                                                        struct kl_core_Thread_SetAffinity_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_SetAffinity_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_SetPriority_val_err(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_SetPriority_err *msg = (const
                                                        struct kl_core_Thread_SetPriority_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_SetPriority_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_SetPriority_val_req(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_SetPriority_req *msg = (const
                                                        struct kl_core_Thread_SetPriority_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_SetPriority_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_SetPriority_val_res(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_SetPriority_res *msg = (const
                                                        struct kl_core_Thread_SetPriority_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_SetPriority_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_SetSchedPolicy_val_err(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_SetSchedPolicy_err *msg = (const
                                                           struct kl_core_Thread_SetSchedPolicy_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_SetSchedPolicy_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_SetSchedPolicy_val_req(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_SetSchedPolicy_req *msg = (const
                                                           struct kl_core_Thread_SetSchedPolicy_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_SetSchedPolicy_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    
    const struct kl_core_Types_TrSchedParam *union0 = &msg->param;
    
    if (union0->tag >= kl_core_Types_TrSchedParam_tag_max)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_SetSchedPolicy_val_res(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_SetSchedPolicy_res *msg = (const
                                                           struct kl_core_Thread_SetSchedPolicy_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_SetSchedPolicy_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_SetTls_val_err(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_SetTls_err *msg = (const
                                                   struct kl_core_Thread_SetTls_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_SetTls_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_SetTls_val_req(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_SetTls_req *msg = (const
                                                   struct kl_core_Thread_SetTls_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_SetTls_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_SetTls_val_res(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_SetTls_res *msg = (const
                                                   struct kl_core_Thread_SetTls_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_SetTls_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Sleep_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Sleep_err *msg = (const
                                                  struct kl_core_Thread_Sleep_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Sleep_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Sleep_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Sleep_req *msg = (const
                                                  struct kl_core_Thread_Sleep_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Sleep_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Sleep_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Sleep_res *msg = (const
                                                  struct kl_core_Thread_Sleep_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Sleep_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Suspend_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Suspend_err *msg = (const
                                                    struct kl_core_Thread_Suspend_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Suspend_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Suspend_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Suspend_req *msg = (const
                                                    struct kl_core_Thread_Suspend_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Suspend_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Suspend_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Suspend_res *msg = (const
                                                    struct kl_core_Thread_Suspend_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Suspend_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Terminate_val_err(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Terminate_err *msg = (const
                                                      struct kl_core_Thread_Terminate_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Terminate_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Terminate_val_req(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Terminate_req *msg = (const
                                                      struct kl_core_Thread_Terminate_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Terminate_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Terminate_val_res(const
                                                         struct nk_message *msg0,
                                                         const
                                                         struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Terminate_res *msg = (const
                                                      struct kl_core_Thread_Terminate_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Terminate_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Wait_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Wait_err *msg = (const
                                                 struct kl_core_Thread_Wait_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Wait_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Wait_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Wait_req *msg = (const
                                                 struct kl_core_Thread_Wait_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Wait_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Thread_Wait_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Thread_Wait_res *msg = (const
                                                 struct kl_core_Thread_Wait_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Thread_Wait_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Time_GetSystemTimeAdj_val_err(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Time_GetSystemTimeAdj_err *msg = (const
                                                           struct kl_core_Time_GetSystemTimeAdj_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Time_GetSystemTimeAdj_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Time_GetSystemTimeAdj_val_req(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Time_GetSystemTimeAdj_req *msg = (const
                                                           struct kl_core_Time_GetSystemTimeAdj_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Time_GetSystemTimeAdj_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Time_GetSystemTimeAdj_val_res(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Time_GetSystemTimeAdj_res *msg = (const
                                                           struct kl_core_Time_GetSystemTimeAdj_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Time_GetSystemTimeAdj_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Time_SetSystemTimeAdj_val_err(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Time_SetSystemTimeAdj_err *msg = (const
                                                           struct kl_core_Time_SetSystemTimeAdj_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Time_SetSystemTimeAdj_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Time_SetSystemTimeAdj_val_req(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Time_SetSystemTimeAdj_req *msg = (const
                                                           struct kl_core_Time_SetSystemTimeAdj_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Time_SetSystemTimeAdj_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Time_SetSystemTimeAdj_val_res(const
                                                              struct nk_message *msg0,
                                                              const
                                                              struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Time_SetSystemTimeAdj_res *msg = (const
                                                           struct kl_core_Time_SetSystemTimeAdj_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Time_SetSystemTimeAdj_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Time_SetSystemTime_val_err(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Time_SetSystemTime_err *msg = (const
                                                        struct kl_core_Time_SetSystemTime_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Time_SetSystemTime_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Time_SetSystemTime_val_req(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Time_SetSystemTime_req *msg = (const
                                                        struct kl_core_Time_SetSystemTime_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_Time_SetSystemTime_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_Time_SetSystemTime_val_res(const
                                                           struct nk_message *msg0,
                                                           const
                                                           struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_Time_SetSystemTime_res *msg = (const
                                                        struct kl_core_Time_SetSystemTime_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_Time_SetSystemTime_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Allocate_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Allocate_err *msg = (const
                                                  struct kl_core_VMM_Allocate_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Allocate_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Allocate_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Allocate_req *msg = (const
                                                  struct kl_core_VMM_Allocate_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Allocate_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Allocate_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Allocate_res *msg = (const
                                                  struct kl_core_VMM_Allocate_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Allocate_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Commit_val_err(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Commit_err *msg = (const
                                                struct kl_core_VMM_Commit_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Commit_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Commit_val_req(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Commit_req *msg = (const
                                                struct kl_core_VMM_Commit_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Commit_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Commit_val_res(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Commit_res *msg = (const
                                                struct kl_core_VMM_Commit_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Commit_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Decommit_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Decommit_err *msg = (const
                                                  struct kl_core_VMM_Decommit_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Decommit_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Decommit_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Decommit_req *msg = (const
                                                  struct kl_core_VMM_Decommit_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Decommit_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Decommit_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Decommit_res *msg = (const
                                                  struct kl_core_VMM_Decommit_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Decommit_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Free_val_err(const struct nk_message *msg0,
                                                 const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Free_err *msg = (const
                                              struct kl_core_VMM_Free_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Free_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Free_val_req(const struct nk_message *msg0,
                                                 const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Free_req *msg = (const
                                              struct kl_core_VMM_Free_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Free_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Free_val_res(const struct nk_message *msg0,
                                                 const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Free_res *msg = (const
                                              struct kl_core_VMM_Free_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Free_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlClone_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlClone_err *msg = (const
                                                  struct kl_core_VMM_MdlClone_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlClone_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlClone_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlClone_req *msg = (const
                                                  struct kl_core_VMM_MdlClone_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlClone_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlClone_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlClone_res *msg = (const
                                                  struct kl_core_VMM_MdlClone_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlClone_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlCreateFromVm_val_err(const
                                                            struct nk_message *msg0,
                                                            const
                                                            struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlCreateFromVm_err *msg = (const
                                                         struct kl_core_VMM_MdlCreateFromVm_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlCreateFromVm_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlCreateFromVm_val_req(const
                                                            struct nk_message *msg0,
                                                            const
                                                            struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlCreateFromVm_req *msg = (const
                                                         struct kl_core_VMM_MdlCreateFromVm_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlCreateFromVm_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlCreateFromVm_val_res(const
                                                            struct nk_message *msg0,
                                                            const
                                                            struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlCreateFromVm_res *msg = (const
                                                         struct kl_core_VMM_MdlCreateFromVm_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlCreateFromVm_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlCreate_val_err(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlCreate_err *msg = (const
                                                   struct kl_core_VMM_MdlCreate_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlCreate_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlCreate_val_req(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlCreate_req *msg = (const
                                                   struct kl_core_VMM_MdlCreate_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlCreate_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlCreate_val_res(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlCreate_res *msg = (const
                                                   struct kl_core_VMM_MdlCreate_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlCreate_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlGetSize_val_err(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlGetSize_err *msg = (const
                                                    struct kl_core_VMM_MdlGetSize_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlGetSize_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlGetSize_val_req(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlGetSize_req *msg = (const
                                                    struct kl_core_VMM_MdlGetSize_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlGetSize_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlGetSize_val_res(const
                                                       struct nk_message *msg0,
                                                       const
                                                       struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlGetSize_res *msg = (const
                                                    struct kl_core_VMM_MdlGetSize_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlGetSize_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlMap_val_err(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlMap_err *msg = (const
                                                struct kl_core_VMM_MdlMap_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlMap_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlMap_val_req(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlMap_req *msg = (const
                                                struct kl_core_VMM_MdlMap_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlMap_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_MdlMap_val_res(const
                                                   struct nk_message *msg0,
                                                   const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_MdlMap_res *msg = (const
                                                struct kl_core_VMM_MdlMap_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_VMM_MdlMap_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Protect_val_err(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Protect_err *msg = (const
                                                 struct kl_core_VMM_Protect_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Protect_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Protect_val_req(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Protect_req *msg = (const
                                                 struct kl_core_VMM_Protect_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Protect_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Protect_val_res(const
                                                    struct nk_message *msg0,
                                                    const
                                                    struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Protect_res *msg = (const
                                                 struct kl_core_VMM_Protect_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Protect_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Query_val_err(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Query_err *msg = (const
                                               struct kl_core_VMM_Query_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Query_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Query_val_req(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Query_req *msg = (const
                                               struct kl_core_VMM_Query_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Query_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Query_val_res(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Query_res *msg = (const
                                               struct kl_core_VMM_Query_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Query_res_handles)
        return NK_FALSE;
    if (arena == NK_NULL)
        return NK_FALSE;
    
    nk_uintptr_t arena_start = (nk_uintptr_t) arena->start;
    nk_uintptr_t arena_current = (nk_uintptr_t) arena->current;
    
    if (arena_current < arena_start)
        return NK_FALSE;
    
    nk_size_t arena_size = arena_current - arena_start;
    
    if (arena_size > NK_UINT32_MAX)
        return NK_FALSE;
    
    const nk_ptr_t *sequence0 = &msg->info;
    
    if (nk_arena_validate(nk_uint8_t, arena, sequence0) != NK_EOK)
        return NK_FALSE;
    
    nk_size_t size1 = 0;
    const nk_uint8_t *items2 = nk_arena_get(nk_uint8_t, arena, sequence0,
                                            &size1);
    
    if (size1 > 128)
        return NK_FALSE;
    nk_unused(items2);
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Reset_val_err(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Reset_err *msg = (const
                                               struct kl_core_VMM_Reset_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Reset_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Reset_val_req(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Reset_req *msg = (const
                                               struct kl_core_VMM_Reset_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Reset_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_VMM_Reset_val_res(const struct nk_message *msg0,
                                                  const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_VMM_Reset_res *msg = (const
                                               struct kl_core_VMM_Reset_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_VMM_Reset_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_XHCIDBG_Start_val_err(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_XHCIDBG_Start_err *msg = (const
                                                   struct kl_core_XHCIDBG_Start_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_XHCIDBG_Start_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_XHCIDBG_Start_val_req(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_XHCIDBG_Start_req *msg = (const
                                                   struct kl_core_XHCIDBG_Start_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_XHCIDBG_Start_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_XHCIDBG_Start_val_res(const
                                                      struct nk_message *msg0,
                                                      const
                                                      struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_XHCIDBG_Start_res *msg = (const
                                                   struct kl_core_XHCIDBG_Start_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_XHCIDBG_Start_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_XHCIDBG_Stop_val_err(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_XHCIDBG_Stop_err *msg = (const
                                                  struct kl_core_XHCIDBG_Stop_err *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_XHCIDBG_Stop_err_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_XHCIDBG_Stop_val_req(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_XHCIDBG_Stop_req *msg = (const
                                                  struct kl_core_XHCIDBG_Stop_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        kl_core_XHCIDBG_Stop_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t kl_core_XHCIDBG_Stop_val_res(const
                                                     struct nk_message *msg0,
                                                     const
                                                     struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct kl_core_XHCIDBG_Stop_res *msg = (const
                                                  struct kl_core_XHCIDBG_Stop_res *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(msg->res_) || nk_msg_ncaps(msg) !=
        kl_core_XHCIDBG_Stop_res_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_bool_t nk_Execute_run_val_req(const struct nk_message *msg0,
                                               const struct nk_arena *arena)
{
    nk_unused(arena);
    
    const struct nk_Execute_run_req *msg = (const
                                            struct nk_Execute_run_req *) msg0;
    
    if (msg->base_.ex.size_ex != sizeof(*msg) || nk_msg_ncaps(msg) !=
        nk_Execute_run_req_handles)
        return NK_FALSE;
    if (nk_arena_allocated_size(arena) > 0)
        return NK_FALSE;
    return NK_TRUE;
}
static inline nk_size_t cbor_audit_close(QCBOREncodeContext *ctx,
                                         UsefulBuf cbor_buf,
                                         kss_call_id call_id)
{
    QCBOREncode_CloseMap(ctx);
    QCBOREncode_CloseArray(ctx);
    return close_message_root(ctx, call_id, cbor_buf);
}
static inline void cbor_audit_open(QCBOREncodeContext *ctx, kss_call_id call_id,
                                   const char *class_name, const
                                   char *object_name, const char *method)
{
    open_message_root(ctx, call_id);
    QCBOREncode_AddTag(ctx, KSS_AUDIT_SUBSYSTEM_PROVIDER);
    QCBOREncode_OpenArray(ctx);
    QCBOREncode_AddSZString(ctx, class_name);
    QCBOREncode_AddSZString(ctx, object_name);
    QCBOREncode_AddSZString(ctx, method);
    QCBOREncode_OpenMap(ctx);
}
static int get_eid_cmp(const void *s1, const void *s2)
{
    return nk_strcmp(*(char *const *) s1, *(char *const *) s2);
}
static kss_audit_operation_t _auditOperationToCBORValue(enum kss_audit_type t)
{
    switch (t) {
        
      case KSS_AUDIT_TYPE_REQUEST:
        return KSS_AUDIT_OPERATION_REQUEST;
        
      case KSS_AUDIT_TYPE_RESPONSE:
        return KSS_AUDIT_OPERATION_RESPONSE;
        
      case KSS_AUDIT_TYPE_EXECUTE:
        return KSS_AUDIT_OPERATION_EXECUTE;
        
      case KSS_AUDIT_TYPE_SECURITY:
        return KSS_AUDIT_OPERATION_SECURITY;
        
      case KSS_AUDIT_TYPE_ERROR:
        return KSS_AUDIT_OPERATION_ERROR;
    }
    nk_assert(NK_FALSE);
    // All cases should be handled here already
    ;
}
static void endpoint_names(kss_eid_t eid, nk_iid_t iid, nk_mid_t mid, const
                           char **endpoint_name, const char **interface_name,
                           const char **method_name)
{
    nk_unused(eid);
    nk_unused(iid);
    nk_unused(mid);
    nk_unused(endpoint_name);
    nk_unused(interface_name);
    nk_unused(method_name);
    switch (eid) {
        
      case 0:
        {
            switch (iid) { }
            break;
        }
        
      case 1:
        {
            switch (iid) { }
            break;
        }
        
      case 2:
        {
            switch (iid) {
                
              case 0:
                {
                    *endpoint_name = "vmm.VMM";
                    *interface_name = "kl.core.VMM";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Allocate";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "Commit";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "Decommit";
                            break;
                        }
                        
                      case 3:
                        {
                            *method_name = "Protect";
                            break;
                        }
                        
                      case 4:
                        {
                            *method_name = "Free";
                            break;
                        }
                        
                      case 5:
                        {
                            *method_name = "Query";
                            break;
                        }
                        
                      case 6:
                        {
                            *method_name = "Reset";
                            break;
                        }
                        
                      case 7:
                        {
                            *method_name = "MdlCreate";
                            break;
                        }
                        
                      case 8:
                        {
                            *method_name = "MdlCreateFromVm";
                            break;
                        }
                        
                      case 9:
                        {
                            *method_name = "MdlGetSize";
                            break;
                        }
                        
                      case 10:
                        {
                            *method_name = "MdlMap";
                            break;
                        }
                        
                      case 11:
                        {
                            *method_name = "MdlClone";
                            break;
                        }
                    }
                    break;
                }
                
              case 1:
                {
                    *endpoint_name = "io.IO";
                    *interface_name = "kl.core.IO";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "RegisterPort";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "RegisterMmio";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "RegisterDma";
                            break;
                        }
                        
                      case 3:
                        {
                            *method_name = "RegisterIrq";
                            break;
                        }
                        
                      case 4:
                        {
                            *method_name = "RevokeResource";
                            break;
                        }
                        
                      case 5:
                        {
                            *method_name = "MapMem";
                            break;
                        }
                        
                      case 6:
                        {
                            *method_name = "PermitPort";
                            break;
                        }
                        
                      case 7:
                        {
                            *method_name = "AttachIrq";
                            break;
                        }
                        
                      case 8:
                        {
                            *method_name = "DetachIrq";
                            break;
                        }
                        
                      case 9:
                        {
                            *method_name = "EnableIrq";
                            break;
                        }
                        
                      case 10:
                        {
                            *method_name = "DisableIrq";
                            break;
                        }
                        
                      case 11:
                        {
                            *method_name = "ModifyDma";
                            break;
                        }
                        
                      case 12:
                        {
                            *method_name = "MapDma";
                            break;
                        }
                        
                      case 13:
                        {
                            *method_name = "DmaGetInfo";
                            break;
                        }
                        
                      case 14:
                        {
                            *method_name = "DmaGetPhysInfo";
                            break;
                        }
                        
                      case 15:
                        {
                            *method_name = "BeginDma";
                            break;
                        }
                    }
                    break;
                }
                
              case 2:
                {
                    *endpoint_name = "thread.Thread";
                    *interface_name = "kl.core.Thread";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Create";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "OpenCurrent";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "Attach";
                            break;
                        }
                        
                      case 3:
                        {
                            *method_name = "Suspend";
                            break;
                        }
                        
                      case 4:
                        {
                            *method_name = "Resume";
                            break;
                        }
                        
                      case 5:
                        {
                            *method_name = "Terminate";
                            break;
                        }
                        
                      case 6:
                        {
                            *method_name = "Exit";
                            break;
                        }
                        
                      case 7:
                        {
                            *method_name = "Wait";
                            break;
                        }
                        
                      case 8:
                        {
                            *method_name = "SetPriority";
                            break;
                        }
                        
                      case 9:
                        {
                            *method_name = "SetTls";
                            break;
                        }
                        
                      case 10:
                        {
                            *method_name = "Sleep";
                            break;
                        }
                        
                      case 11:
                        {
                            *method_name = "GetInfo";
                            break;
                        }
                        
                      case 12:
                        {
                            *method_name = "DetachIrq";
                            break;
                        }
                        
                      case 13:
                        {
                            *method_name = "GetAffinity";
                            break;
                        }
                        
                      case 14:
                        {
                            *method_name = "SetAffinity";
                            break;
                        }
                        
                      case 15:
                        {
                            *method_name = "SetSchedPolicy";
                            break;
                        }
                        
                      case 16:
                        {
                            *method_name = "GetSchedPolicy";
                            break;
                        }
                    }
                    break;
                }
                
              case 3:
                {
                    *endpoint_name = "handle.Handle";
                    *interface_name = "kl.core.Handle";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Alloc";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "Free";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "Copy";
                            break;
                        }
                        
                      case 3:
                        {
                            *method_name = "Init";
                            break;
                        }
                        
                      case 4:
                        {
                            *method_name = "Fini";
                            break;
                        }
                        
                      case 5:
                        {
                            *method_name = "CreateUserObject";
                            break;
                        }
                        
                      case 6:
                        {
                            *method_name = "Close";
                            break;
                        }
                        
                      case 7:
                        {
                            *method_name = "Connect";
                            break;
                        }
                        
                      case 8:
                        {
                            *method_name = "Disconnect";
                            break;
                        }
                        
                      case 9:
                        {
                            *method_name = "SecurityConnect";
                            break;
                        }
                        
                      case 10:
                        {
                            *method_name = "UidAlloc";
                            break;
                        }
                        
                      case 11:
                        {
                            *method_name = "UidFree";
                            break;
                        }
                        
                      case 12:
                        {
                            *method_name = "GetSidByHandle";
                            break;
                        }
                        
                      case 13:
                        {
                            *method_name = "Revoke";
                            break;
                        }
                        
                      case 14:
                        {
                            *method_name = "RevokeSubtree";
                            break;
                        }
                        
                      case 15:
                        {
                            *method_name = "CreateBadge";
                            break;
                        }
                    }
                    break;
                }
                
              case 4:
                {
                    *endpoint_name = "task.Task";
                    *interface_name = "kl.core.Task";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Create";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "LoadSeg";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "VmReserve";
                            break;
                        }
                        
                      case 3:
                        {
                            *method_name = "VmFree";
                            break;
                        }
                        
                      case 4:
                        {
                            *method_name = "SetEntry";
                            break;
                        }
                        
                      case 5:
                        {
                            *method_name = "LoadElfSyms";
                            break;
                        }
                        
                      case 6:
                        {
                            *method_name = "LoadElfHdr";
                            break;
                        }
                        
                      case 7:
                        {
                            *method_name = "SetEnv";
                            break;
                        }
                        
                      case 8:
                        {
                            *method_name = "FreeSelfEnv";
                            break;
                        }
                        
                      case 9:
                        {
                            *method_name = "Resume";
                            break;
                        }
                        
                      case 10:
                        {
                            *method_name = "Exit";
                            break;
                        }
                        
                      case 11:
                        {
                            *method_name = "Terminate";
                            break;
                        }
                        
                      case 12:
                        {
                            *method_name = "GetExitInfo";
                            break;
                        }
                        
                      case 13:
                        {
                            *method_name = "GetThreadContext";
                            break;
                        }
                        
                      case 14:
                        {
                            *method_name = "GetNextVmRegion";
                            break;
                        }
                        
                      case 15:
                        {
                            *method_name = "TerminateAfterFreezing";
                            break;
                        }
                        
                      case 16:
                        {
                            *method_name = "GetName";
                            break;
                        }
                        
                      case 17:
                        {
                            *method_name = "GetPath";
                            break;
                        }
                        
                      case 18:
                        {
                            *method_name = "GetInitialThreadPriority";
                            break;
                        }
                        
                      case 19:
                        {
                            *method_name = "SetInitialThreadPriority";
                            break;
                        }
                        
                      case 20:
                        {
                            *method_name = "GetTasksList";
                            break;
                        }
                        
                      case 21:
                        {
                            *method_name = "SetInitialThreadSchedPolicy";
                            break;
                        }
                        
                      case 22:
                        {
                            *method_name = "ReseedAslr";
                            break;
                        }
                        
                      case 23:
                        {
                            *method_name = "GetElfSyms";
                            break;
                        }
                        
                      case 24:
                        {
                            *method_name = "TransferHandle";
                            break;
                        }
                        
                      case 25:
                        {
                            *method_name = "GetPid";
                            break;
                        }
                    }
                    break;
                }
                
              case 5:
                {
                    *endpoint_name = "task.TaskDebug";
                    *interface_name = "kl.core.TaskDebug";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "GetHandlesCount";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "GetHandles";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "GetHandleInfo";
                            break;
                        }
                        
                      case 3:
                        {
                            *method_name = "EnableHandleTracing";
                            break;
                        }
                        
                      case 4:
                        {
                            *method_name = "DisableHandleTracing";
                            break;
                        }
                    }
                    break;
                }
                
              case 6:
                {
                    *endpoint_name = "sync.Sync";
                    *interface_name = "kl.core.Sync";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Wait";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "Wake";
                            break;
                        }
                    }
                    break;
                }
                
              case 7:
                {
                    *endpoint_name = "fs.FS";
                    *interface_name = "kl.core.FS";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Open";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "Close";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "Read";
                            break;
                        }
                        
                      case 3:
                        {
                            *method_name = "GetSize";
                            break;
                        }
                        
                      case 4:
                        {
                            *method_name = "GetId";
                            break;
                        }
                        
                      case 5:
                        {
                            *method_name = "Count";
                            break;
                        }
                        
                      case 6:
                        {
                            *method_name = "GetInfo";
                            break;
                        }
                        
                      case 7:
                        {
                            *method_name = "GetFsSize";
                            break;
                        }
                    }
                    break;
                }
                
              case 8:
                {
                    *endpoint_name = "fs.FSUnsafe";
                    *interface_name = "kl.core.FSUnsafe";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Change";
                            break;
                        }
                    }
                    break;
                }
                
              case 9:
                {
                    *endpoint_name = "time.Time";
                    *interface_name = "kl.core.Time";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "SetSystemTime";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "SetSystemTimeAdj";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "GetSystemTimeAdj";
                            break;
                        }
                    }
                    break;
                }
                
              case 10:
                {
                    *endpoint_name = "hal.HAL";
                    *interface_name = "kl.core.HAL";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "GetEnv";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "GetPrivReg";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "SetPrivReg";
                            break;
                        }
                        
                      case 3:
                        {
                            *method_name = "GetPrivRegRange";
                            break;
                        }
                        
                      case 4:
                        {
                            *method_name = "SetPrivRegRange";
                            break;
                        }
                        
                      case 5:
                        {
                            *method_name = "FlushCache";
                            break;
                        }
                        
                      case 6:
                        {
                            *method_name = "DebugWrite";
                            break;
                        }
                        
                      case 7:
                        {
                            *method_name = "GetEntropy";
                            break;
                        }
                    }
                    break;
                }
                
              case 11:
                {
                    *endpoint_name = "xhcidbg.XHCIDBG";
                    *interface_name = "kl.core.XHCIDBG";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Start";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "Stop";
                            break;
                        }
                    }
                    break;
                }
                
              case 12:
                {
                    *endpoint_name = "audit.Audit";
                    *interface_name = "kl.core.Audit";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Open";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "Close";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "Read";
                            break;
                        }
                    }
                    break;
                }
                
              case 13:
                {
                    *endpoint_name = "profiler.Profiler";
                    *interface_name = "kl.core.Profiler";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "GetCoverageData";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "FlushGcov";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "FlushGcovFile";
                            break;
                        }
                        
                      case 3:
                        {
                            *method_name = "GetCounters";
                            break;
                        }
                        
                      case 4:
                        {
                            *method_name = "ObjectGetStat";
                            break;
                        }
                        
                      case 5:
                        {
                            *method_name = "SamplingStart";
                            break;
                        }
                        
                      case 6:
                        {
                            *method_name = "SamplingStop";
                            break;
                        }
                        
                      case 7:
                        {
                            *method_name = "SamplingRead";
                            break;
                        }
                        
                      case 8:
                        {
                            *method_name = "SamplingAddPidToList";
                            break;
                        }
                        
                      case 9:
                        {
                            *method_name = "SamplingClearPidList";
                            break;
                        }
                        
                      case 10:
                        {
                            *method_name = "LoadSegInfo";
                            break;
                        }
                        
                      case 11:
                        {
                            *method_name = "UnloadSegInfo";
                            break;
                        }
                        
                      case 12:
                        {
                            *method_name = "KcovAlloc";
                            break;
                        }
                        
                      case 13:
                        {
                            *method_name = "KcovFree";
                            break;
                        }
                        
                      case 14:
                        {
                            *method_name = "KcovStart";
                            break;
                        }
                        
                      case 15:
                        {
                            *method_name = "KcovStop";
                            break;
                        }
                    }
                    break;
                }
                
              case 14:
                {
                    *endpoint_name = "iommu.IOMMU";
                    *interface_name = "kl.core.IOMMU";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Attach";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "Detach";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "CreateDomain";
                            break;
                        }
                        
                      case 3:
                        {
                            *method_name = "AttachToDomain";
                            break;
                        }
                        
                      case 4:
                        {
                            *method_name = "DetachFromDomain";
                            break;
                        }
                    }
                    break;
                }
                
              case 15:
                {
                    *endpoint_name = "cm.CM";
                    *interface_name = "kl.core.CM";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Connect";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "Listen";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "Drop";
                            break;
                        }
                        
                      case 3:
                        {
                            *method_name = "Accept";
                            break;
                        }
                    }
                    break;
                }
                
              case 16:
                {
                    *endpoint_name = "pm.PM";
                    *interface_name = "kl.core.PM";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Request";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "SetCpusOnline";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "GetCpusOnline";
                            break;
                        }
                    }
                    break;
                }
                
              case 17:
                {
                    *endpoint_name = "notice.Notice";
                    *interface_name = "kl.core.Notice";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Create";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "SubscribeToObject";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "UnsubscribeFromEvent";
                            break;
                        }
                        
                      case 3:
                        {
                            *method_name = "UnsubscribeFromObject";
                            break;
                        }
                        
                      case 4:
                        {
                            *method_name = "GetEvent";
                            break;
                        }
                        
                      case 5:
                        {
                            *method_name = "DropAndWake";
                            break;
                        }
                        
                      case 6:
                        {
                            *method_name = "SetObjectEvent";
                            break;
                        }
                    }
                    break;
                }
                
              case 18:
                {
                    *endpoint_name = "ipc.IPC";
                    *interface_name = "kl.core.IPC";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "CreateSyncObject";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "SetInterrupt";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "ClearInterrupt";
                            break;
                        }
                    }
                    break;
                }
                
              case 19:
                {
                    *endpoint_name = "log.Log";
                    *interface_name = "kl.core.Log";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "Handoff";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "FetchMessages";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "GetMessagesHandle";
                            break;
                        }
                    }
                    break;
                }
                
              case 20:
                {
                    *endpoint_name = "efi.Efi";
                    *interface_name = "kl.core.Efi";
                    switch (mid) {
                        
                      case 0:
                        {
                            *method_name = "GetTime";
                            break;
                        }
                        
                      case 1:
                        {
                            *method_name = "SetTime";
                            break;
                        }
                        
                      case 2:
                        {
                            *method_name = "GetVariable";
                            break;
                        }
                        
                      case 3:
                        {
                            *method_name = "GetNextVariableName";
                            break;
                        }
                        
                      case 4:
                        {
                            *method_name = "SetVariable";
                            break;
                        }
                        
                      case 5:
                        {
                            *method_name = "QueryVariableInfo";
                            break;
                        }
                        
                      case 6:
                        {
                            *method_name = "ResetSystem";
                            break;
                        }
                    }
                    break;
                }
            }
            break;
        }
    }
}
static void security_names(kss_eid_t eid, nk_iid_t iid, nk_mid_t mid, const
                           char **endpoint_name, const char **interface_name,
                           const char **method_name)
{
    nk_unused(eid);
    nk_unused(iid);
    nk_unused(mid);
    nk_unused(endpoint_name);
    nk_unused(interface_name);
    nk_unused(method_name);
    switch (eid) {
        
      case 0:
        {
            switch (iid) { }
            break;
        }
        
      case 1:
        {
            switch (iid) { }
            break;
        }
        
      case 2:
        {
            switch (iid) { }
            break;
        }
    }
}
struct base_audit_profile {
    kss_audit_profile_t kss;
};
static void audit_common(const kss_audit_subsystem_t subsystem, const
                         kss_call_id call_id, const
                         struct kss_audit_message *message, const
                         kss_decision_t *decision)
{
    nk_assert(message != NK_NULL);
    
    nk_uint8_t __cbor_buf[512];
    UsefulBuf cbor_buf = {__cbor_buf, sizeof(__cbor_buf)};
    
    PSL_TRACE(CLS_KSS, "Audit",
              "call=%u decision=%u type=%u eids=%u:%u sids=%u:%u method=%u.%u",
              (unsigned int) call_id, (unsigned int) *decision,
              (unsigned int) message->type, (unsigned int) message->src_eid,
              (unsigned int) message->dst_eid, (unsigned int) message->src_sid,
              (unsigned int) message->dst_sid, (unsigned int) message->iid,
              (unsigned int) message->mid);
    
    kss_eid_t src_eid = message->src_eid;
    kss_eid_t dst_eid = KSS_INVALID_EID;
    
    if (message->type != KSS_AUDIT_TYPE_SECURITY)
        dst_eid = message->dst_eid;
    
    const char *endpoint_name = "NULL";
    const char *interface_name = "NULL";
    const char *method_name = "NULL";
    
    switch (message->type) {
        
      case KSS_AUDIT_TYPE_EXECUTE:
        method_name = execute_names(message->mid);
        break;
        
      case KSS_AUDIT_TYPE_REQUEST:
        endpoint_names(dst_eid, message->iid, message->mid, &endpoint_name,
                       &interface_name, &method_name);
        break;
        
      case KSS_AUDIT_TYPE_RESPONSE:
        
      case KSS_AUDIT_TYPE_ERROR:
        endpoint_names(src_eid, message->iid, message->mid, &endpoint_name,
                       &interface_name, &method_name);
        break;
        
      case KSS_AUDIT_TYPE_SECURITY:
        security_names(src_eid, message->iid, message->mid, &endpoint_name,
                       &interface_name, &method_name);
        break;
        
      default:
        nk_assert(0);
        return;
    }
    
    nk_size_t audit_buf_written =
              emit_audit_CBOR_next((nk_uint8_t *) cbor_buf.ptr, cbor_buf.len,
                                   call_id,
                                   _auditOperationToCBORValue(message->type),
                                   __kss_get_eiid(message->src_eid),
                                   message->src_eid, message->type !=
                                   KSS_AUDIT_TYPE_SECURITY ? __kss_get_eiid(message->dst_eid) : "NULL",
                                   message->dst_eid, endpoint_name,
                                   interface_name, method_name, message->mid,
                                   message->iid, subsystem, *decision);
    kss_audit_header header = {.callId =call_id, .tag =
                               KSS_AUDIT_MESSAGE_FORMAT_CBOR, .size =
                               (nk_uint16_t) audit_buf_written};
    
    AUDIT_LOG_TO_CORE_DEBUG_CONSOLE(header, cbor_buf.ptr);
    kss_audit_log(&header, sizeof(header), cbor_buf.ptr, header.size);
}
static const struct base_audit_profile base_rt_audit_profile_0 = {.kss =
                                       KSS_AUDIT_NEVER};
static nk_err_t calltree_0(kss_decision_t *decision, kss_eid_t src_eid,
                           nk_sid_t src_sid, kss_eid_t dst_eid,
                           nk_sid_t dst_sid, const struct nk_message *message,
                           const struct nk_arena *arena,
                           struct kss_audit_message *kss_audit_message)
{
    // calltree decls
    kss_call_id psl_call_id = kss_alloc_call_id();
    nk_bool_t psl_audit_flag = NK_FALSE;
    nk_uint8_t __cbor_buf[512];
    UsefulBuf cbor_buf = {__cbor_buf, sizeof(__cbor_buf)};
    
    nk_unused(cbor_buf);
    
    nk_sid_t callable_sid;
    
    callable_sid = nk_get_handle(&message->self);
    nk_unused(callable_sid);
    nk_unused(decision);
    nk_unused(src_eid);
    nk_unused(src_sid);
    nk_unused(dst_eid);
    nk_unused(dst_sid);
    nk_unused(message);
    nk_unused(arena);
    nk_unused(kss_audit_message);
    PSL_TRACE(CLS_KSS, "PSL", "Call # %u", psl_call_id);
    *decision = KSS_GRANT;
    // calltree prolog
    // calltree body
    {
        // leaf locals
        // leaf prolog
        // checks
        {
            // base.grant @ security.psl:9:12 : unconditional grant (no-op)
            //svacer_review: UNREACHABLE_CODE r:False Positive|s:Minor|a:Ignore|c:default
            const struct base_audit_profile *rtProfile =
                                            &base_rt_audit_profile_0;
            kss_decision_t local_decision = KSS_GRANT;
            
            if ((rtProfile->kss & KSS_AUDIT_DENIED && *&local_decision ==
                 KSS_DENY) || (rtProfile->kss & KSS_AUDIT_GRANTED &&
                               *&local_decision == KSS_GRANT)) {
                QCBOREncodeContext cbor_ctx;
                
                QCBOREncode_Init(&cbor_ctx, cbor_buf);
                cbor_audit_open(&cbor_ctx, 0, "Base", "base", "grant");
                
                nk_size_t cbor_size = cbor_audit_close(&cbor_ctx, cbor_buf, 0);
                
                psl_audit_flag |= psl_audit_log(psl_call_id,
                                                KSS_AUDIT_MESSAGE_FORMAT_CBOR,
                                                rtProfile->kss, &local_decision,
                                                cbor_buf.ptr, cbor_size);
            }
            PSL_TRACE(CLS_PROVIDER, "Base", "rtProfile(%d)=%p -> kssProfile=%d",
                      rt_audit_level, rtProfile, rtProfile->kss);
        }
        if (*decision == KSS_GRANT) {
            // commit
        } else {
            // rollback
        }
        // leaf epilog
    }
    // calltree epilog
    // calltree audit
    if (*decision == KSS_GRANT) {
        PSL_TRACE(CLS_KSS_GRANTED, "PSL", "%u -> granted, %s", psl_call_id,
                  psl_audit_flag ? "logged" : "silenced");
        if (psl_audit_flag)
            audit_common(KSS_AUDIT_SUBSYSTEM_EPILOGUE, psl_call_id,
                         kss_audit_message, decision);
        ;
        return NK_EOK;
    } else {
        PSL_TRACE(CLS_KSS_DENIED, "PSL", "%u -> denied, %s", psl_call_id,
                  psl_audit_flag ? "logged" : "silenced");
        if (psl_audit_flag)
            audit_common(KSS_AUDIT_SUBSYSTEM_EPILOGUE, psl_call_id,
                         kss_audit_message, decision);
        ;
        return NK_EPERM;
    }
}

static void log_rc(const struct kss_audit_message *message, nk_err_t rc)
{
    if (rc == NK_EOK)
        return;
    
    kss_call_id call_id = kss_alloc_call_id();
    kss_decision_t deny_decision = KSS_DENY;
    
    switch (rc) {
        
      case NK_EINVAL:
        audit_common(KSS_AUDIT_SUBSYSTEM_VALIDATOR, call_id, message,
                     &deny_decision);
        break;
        
      case NK_ENOENT:
        audit_common(KSS_AUDIT_SUBSYSTEM_ROUTER, call_id, message,
                     &deny_decision);
        break;
        
      default:
        break;
    }
    return;
}
nk_err_t __kss_security(kss_decision_t *decision, kss_eid_t driver_eid,
                        nk_sid_t driver_sid, const struct nk_message *message,
                        const struct nk_arena *arena,
                        struct kss_audit_message *audit_message)
{
    nk_err_t rc = NK_ENOENT;
    
    nk_unused(decision);
    nk_unused(driver_sid);
    nk_unused(message);
    nk_unused(arena);
    PSL_TRACE(CLS_PSL, "PSL", "driver: %d", driver_eid);
    switch (driver_eid) {
        
      default:
        break;
    }
    log_rc(audit_message, rc);
    return rc;
}
static
nk_err_t validate__Error__kl_core_Audit__95d3ff5faaadd2d8a9386c51b93767aa8099be3d(kss_decision_t *decision,
                                                                                  kss_eid_t src_eid,
                                                                                  nk_sid_t src_sid,
                                                                                  kss_eid_t dst_eid,
                                                                                  nk_sid_t dst_sid,
                                                                                  const
                                                                                  struct nk_message *message,
                                                                                  const
                                                                                  struct nk_arena *arena,
                                                                                  struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Audit_Open_mid:
        {
            if (NK_TRUE == kl_core_Audit_Open_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Audit_Open_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Audit_Open_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Audit_Close_mid:
        {
            if (NK_TRUE == kl_core_Audit_Close_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Audit_Close_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Audit_Close_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Audit_Read_mid:
        {
            if (NK_TRUE == kl_core_Audit_Read_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Audit_Read_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Audit_Read_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_CM__27258f11c55ea0fd9851fb5f9fec795fd2864948(kss_decision_t *decision,
                                                                               kss_eid_t src_eid,
                                                                               nk_sid_t src_sid,
                                                                               kss_eid_t dst_eid,
                                                                               nk_sid_t dst_sid,
                                                                               const
                                                                               struct nk_message *message,
                                                                               const
                                                                               struct nk_arena *arena,
                                                                               struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_CM_Connect_mid:
        {
            if (NK_TRUE == kl_core_CM_Connect_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_CM_Connect_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_CM_Connect_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_CM_Listen_mid:
        {
            if (NK_TRUE == kl_core_CM_Listen_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_CM_Listen_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_CM_Listen_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_CM_Drop_mid:
        {
            if (NK_TRUE == kl_core_CM_Drop_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_CM_Drop_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_CM_Drop_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_CM_Accept_mid:
        {
            if (NK_TRUE == kl_core_CM_Accept_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_CM_Accept_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_CM_Accept_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_Efi__15bc3f2dbc9a0058cff270f5476465a7356d5d1d(kss_decision_t *decision,
                                                                                kss_eid_t src_eid,
                                                                                nk_sid_t src_sid,
                                                                                kss_eid_t dst_eid,
                                                                                nk_sid_t dst_sid,
                                                                                const
                                                                                struct nk_message *message,
                                                                                const
                                                                                struct nk_arena *arena,
                                                                                struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Efi_GetTime_mid:
        {
            if (NK_TRUE == kl_core_Efi_GetTime_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_GetTime_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_GetTime_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_SetTime_mid:
        {
            if (NK_TRUE == kl_core_Efi_SetTime_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_SetTime_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_SetTime_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_GetVariable_mid:
        {
            if (NK_TRUE == kl_core_Efi_GetVariable_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_GetVariable_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_GetVariable_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_GetNextVariableName_mid:
        {
            if (NK_TRUE == kl_core_Efi_GetNextVariableName_val_err(message,
                                                                   arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_GetNextVariableName_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_GetNextVariableName_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_SetVariable_mid:
        {
            if (NK_TRUE == kl_core_Efi_SetVariable_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_SetVariable_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_SetVariable_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_QueryVariableInfo_mid:
        {
            if (NK_TRUE == kl_core_Efi_QueryVariableInfo_val_err(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_QueryVariableInfo_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_QueryVariableInfo_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_ResetSystem_mid:
        {
            if (NK_TRUE == kl_core_Efi_ResetSystem_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_ResetSystem_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_ResetSystem_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_FSUnsafe__9254f858dce54194081d210f94ee5d44ef2610a4(kss_decision_t *decision,
                                                                                     kss_eid_t src_eid,
                                                                                     nk_sid_t src_sid,
                                                                                     kss_eid_t dst_eid,
                                                                                     nk_sid_t dst_sid,
                                                                                     const
                                                                                     struct nk_message *message,
                                                                                     const
                                                                                     struct nk_arena *arena,
                                                                                     struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_FSUnsafe_Change_mid:
        {
            if (NK_TRUE == kl_core_FSUnsafe_Change_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FSUnsafe_Change_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FSUnsafe_Change_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_FS__9e3d0d77274d67a9140570815843418a8e4080de(kss_decision_t *decision,
                                                                               kss_eid_t src_eid,
                                                                               nk_sid_t src_sid,
                                                                               kss_eid_t dst_eid,
                                                                               nk_sid_t dst_sid,
                                                                               const
                                                                               struct nk_message *message,
                                                                               const
                                                                               struct nk_arena *arena,
                                                                               struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_FS_Open_mid:
        {
            if (NK_TRUE == kl_core_FS_Open_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_Open_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_Open_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_Close_mid:
        {
            if (NK_TRUE == kl_core_FS_Close_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_Close_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_Close_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_Read_mid:
        {
            if (NK_TRUE == kl_core_FS_Read_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_Read_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_Read_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_GetSize_mid:
        {
            if (NK_TRUE == kl_core_FS_GetSize_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_GetSize_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_GetSize_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_GetId_mid:
        {
            if (NK_TRUE == kl_core_FS_GetId_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_GetId_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_GetId_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_Count_mid:
        {
            if (NK_TRUE == kl_core_FS_Count_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_Count_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_Count_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_GetInfo_mid:
        {
            if (NK_TRUE == kl_core_FS_GetInfo_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_GetInfo_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_GetInfo_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_GetFsSize_mid:
        {
            if (NK_TRUE == kl_core_FS_GetFsSize_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_GetFsSize_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_GetFsSize_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_HAL__7a9ae0ccf9803fb09220411101c508affc1de9c0(kss_decision_t *decision,
                                                                                kss_eid_t src_eid,
                                                                                nk_sid_t src_sid,
                                                                                kss_eid_t dst_eid,
                                                                                nk_sid_t dst_sid,
                                                                                const
                                                                                struct nk_message *message,
                                                                                const
                                                                                struct nk_arena *arena,
                                                                                struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_HAL_GetEnv_mid:
        {
            if (NK_TRUE == kl_core_HAL_GetEnv_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_GetEnv_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_GetEnv_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_GetPrivReg_mid:
        {
            if (NK_TRUE == kl_core_HAL_GetPrivReg_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_GetPrivReg_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_GetPrivReg_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_SetPrivReg_mid:
        {
            if (NK_TRUE == kl_core_HAL_SetPrivReg_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_SetPrivReg_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_SetPrivReg_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_GetPrivRegRange_mid:
        {
            if (NK_TRUE == kl_core_HAL_GetPrivRegRange_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_GetPrivRegRange_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_GetPrivRegRange_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_SetPrivRegRange_mid:
        {
            if (NK_TRUE == kl_core_HAL_SetPrivRegRange_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_SetPrivRegRange_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_SetPrivRegRange_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_FlushCache_mid:
        {
            if (NK_TRUE == kl_core_HAL_FlushCache_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_FlushCache_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_FlushCache_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_DebugWrite_mid:
        {
            if (NK_TRUE == kl_core_HAL_DebugWrite_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_DebugWrite_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_DebugWrite_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_GetEntropy_mid:
        {
            if (NK_TRUE == kl_core_HAL_GetEntropy_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_GetEntropy_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_GetEntropy_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_Handle__96653286716976cc757704f49aa76a2e90f39ad1(kss_decision_t *decision,
                                                                                   kss_eid_t src_eid,
                                                                                   nk_sid_t src_sid,
                                                                                   kss_eid_t dst_eid,
                                                                                   nk_sid_t dst_sid,
                                                                                   const
                                                                                   struct nk_message *message,
                                                                                   const
                                                                                   struct nk_arena *arena,
                                                                                   struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Handle_Alloc_mid:
        {
            if (NK_TRUE == kl_core_Handle_Alloc_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Alloc_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Alloc_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Free_mid:
        {
            if (NK_TRUE == kl_core_Handle_Free_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Free_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Free_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Copy_mid:
        {
            if (NK_TRUE == kl_core_Handle_Copy_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Copy_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Copy_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Init_mid:
        {
            if (NK_TRUE == kl_core_Handle_Init_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Init_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Init_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Fini_mid:
        {
            if (NK_TRUE == kl_core_Handle_Fini_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Fini_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Fini_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_CreateUserObject_mid:
        {
            if (NK_TRUE == kl_core_Handle_CreateUserObject_val_err(message,
                                                                   arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_CreateUserObject_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_CreateUserObject_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Close_mid:
        {
            if (NK_TRUE == kl_core_Handle_Close_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Close_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Close_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Connect_mid:
        {
            if (NK_TRUE == kl_core_Handle_Connect_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Connect_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Connect_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Disconnect_mid:
        {
            if (NK_TRUE == kl_core_Handle_Disconnect_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Disconnect_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Disconnect_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_SecurityConnect_mid:
        {
            if (NK_TRUE == kl_core_Handle_SecurityConnect_val_err(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_SecurityConnect_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_SecurityConnect_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_UidAlloc_mid:
        {
            if (NK_TRUE == kl_core_Handle_UidAlloc_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_UidAlloc_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_UidAlloc_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_UidFree_mid:
        {
            if (NK_TRUE == kl_core_Handle_UidFree_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_UidFree_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_UidFree_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_GetSidByHandle_mid:
        {
            if (NK_TRUE == kl_core_Handle_GetSidByHandle_val_err(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_GetSidByHandle_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_GetSidByHandle_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Revoke_mid:
        {
            if (NK_TRUE == kl_core_Handle_Revoke_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Revoke_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Revoke_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_RevokeSubtree_mid:
        {
            if (NK_TRUE == kl_core_Handle_RevokeSubtree_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_RevokeSubtree_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_RevokeSubtree_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_CreateBadge_mid:
        {
            if (NK_TRUE == kl_core_Handle_CreateBadge_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_CreateBadge_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_CreateBadge_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_IOMMU__0a00654332ff29362cf9dda0e998e099f24d3592(kss_decision_t *decision,
                                                                                  kss_eid_t src_eid,
                                                                                  nk_sid_t src_sid,
                                                                                  kss_eid_t dst_eid,
                                                                                  nk_sid_t dst_sid,
                                                                                  const
                                                                                  struct nk_message *message,
                                                                                  const
                                                                                  struct nk_arena *arena,
                                                                                  struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_IOMMU_Attach_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_Attach_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_Attach_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_Attach_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IOMMU_Detach_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_Detach_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_Detach_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_Detach_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IOMMU_CreateDomain_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_CreateDomain_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_CreateDomain_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_CreateDomain_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IOMMU_AttachToDomain_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_AttachToDomain_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_AttachToDomain_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_AttachToDomain_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IOMMU_DetachFromDomain_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_DetachFromDomain_val_err(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_DetachFromDomain_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_DetachFromDomain_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_IO__823fc93e667833fc2cced245c3d148ff3d20c3a6(kss_decision_t *decision,
                                                                               kss_eid_t src_eid,
                                                                               nk_sid_t src_sid,
                                                                               kss_eid_t dst_eid,
                                                                               nk_sid_t dst_sid,
                                                                               const
                                                                               struct nk_message *message,
                                                                               const
                                                                               struct nk_arena *arena,
                                                                               struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_IO_RegisterPort_mid:
        {
            if (NK_TRUE == kl_core_IO_RegisterPort_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RegisterPort_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RegisterPort_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_RegisterMmio_mid:
        {
            if (NK_TRUE == kl_core_IO_RegisterMmio_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RegisterMmio_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RegisterMmio_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_RegisterDma_mid:
        {
            if (NK_TRUE == kl_core_IO_RegisterDma_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RegisterDma_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RegisterDma_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_RegisterIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_RegisterIrq_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RegisterIrq_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RegisterIrq_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_RevokeResource_mid:
        {
            if (NK_TRUE == kl_core_IO_RevokeResource_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RevokeResource_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RevokeResource_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_MapMem_mid:
        {
            if (NK_TRUE == kl_core_IO_MapMem_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_MapMem_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_MapMem_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_PermitPort_mid:
        {
            if (NK_TRUE == kl_core_IO_PermitPort_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_PermitPort_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_PermitPort_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_AttachIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_AttachIrq_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_AttachIrq_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_AttachIrq_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_DetachIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_DetachIrq_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_DetachIrq_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_DetachIrq_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_EnableIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_EnableIrq_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_EnableIrq_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_EnableIrq_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_DisableIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_DisableIrq_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_DisableIrq_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_DisableIrq_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_ModifyDma_mid:
        {
            if (NK_TRUE == kl_core_IO_ModifyDma_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_ModifyDma_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_ModifyDma_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_MapDma_mid:
        {
            if (NK_TRUE == kl_core_IO_MapDma_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_MapDma_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_MapDma_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_DmaGetInfo_mid:
        {
            if (NK_TRUE == kl_core_IO_DmaGetInfo_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_DmaGetInfo_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_DmaGetInfo_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_DmaGetPhysInfo_mid:
        {
            if (NK_TRUE == kl_core_IO_DmaGetPhysInfo_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_DmaGetPhysInfo_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_DmaGetPhysInfo_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_BeginDma_mid:
        {
            if (NK_TRUE == kl_core_IO_BeginDma_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_BeginDma_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_BeginDma_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_IPC__ca5864d469b432ebf1b8f36bb9b6802130c41972(kss_decision_t *decision,
                                                                                kss_eid_t src_eid,
                                                                                nk_sid_t src_sid,
                                                                                kss_eid_t dst_eid,
                                                                                nk_sid_t dst_sid,
                                                                                const
                                                                                struct nk_message *message,
                                                                                const
                                                                                struct nk_arena *arena,
                                                                                struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_IPC_CreateSyncObject_mid:
        {
            if (NK_TRUE == kl_core_IPC_CreateSyncObject_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IPC_CreateSyncObject_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IPC_CreateSyncObject_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IPC_SetInterrupt_mid:
        {
            if (NK_TRUE == kl_core_IPC_SetInterrupt_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IPC_SetInterrupt_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IPC_SetInterrupt_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IPC_ClearInterrupt_mid:
        {
            if (NK_TRUE == kl_core_IPC_ClearInterrupt_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IPC_ClearInterrupt_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IPC_ClearInterrupt_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_Log__76ebab3667966e8c0e43178c4ec33fa4a4cf15f0(kss_decision_t *decision,
                                                                                kss_eid_t src_eid,
                                                                                nk_sid_t src_sid,
                                                                                kss_eid_t dst_eid,
                                                                                nk_sid_t dst_sid,
                                                                                const
                                                                                struct nk_message *message,
                                                                                const
                                                                                struct nk_arena *arena,
                                                                                struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Log_Handoff_mid:
        {
            if (NK_TRUE == kl_core_Log_Handoff_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Log_Handoff_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Log_Handoff_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Log_FetchMessages_mid:
        {
            if (NK_TRUE == kl_core_Log_FetchMessages_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Log_FetchMessages_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Log_FetchMessages_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Log_GetMessagesHandle_mid:
        {
            if (NK_TRUE == kl_core_Log_GetMessagesHandle_val_err(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Log_GetMessagesHandle_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Log_GetMessagesHandle_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_Notice__c06885b33dd04f2be6f95b13c5ed4bc5932fe7b6(kss_decision_t *decision,
                                                                                   kss_eid_t src_eid,
                                                                                   nk_sid_t src_sid,
                                                                                   kss_eid_t dst_eid,
                                                                                   nk_sid_t dst_sid,
                                                                                   const
                                                                                   struct nk_message *message,
                                                                                   const
                                                                                   struct nk_arena *arena,
                                                                                   struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Notice_Create_mid:
        {
            if (NK_TRUE == kl_core_Notice_Create_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_Create_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_Create_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_SubscribeToObject_mid:
        {
            if (NK_TRUE == kl_core_Notice_SubscribeToObject_val_err(message,
                                                                    arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_SubscribeToObject_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_SubscribeToObject_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_UnsubscribeFromEvent_mid:
        {
            if (NK_TRUE == kl_core_Notice_UnsubscribeFromEvent_val_err(message,
                                                                       arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_UnsubscribeFromEvent_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_UnsubscribeFromEvent_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_UnsubscribeFromObject_mid:
        {
            if (NK_TRUE == kl_core_Notice_UnsubscribeFromObject_val_err(message,
                                                                        arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_UnsubscribeFromObject_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_UnsubscribeFromObject_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_GetEvent_mid:
        {
            if (NK_TRUE == kl_core_Notice_GetEvent_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_GetEvent_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_GetEvent_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_DropAndWake_mid:
        {
            if (NK_TRUE == kl_core_Notice_DropAndWake_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_DropAndWake_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_DropAndWake_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_SetObjectEvent_mid:
        {
            if (NK_TRUE == kl_core_Notice_SetObjectEvent_val_err(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_SetObjectEvent_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_SetObjectEvent_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_PM__929ece837b8a4cad967d61fd11b2a993aa452306(kss_decision_t *decision,
                                                                               kss_eid_t src_eid,
                                                                               nk_sid_t src_sid,
                                                                               kss_eid_t dst_eid,
                                                                               nk_sid_t dst_sid,
                                                                               const
                                                                               struct nk_message *message,
                                                                               const
                                                                               struct nk_arena *arena,
                                                                               struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_PM_Request_mid:
        {
            if (NK_TRUE == kl_core_PM_Request_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_PM_Request_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_PM_Request_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_PM_SetCpusOnline_mid:
        {
            if (NK_TRUE == kl_core_PM_SetCpusOnline_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_PM_SetCpusOnline_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_PM_SetCpusOnline_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_PM_GetCpusOnline_mid:
        {
            if (NK_TRUE == kl_core_PM_GetCpusOnline_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_PM_GetCpusOnline_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_PM_GetCpusOnline_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_Profiler__ee45805d647463c80c226e762f8e2e4cc2a299f7(kss_decision_t *decision,
                                                                                     kss_eid_t src_eid,
                                                                                     nk_sid_t src_sid,
                                                                                     kss_eid_t dst_eid,
                                                                                     nk_sid_t dst_sid,
                                                                                     const
                                                                                     struct nk_message *message,
                                                                                     const
                                                                                     struct nk_arena *arena,
                                                                                     struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Profiler_GetCoverageData_mid:
        {
            if (NK_TRUE == kl_core_Profiler_GetCoverageData_val_err(message,
                                                                    arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_GetCoverageData_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_GetCoverageData_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_FlushGcov_mid:
        {
            if (NK_TRUE == kl_core_Profiler_FlushGcov_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_FlushGcov_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_FlushGcov_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_FlushGcovFile_mid:
        {
            if (NK_TRUE == kl_core_Profiler_FlushGcovFile_val_err(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_FlushGcovFile_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_FlushGcovFile_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_GetCounters_mid:
        {
            if (NK_TRUE == kl_core_Profiler_GetCounters_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_GetCounters_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_GetCounters_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_ObjectGetStat_mid:
        {
            if (NK_TRUE == kl_core_Profiler_ObjectGetStat_val_err(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_ObjectGetStat_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_ObjectGetStat_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingStart_mid:
        {
            if (NK_TRUE == kl_core_Profiler_SamplingStart_val_err(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingStart_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingStart_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingStop_mid:
        {
            if (NK_TRUE == kl_core_Profiler_SamplingStop_val_err(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingStop_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingStop_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingRead_mid:
        {
            if (NK_TRUE == kl_core_Profiler_SamplingRead_val_err(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingRead_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingRead_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingAddPidToList_mid:
        {
            if (NK_TRUE ==
                kl_core_Profiler_SamplingAddPidToList_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingAddPidToList_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingAddPidToList_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingClearPidList_mid:
        {
            if (NK_TRUE ==
                kl_core_Profiler_SamplingClearPidList_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingClearPidList_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingClearPidList_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_LoadSegInfo_mid:
        {
            if (NK_TRUE == kl_core_Profiler_LoadSegInfo_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_LoadSegInfo_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_LoadSegInfo_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_UnloadSegInfo_mid:
        {
            if (NK_TRUE == kl_core_Profiler_UnloadSegInfo_val_err(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_UnloadSegInfo_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_UnloadSegInfo_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_KcovAlloc_mid:
        {
            if (NK_TRUE == kl_core_Profiler_KcovAlloc_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_KcovAlloc_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_KcovAlloc_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_KcovFree_mid:
        {
            if (NK_TRUE == kl_core_Profiler_KcovFree_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_KcovFree_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_KcovFree_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_KcovStart_mid:
        {
            if (NK_TRUE == kl_core_Profiler_KcovStart_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_KcovStart_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_KcovStart_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_KcovStop_mid:
        {
            if (NK_TRUE == kl_core_Profiler_KcovStop_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_KcovStop_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_KcovStop_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_Sync__162da361746c1842f44fcea945d10e6019428afe(kss_decision_t *decision,
                                                                                 kss_eid_t src_eid,
                                                                                 nk_sid_t src_sid,
                                                                                 kss_eid_t dst_eid,
                                                                                 nk_sid_t dst_sid,
                                                                                 const
                                                                                 struct nk_message *message,
                                                                                 const
                                                                                 struct nk_arena *arena,
                                                                                 struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Sync_Wait_mid:
        {
            if (NK_TRUE == kl_core_Sync_Wait_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Sync_Wait_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Sync_Wait_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Sync_Wake_mid:
        {
            if (NK_TRUE == kl_core_Sync_Wake_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Sync_Wake_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Sync_Wake_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_TaskDebug__074f7853ddeff8af0ba67c543527a5201c51361e(kss_decision_t *decision,
                                                                                      kss_eid_t src_eid,
                                                                                      nk_sid_t src_sid,
                                                                                      kss_eid_t dst_eid,
                                                                                      nk_sid_t dst_sid,
                                                                                      const
                                                                                      struct nk_message *message,
                                                                                      const
                                                                                      struct nk_arena *arena,
                                                                                      struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_TaskDebug_GetHandlesCount_mid:
        {
            if (NK_TRUE == kl_core_TaskDebug_GetHandlesCount_val_err(message,
                                                                     arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_GetHandlesCount_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_GetHandlesCount_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_TaskDebug_GetHandles_mid:
        {
            if (NK_TRUE == kl_core_TaskDebug_GetHandles_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_GetHandles_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_GetHandles_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_TaskDebug_GetHandleInfo_mid:
        {
            if (NK_TRUE == kl_core_TaskDebug_GetHandleInfo_val_err(message,
                                                                   arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_GetHandleInfo_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_GetHandleInfo_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_TaskDebug_EnableHandleTracing_mid:
        {
            if (NK_TRUE ==
                kl_core_TaskDebug_EnableHandleTracing_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_EnableHandleTracing_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_EnableHandleTracing_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_TaskDebug_DisableHandleTracing_mid:
        {
            if (NK_TRUE ==
                kl_core_TaskDebug_DisableHandleTracing_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_DisableHandleTracing_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_DisableHandleTracing_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_Task__e138f630c31ff6706136636848b4f54a30b9bb3a(kss_decision_t *decision,
                                                                                 kss_eid_t src_eid,
                                                                                 nk_sid_t src_sid,
                                                                                 kss_eid_t dst_eid,
                                                                                 nk_sid_t dst_sid,
                                                                                 const
                                                                                 struct nk_message *message,
                                                                                 const
                                                                                 struct nk_arena *arena,
                                                                                 struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Task_Create_mid:
        {
            if (NK_TRUE == kl_core_Task_Create_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_Create_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_Create_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_LoadSeg_mid:
        {
            if (NK_TRUE == kl_core_Task_LoadSeg_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_LoadSeg_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_LoadSeg_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_VmReserve_mid:
        {
            if (NK_TRUE == kl_core_Task_VmReserve_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_VmReserve_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_VmReserve_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_VmFree_mid:
        {
            if (NK_TRUE == kl_core_Task_VmFree_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_VmFree_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_VmFree_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_SetEntry_mid:
        {
            if (NK_TRUE == kl_core_Task_SetEntry_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_SetEntry_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_SetEntry_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_LoadElfSyms_mid:
        {
            if (NK_TRUE == kl_core_Task_LoadElfSyms_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_LoadElfSyms_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_LoadElfSyms_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_LoadElfHdr_mid:
        {
            if (NK_TRUE == kl_core_Task_LoadElfHdr_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_LoadElfHdr_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_LoadElfHdr_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_SetEnv_mid:
        {
            if (NK_TRUE == kl_core_Task_SetEnv_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_SetEnv_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_SetEnv_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_FreeSelfEnv_mid:
        {
            if (NK_TRUE == kl_core_Task_FreeSelfEnv_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_FreeSelfEnv_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_FreeSelfEnv_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_Resume_mid:
        {
            if (NK_TRUE == kl_core_Task_Resume_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_Resume_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_Resume_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_Exit_mid:
        {
            if (NK_TRUE == kl_core_Task_Exit_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_Exit_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_Exit_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_Terminate_mid:
        {
            if (NK_TRUE == kl_core_Task_Terminate_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_Terminate_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_Terminate_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetExitInfo_mid:
        {
            if (NK_TRUE == kl_core_Task_GetExitInfo_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetExitInfo_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetExitInfo_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetThreadContext_mid:
        {
            if (NK_TRUE == kl_core_Task_GetThreadContext_val_err(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetThreadContext_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetThreadContext_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetNextVmRegion_mid:
        {
            if (NK_TRUE == kl_core_Task_GetNextVmRegion_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetNextVmRegion_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetNextVmRegion_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_TerminateAfterFreezing_mid:
        {
            if (NK_TRUE == kl_core_Task_TerminateAfterFreezing_val_err(message,
                                                                       arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_TerminateAfterFreezing_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_TerminateAfterFreezing_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetName_mid:
        {
            if (NK_TRUE == kl_core_Task_GetName_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetName_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetName_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetPath_mid:
        {
            if (NK_TRUE == kl_core_Task_GetPath_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetPath_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetPath_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetInitialThreadPriority_mid:
        {
            if (NK_TRUE ==
                kl_core_Task_GetInitialThreadPriority_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetInitialThreadPriority_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetInitialThreadPriority_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_SetInitialThreadPriority_mid:
        {
            if (NK_TRUE ==
                kl_core_Task_SetInitialThreadPriority_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_SetInitialThreadPriority_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_SetInitialThreadPriority_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetTasksList_mid:
        {
            if (NK_TRUE == kl_core_Task_GetTasksList_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetTasksList_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetTasksList_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_SetInitialThreadSchedPolicy_mid:
        {
            if (NK_TRUE ==
                kl_core_Task_SetInitialThreadSchedPolicy_val_err(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_SetInitialThreadSchedPolicy_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_SetInitialThreadSchedPolicy_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_ReseedAslr_mid:
        {
            if (NK_TRUE == kl_core_Task_ReseedAslr_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_ReseedAslr_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_ReseedAslr_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetElfSyms_mid:
        {
            if (NK_TRUE == kl_core_Task_GetElfSyms_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetElfSyms_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetElfSyms_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_TransferHandle_mid:
        {
            if (NK_TRUE == kl_core_Task_TransferHandle_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_TransferHandle_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_TransferHandle_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetPid_mid:
        {
            if (NK_TRUE == kl_core_Task_GetPid_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetPid_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetPid_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_Thread__908ab87422c99c003e4d3c9ae36a9829f3dcf503(kss_decision_t *decision,
                                                                                   kss_eid_t src_eid,
                                                                                   nk_sid_t src_sid,
                                                                                   kss_eid_t dst_eid,
                                                                                   nk_sid_t dst_sid,
                                                                                   const
                                                                                   struct nk_message *message,
                                                                                   const
                                                                                   struct nk_arena *arena,
                                                                                   struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Thread_Create_mid:
        {
            if (NK_TRUE == kl_core_Thread_Create_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Create_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Create_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_OpenCurrent_mid:
        {
            if (NK_TRUE == kl_core_Thread_OpenCurrent_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_OpenCurrent_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_OpenCurrent_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Attach_mid:
        {
            if (NK_TRUE == kl_core_Thread_Attach_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Attach_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Attach_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Suspend_mid:
        {
            if (NK_TRUE == kl_core_Thread_Suspend_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Suspend_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Suspend_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Resume_mid:
        {
            if (NK_TRUE == kl_core_Thread_Resume_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Resume_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Resume_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Terminate_mid:
        {
            if (NK_TRUE == kl_core_Thread_Terminate_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Terminate_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Terminate_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Exit_mid:
        {
            if (NK_TRUE == kl_core_Thread_Exit_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Exit_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Exit_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Wait_mid:
        {
            if (NK_TRUE == kl_core_Thread_Wait_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Wait_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Wait_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_SetPriority_mid:
        {
            if (NK_TRUE == kl_core_Thread_SetPriority_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_SetPriority_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_SetPriority_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_SetTls_mid:
        {
            if (NK_TRUE == kl_core_Thread_SetTls_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_SetTls_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_SetTls_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Sleep_mid:
        {
            if (NK_TRUE == kl_core_Thread_Sleep_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Sleep_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Sleep_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_GetInfo_mid:
        {
            if (NK_TRUE == kl_core_Thread_GetInfo_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_GetInfo_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_GetInfo_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_DetachIrq_mid:
        {
            if (NK_TRUE == kl_core_Thread_DetachIrq_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_DetachIrq_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_DetachIrq_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_GetAffinity_mid:
        {
            if (NK_TRUE == kl_core_Thread_GetAffinity_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_GetAffinity_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_GetAffinity_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_SetAffinity_mid:
        {
            if (NK_TRUE == kl_core_Thread_SetAffinity_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_SetAffinity_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_SetAffinity_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_SetSchedPolicy_mid:
        {
            if (NK_TRUE == kl_core_Thread_SetSchedPolicy_val_err(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_SetSchedPolicy_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_SetSchedPolicy_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_GetSchedPolicy_mid:
        {
            if (NK_TRUE == kl_core_Thread_GetSchedPolicy_val_err(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_GetSchedPolicy_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_GetSchedPolicy_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_Time__b03d2ee978febf96e918036eb2edf4f82dc04a93(kss_decision_t *decision,
                                                                                 kss_eid_t src_eid,
                                                                                 nk_sid_t src_sid,
                                                                                 kss_eid_t dst_eid,
                                                                                 nk_sid_t dst_sid,
                                                                                 const
                                                                                 struct nk_message *message,
                                                                                 const
                                                                                 struct nk_arena *arena,
                                                                                 struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Time_SetSystemTime_mid:
        {
            if (NK_TRUE == kl_core_Time_SetSystemTime_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Time_SetSystemTime_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Time_SetSystemTime_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Time_SetSystemTimeAdj_mid:
        {
            if (NK_TRUE == kl_core_Time_SetSystemTimeAdj_val_err(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Time_SetSystemTimeAdj_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Time_SetSystemTimeAdj_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Time_GetSystemTimeAdj_mid:
        {
            if (NK_TRUE == kl_core_Time_GetSystemTimeAdj_val_err(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Time_GetSystemTimeAdj_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Time_GetSystemTimeAdj_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_VMM__a78ac7b765c242a895fe647c4df9b3fbb1e3e302(kss_decision_t *decision,
                                                                                kss_eid_t src_eid,
                                                                                nk_sid_t src_sid,
                                                                                kss_eid_t dst_eid,
                                                                                nk_sid_t dst_sid,
                                                                                const
                                                                                struct nk_message *message,
                                                                                const
                                                                                struct nk_arena *arena,
                                                                                struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_VMM_Allocate_mid:
        {
            if (NK_TRUE == kl_core_VMM_Allocate_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Allocate_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Allocate_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Commit_mid:
        {
            if (NK_TRUE == kl_core_VMM_Commit_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Commit_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Commit_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Decommit_mid:
        {
            if (NK_TRUE == kl_core_VMM_Decommit_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Decommit_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Decommit_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Protect_mid:
        {
            if (NK_TRUE == kl_core_VMM_Protect_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Protect_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Protect_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Free_mid:
        {
            if (NK_TRUE == kl_core_VMM_Free_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Free_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Free_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Query_mid:
        {
            if (NK_TRUE == kl_core_VMM_Query_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Query_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Query_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Reset_mid:
        {
            if (NK_TRUE == kl_core_VMM_Reset_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Reset_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Reset_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlCreate_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlCreate_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlCreate_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlCreate_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlCreateFromVm_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlCreateFromVm_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlCreateFromVm_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlCreateFromVm_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlGetSize_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlGetSize_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlGetSize_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlGetSize_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlMap_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlMap_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlMap_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlMap_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlClone_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlClone_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlClone_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlClone_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Error__kl_core_XHCIDBG__66fb525d8309c5ff603aef64b013768fe866d368(kss_decision_t *decision,
                                                                                    kss_eid_t src_eid,
                                                                                    nk_sid_t src_sid,
                                                                                    kss_eid_t dst_eid,
                                                                                    nk_sid_t dst_sid,
                                                                                    const
                                                                                    struct nk_message *message,
                                                                                    const
                                                                                    struct nk_arena *arena,
                                                                                    struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_XHCIDBG_Start_mid:
        {
            if (NK_TRUE == kl_core_XHCIDBG_Start_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_XHCIDBG_Start_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_XHCIDBG_Start_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_XHCIDBG_Stop_mid:
        {
            if (NK_TRUE == kl_core_XHCIDBG_Stop_val_err(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_XHCIDBG_Stop_val_err");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_XHCIDBG_Stop_val_err");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Execute__nk_Execute__9ec7c875d839e5a1b9e4472c3dcb74d7a82d9331(kss_decision_t *decision,
                                                                                 kss_eid_t src_eid,
                                                                                 nk_sid_t src_sid,
                                                                                 kss_eid_t dst_eid,
                                                                                 nk_sid_t dst_sid,
                                                                                 const
                                                                                 struct nk_message *message,
                                                                                 const
                                                                                 struct nk_arena *arena,
                                                                                 struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "Execute call, mid: %d", message->mid);
    switch (message->mid) {
        
      case nk_Execute_run_mid:
        {
            if (NK_TRUE == nk_Execute_run_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "nk_Execute_run_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "nk_Execute_run_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_Audit__30b0af43ff347699df7ad7d939bbdc1d76359870(kss_decision_t *decision,
                                                                                    kss_eid_t src_eid,
                                                                                    nk_sid_t src_sid,
                                                                                    kss_eid_t dst_eid,
                                                                                    nk_sid_t dst_sid,
                                                                                    const
                                                                                    struct nk_message *message,
                                                                                    const
                                                                                    struct nk_arena *arena,
                                                                                    struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Audit_Open_mid:
        {
            if (NK_TRUE == kl_core_Audit_Open_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Audit_Open_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Audit_Open_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Audit_Close_mid:
        {
            if (NK_TRUE == kl_core_Audit_Close_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Audit_Close_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Audit_Close_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Audit_Read_mid:
        {
            if (NK_TRUE == kl_core_Audit_Read_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Audit_Read_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Audit_Read_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_CM__20ff06f6a3549d82411710ce8095d44dacbf9b0d(kss_decision_t *decision,
                                                                                 kss_eid_t src_eid,
                                                                                 nk_sid_t src_sid,
                                                                                 kss_eid_t dst_eid,
                                                                                 nk_sid_t dst_sid,
                                                                                 const
                                                                                 struct nk_message *message,
                                                                                 const
                                                                                 struct nk_arena *arena,
                                                                                 struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_CM_Connect_mid:
        {
            if (NK_TRUE == kl_core_CM_Connect_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_CM_Connect_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_CM_Connect_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_CM_Listen_mid:
        {
            if (NK_TRUE == kl_core_CM_Listen_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_CM_Listen_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_CM_Listen_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_CM_Drop_mid:
        {
            if (NK_TRUE == kl_core_CM_Drop_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_CM_Drop_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_CM_Drop_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_CM_Accept_mid:
        {
            if (NK_TRUE == kl_core_CM_Accept_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_CM_Accept_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_CM_Accept_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_Efi__5f1cde4cd229d66d367f33bec3d44381192ab039(kss_decision_t *decision,
                                                                                  kss_eid_t src_eid,
                                                                                  nk_sid_t src_sid,
                                                                                  kss_eid_t dst_eid,
                                                                                  nk_sid_t dst_sid,
                                                                                  const
                                                                                  struct nk_message *message,
                                                                                  const
                                                                                  struct nk_arena *arena,
                                                                                  struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Efi_GetTime_mid:
        {
            if (NK_TRUE == kl_core_Efi_GetTime_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_GetTime_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_GetTime_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_SetTime_mid:
        {
            if (NK_TRUE == kl_core_Efi_SetTime_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_SetTime_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_SetTime_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_GetVariable_mid:
        {
            if (NK_TRUE == kl_core_Efi_GetVariable_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_GetVariable_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_GetVariable_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_GetNextVariableName_mid:
        {
            if (NK_TRUE == kl_core_Efi_GetNextVariableName_val_req(message,
                                                                   arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_GetNextVariableName_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_GetNextVariableName_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_SetVariable_mid:
        {
            if (NK_TRUE == kl_core_Efi_SetVariable_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_SetVariable_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_SetVariable_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_QueryVariableInfo_mid:
        {
            if (NK_TRUE == kl_core_Efi_QueryVariableInfo_val_req(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_QueryVariableInfo_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_QueryVariableInfo_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_ResetSystem_mid:
        {
            if (NK_TRUE == kl_core_Efi_ResetSystem_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_ResetSystem_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_ResetSystem_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_FSUnsafe__755206e70fc72efec82d5ca08b4a2c1516459a22(kss_decision_t *decision,
                                                                                       kss_eid_t src_eid,
                                                                                       nk_sid_t src_sid,
                                                                                       kss_eid_t dst_eid,
                                                                                       nk_sid_t dst_sid,
                                                                                       const
                                                                                       struct nk_message *message,
                                                                                       const
                                                                                       struct nk_arena *arena,
                                                                                       struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_FSUnsafe_Change_mid:
        {
            if (NK_TRUE == kl_core_FSUnsafe_Change_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FSUnsafe_Change_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FSUnsafe_Change_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_FS__e19b8cb0ac46d90a250068c9ca8626fe6fe5cc14(kss_decision_t *decision,
                                                                                 kss_eid_t src_eid,
                                                                                 nk_sid_t src_sid,
                                                                                 kss_eid_t dst_eid,
                                                                                 nk_sid_t dst_sid,
                                                                                 const
                                                                                 struct nk_message *message,
                                                                                 const
                                                                                 struct nk_arena *arena,
                                                                                 struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_FS_Open_mid:
        {
            if (NK_TRUE == kl_core_FS_Open_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_Open_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_Open_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_Close_mid:
        {
            if (NK_TRUE == kl_core_FS_Close_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_Close_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_Close_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_Read_mid:
        {
            if (NK_TRUE == kl_core_FS_Read_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_Read_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_Read_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_GetSize_mid:
        {
            if (NK_TRUE == kl_core_FS_GetSize_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_GetSize_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_GetSize_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_GetId_mid:
        {
            if (NK_TRUE == kl_core_FS_GetId_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_GetId_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_GetId_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_Count_mid:
        {
            if (NK_TRUE == kl_core_FS_Count_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_Count_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_Count_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_GetInfo_mid:
        {
            if (NK_TRUE == kl_core_FS_GetInfo_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_GetInfo_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_GetInfo_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_GetFsSize_mid:
        {
            if (NK_TRUE == kl_core_FS_GetFsSize_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_GetFsSize_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_GetFsSize_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_HAL__5d6aa03c6b953727636e7b40b6a9176d8f84ac81(kss_decision_t *decision,
                                                                                  kss_eid_t src_eid,
                                                                                  nk_sid_t src_sid,
                                                                                  kss_eid_t dst_eid,
                                                                                  nk_sid_t dst_sid,
                                                                                  const
                                                                                  struct nk_message *message,
                                                                                  const
                                                                                  struct nk_arena *arena,
                                                                                  struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_HAL_GetEnv_mid:
        {
            if (NK_TRUE == kl_core_HAL_GetEnv_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_GetEnv_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_GetEnv_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_GetPrivReg_mid:
        {
            if (NK_TRUE == kl_core_HAL_GetPrivReg_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_GetPrivReg_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_GetPrivReg_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_SetPrivReg_mid:
        {
            if (NK_TRUE == kl_core_HAL_SetPrivReg_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_SetPrivReg_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_SetPrivReg_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_GetPrivRegRange_mid:
        {
            if (NK_TRUE == kl_core_HAL_GetPrivRegRange_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_GetPrivRegRange_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_GetPrivRegRange_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_SetPrivRegRange_mid:
        {
            if (NK_TRUE == kl_core_HAL_SetPrivRegRange_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_SetPrivRegRange_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_SetPrivRegRange_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_FlushCache_mid:
        {
            if (NK_TRUE == kl_core_HAL_FlushCache_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_FlushCache_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_FlushCache_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_DebugWrite_mid:
        {
            if (NK_TRUE == kl_core_HAL_DebugWrite_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_DebugWrite_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_DebugWrite_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_GetEntropy_mid:
        {
            if (NK_TRUE == kl_core_HAL_GetEntropy_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_GetEntropy_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_GetEntropy_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_Handle__774bfd78165bf037edadf4bff244e5f2c6e2a09c(kss_decision_t *decision,
                                                                                     kss_eid_t src_eid,
                                                                                     nk_sid_t src_sid,
                                                                                     kss_eid_t dst_eid,
                                                                                     nk_sid_t dst_sid,
                                                                                     const
                                                                                     struct nk_message *message,
                                                                                     const
                                                                                     struct nk_arena *arena,
                                                                                     struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Handle_Alloc_mid:
        {
            if (NK_TRUE == kl_core_Handle_Alloc_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Alloc_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Alloc_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Free_mid:
        {
            if (NK_TRUE == kl_core_Handle_Free_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Free_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Free_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Copy_mid:
        {
            if (NK_TRUE == kl_core_Handle_Copy_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Copy_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Copy_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Init_mid:
        {
            if (NK_TRUE == kl_core_Handle_Init_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Init_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Init_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Fini_mid:
        {
            if (NK_TRUE == kl_core_Handle_Fini_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Fini_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Fini_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_CreateUserObject_mid:
        {
            if (NK_TRUE == kl_core_Handle_CreateUserObject_val_req(message,
                                                                   arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_CreateUserObject_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_CreateUserObject_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Close_mid:
        {
            if (NK_TRUE == kl_core_Handle_Close_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Close_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Close_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Connect_mid:
        {
            if (NK_TRUE == kl_core_Handle_Connect_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Connect_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Connect_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Disconnect_mid:
        {
            if (NK_TRUE == kl_core_Handle_Disconnect_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Disconnect_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Disconnect_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_SecurityConnect_mid:
        {
            if (NK_TRUE == kl_core_Handle_SecurityConnect_val_req(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_SecurityConnect_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_SecurityConnect_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_UidAlloc_mid:
        {
            if (NK_TRUE == kl_core_Handle_UidAlloc_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_UidAlloc_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_UidAlloc_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_UidFree_mid:
        {
            if (NK_TRUE == kl_core_Handle_UidFree_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_UidFree_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_UidFree_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_GetSidByHandle_mid:
        {
            if (NK_TRUE == kl_core_Handle_GetSidByHandle_val_req(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_GetSidByHandle_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_GetSidByHandle_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Revoke_mid:
        {
            if (NK_TRUE == kl_core_Handle_Revoke_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Revoke_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Revoke_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_RevokeSubtree_mid:
        {
            if (NK_TRUE == kl_core_Handle_RevokeSubtree_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_RevokeSubtree_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_RevokeSubtree_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_CreateBadge_mid:
        {
            if (NK_TRUE == kl_core_Handle_CreateBadge_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_CreateBadge_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_CreateBadge_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_IOMMU__383215b2bffedc87ae6745a74d93cb4eea886512(kss_decision_t *decision,
                                                                                    kss_eid_t src_eid,
                                                                                    nk_sid_t src_sid,
                                                                                    kss_eid_t dst_eid,
                                                                                    nk_sid_t dst_sid,
                                                                                    const
                                                                                    struct nk_message *message,
                                                                                    const
                                                                                    struct nk_arena *arena,
                                                                                    struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_IOMMU_Attach_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_Attach_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_Attach_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_Attach_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IOMMU_Detach_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_Detach_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_Detach_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_Detach_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IOMMU_CreateDomain_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_CreateDomain_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_CreateDomain_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_CreateDomain_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IOMMU_AttachToDomain_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_AttachToDomain_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_AttachToDomain_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_AttachToDomain_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IOMMU_DetachFromDomain_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_DetachFromDomain_val_req(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_DetachFromDomain_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_DetachFromDomain_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_IO__4cc46f0a31ce4ba7b375c70fac8d2c51fcf7ed85(kss_decision_t *decision,
                                                                                 kss_eid_t src_eid,
                                                                                 nk_sid_t src_sid,
                                                                                 kss_eid_t dst_eid,
                                                                                 nk_sid_t dst_sid,
                                                                                 const
                                                                                 struct nk_message *message,
                                                                                 const
                                                                                 struct nk_arena *arena,
                                                                                 struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_IO_RegisterPort_mid:
        {
            if (NK_TRUE == kl_core_IO_RegisterPort_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RegisterPort_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RegisterPort_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_RegisterMmio_mid:
        {
            if (NK_TRUE == kl_core_IO_RegisterMmio_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RegisterMmio_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RegisterMmio_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_RegisterDma_mid:
        {
            if (NK_TRUE == kl_core_IO_RegisterDma_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RegisterDma_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RegisterDma_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_RegisterIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_RegisterIrq_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RegisterIrq_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RegisterIrq_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_RevokeResource_mid:
        {
            if (NK_TRUE == kl_core_IO_RevokeResource_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RevokeResource_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RevokeResource_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_MapMem_mid:
        {
            if (NK_TRUE == kl_core_IO_MapMem_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_MapMem_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_MapMem_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_PermitPort_mid:
        {
            if (NK_TRUE == kl_core_IO_PermitPort_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_PermitPort_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_PermitPort_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_AttachIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_AttachIrq_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_AttachIrq_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_AttachIrq_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_DetachIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_DetachIrq_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_DetachIrq_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_DetachIrq_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_EnableIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_EnableIrq_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_EnableIrq_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_EnableIrq_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_DisableIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_DisableIrq_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_DisableIrq_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_DisableIrq_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_ModifyDma_mid:
        {
            if (NK_TRUE == kl_core_IO_ModifyDma_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_ModifyDma_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_ModifyDma_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_MapDma_mid:
        {
            if (NK_TRUE == kl_core_IO_MapDma_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_MapDma_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_MapDma_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_DmaGetInfo_mid:
        {
            if (NK_TRUE == kl_core_IO_DmaGetInfo_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_DmaGetInfo_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_DmaGetInfo_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_DmaGetPhysInfo_mid:
        {
            if (NK_TRUE == kl_core_IO_DmaGetPhysInfo_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_DmaGetPhysInfo_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_DmaGetPhysInfo_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_BeginDma_mid:
        {
            if (NK_TRUE == kl_core_IO_BeginDma_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_BeginDma_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_BeginDma_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_IPC__d34dc2cf5abce4af1039c67e2f4ff98dd17c498b(kss_decision_t *decision,
                                                                                  kss_eid_t src_eid,
                                                                                  nk_sid_t src_sid,
                                                                                  kss_eid_t dst_eid,
                                                                                  nk_sid_t dst_sid,
                                                                                  const
                                                                                  struct nk_message *message,
                                                                                  const
                                                                                  struct nk_arena *arena,
                                                                                  struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_IPC_CreateSyncObject_mid:
        {
            if (NK_TRUE == kl_core_IPC_CreateSyncObject_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IPC_CreateSyncObject_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IPC_CreateSyncObject_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IPC_SetInterrupt_mid:
        {
            if (NK_TRUE == kl_core_IPC_SetInterrupt_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IPC_SetInterrupt_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IPC_SetInterrupt_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IPC_ClearInterrupt_mid:
        {
            if (NK_TRUE == kl_core_IPC_ClearInterrupt_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IPC_ClearInterrupt_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IPC_ClearInterrupt_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_Log__c93f30f7e5723193f2035e6a7531cd4401916969(kss_decision_t *decision,
                                                                                  kss_eid_t src_eid,
                                                                                  nk_sid_t src_sid,
                                                                                  kss_eid_t dst_eid,
                                                                                  nk_sid_t dst_sid,
                                                                                  const
                                                                                  struct nk_message *message,
                                                                                  const
                                                                                  struct nk_arena *arena,
                                                                                  struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Log_Handoff_mid:
        {
            if (NK_TRUE == kl_core_Log_Handoff_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Log_Handoff_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Log_Handoff_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Log_FetchMessages_mid:
        {
            if (NK_TRUE == kl_core_Log_FetchMessages_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Log_FetchMessages_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Log_FetchMessages_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Log_GetMessagesHandle_mid:
        {
            if (NK_TRUE == kl_core_Log_GetMessagesHandle_val_req(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Log_GetMessagesHandle_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Log_GetMessagesHandle_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_Notice__17358c558b7ee6311f3c4f63262cd4df3104befa(kss_decision_t *decision,
                                                                                     kss_eid_t src_eid,
                                                                                     nk_sid_t src_sid,
                                                                                     kss_eid_t dst_eid,
                                                                                     nk_sid_t dst_sid,
                                                                                     const
                                                                                     struct nk_message *message,
                                                                                     const
                                                                                     struct nk_arena *arena,
                                                                                     struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Notice_Create_mid:
        {
            if (NK_TRUE == kl_core_Notice_Create_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_Create_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_Create_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_SubscribeToObject_mid:
        {
            if (NK_TRUE == kl_core_Notice_SubscribeToObject_val_req(message,
                                                                    arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_SubscribeToObject_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_SubscribeToObject_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_UnsubscribeFromEvent_mid:
        {
            if (NK_TRUE == kl_core_Notice_UnsubscribeFromEvent_val_req(message,
                                                                       arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_UnsubscribeFromEvent_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_UnsubscribeFromEvent_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_UnsubscribeFromObject_mid:
        {
            if (NK_TRUE == kl_core_Notice_UnsubscribeFromObject_val_req(message,
                                                                        arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_UnsubscribeFromObject_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_UnsubscribeFromObject_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_GetEvent_mid:
        {
            if (NK_TRUE == kl_core_Notice_GetEvent_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_GetEvent_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_GetEvent_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_DropAndWake_mid:
        {
            if (NK_TRUE == kl_core_Notice_DropAndWake_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_DropAndWake_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_DropAndWake_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_SetObjectEvent_mid:
        {
            if (NK_TRUE == kl_core_Notice_SetObjectEvent_val_req(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_SetObjectEvent_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_SetObjectEvent_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_PM__aa509a2f41137874a757461322666016419b24bc(kss_decision_t *decision,
                                                                                 kss_eid_t src_eid,
                                                                                 nk_sid_t src_sid,
                                                                                 kss_eid_t dst_eid,
                                                                                 nk_sid_t dst_sid,
                                                                                 const
                                                                                 struct nk_message *message,
                                                                                 const
                                                                                 struct nk_arena *arena,
                                                                                 struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_PM_Request_mid:
        {
            if (NK_TRUE == kl_core_PM_Request_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_PM_Request_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_PM_Request_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_PM_SetCpusOnline_mid:
        {
            if (NK_TRUE == kl_core_PM_SetCpusOnline_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_PM_SetCpusOnline_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_PM_SetCpusOnline_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_PM_GetCpusOnline_mid:
        {
            if (NK_TRUE == kl_core_PM_GetCpusOnline_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_PM_GetCpusOnline_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_PM_GetCpusOnline_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_Profiler__41078ec5de2cf866098147885d622026e4db94d5(kss_decision_t *decision,
                                                                                       kss_eid_t src_eid,
                                                                                       nk_sid_t src_sid,
                                                                                       kss_eid_t dst_eid,
                                                                                       nk_sid_t dst_sid,
                                                                                       const
                                                                                       struct nk_message *message,
                                                                                       const
                                                                                       struct nk_arena *arena,
                                                                                       struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Profiler_GetCoverageData_mid:
        {
            if (NK_TRUE == kl_core_Profiler_GetCoverageData_val_req(message,
                                                                    arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_GetCoverageData_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_GetCoverageData_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_FlushGcov_mid:
        {
            if (NK_TRUE == kl_core_Profiler_FlushGcov_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_FlushGcov_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_FlushGcov_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_FlushGcovFile_mid:
        {
            if (NK_TRUE == kl_core_Profiler_FlushGcovFile_val_req(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_FlushGcovFile_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_FlushGcovFile_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_GetCounters_mid:
        {
            if (NK_TRUE == kl_core_Profiler_GetCounters_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_GetCounters_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_GetCounters_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_ObjectGetStat_mid:
        {
            if (NK_TRUE == kl_core_Profiler_ObjectGetStat_val_req(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_ObjectGetStat_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_ObjectGetStat_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingStart_mid:
        {
            if (NK_TRUE == kl_core_Profiler_SamplingStart_val_req(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingStart_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingStart_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingStop_mid:
        {
            if (NK_TRUE == kl_core_Profiler_SamplingStop_val_req(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingStop_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingStop_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingRead_mid:
        {
            if (NK_TRUE == kl_core_Profiler_SamplingRead_val_req(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingRead_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingRead_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingAddPidToList_mid:
        {
            if (NK_TRUE ==
                kl_core_Profiler_SamplingAddPidToList_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingAddPidToList_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingAddPidToList_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingClearPidList_mid:
        {
            if (NK_TRUE ==
                kl_core_Profiler_SamplingClearPidList_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingClearPidList_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingClearPidList_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_LoadSegInfo_mid:
        {
            if (NK_TRUE == kl_core_Profiler_LoadSegInfo_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_LoadSegInfo_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_LoadSegInfo_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_UnloadSegInfo_mid:
        {
            if (NK_TRUE == kl_core_Profiler_UnloadSegInfo_val_req(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_UnloadSegInfo_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_UnloadSegInfo_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_KcovAlloc_mid:
        {
            if (NK_TRUE == kl_core_Profiler_KcovAlloc_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_KcovAlloc_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_KcovAlloc_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_KcovFree_mid:
        {
            if (NK_TRUE == kl_core_Profiler_KcovFree_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_KcovFree_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_KcovFree_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_KcovStart_mid:
        {
            if (NK_TRUE == kl_core_Profiler_KcovStart_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_KcovStart_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_KcovStart_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_KcovStop_mid:
        {
            if (NK_TRUE == kl_core_Profiler_KcovStop_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_KcovStop_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_KcovStop_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_Sync__6da01def9052fedbb83c77bc125f119761715d7c(kss_decision_t *decision,
                                                                                   kss_eid_t src_eid,
                                                                                   nk_sid_t src_sid,
                                                                                   kss_eid_t dst_eid,
                                                                                   nk_sid_t dst_sid,
                                                                                   const
                                                                                   struct nk_message *message,
                                                                                   const
                                                                                   struct nk_arena *arena,
                                                                                   struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Sync_Wait_mid:
        {
            if (NK_TRUE == kl_core_Sync_Wait_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Sync_Wait_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Sync_Wait_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Sync_Wake_mid:
        {
            if (NK_TRUE == kl_core_Sync_Wake_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Sync_Wake_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Sync_Wake_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_TaskDebug__48b59d2f5602db5d2e630cd908be187fcb3a2faf(kss_decision_t *decision,
                                                                                        kss_eid_t src_eid,
                                                                                        nk_sid_t src_sid,
                                                                                        kss_eid_t dst_eid,
                                                                                        nk_sid_t dst_sid,
                                                                                        const
                                                                                        struct nk_message *message,
                                                                                        const
                                                                                        struct nk_arena *arena,
                                                                                        struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_TaskDebug_GetHandlesCount_mid:
        {
            if (NK_TRUE == kl_core_TaskDebug_GetHandlesCount_val_req(message,
                                                                     arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_GetHandlesCount_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_GetHandlesCount_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_TaskDebug_GetHandles_mid:
        {
            if (NK_TRUE == kl_core_TaskDebug_GetHandles_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_GetHandles_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_GetHandles_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_TaskDebug_GetHandleInfo_mid:
        {
            if (NK_TRUE == kl_core_TaskDebug_GetHandleInfo_val_req(message,
                                                                   arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_GetHandleInfo_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_GetHandleInfo_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_TaskDebug_EnableHandleTracing_mid:
        {
            if (NK_TRUE ==
                kl_core_TaskDebug_EnableHandleTracing_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_EnableHandleTracing_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_EnableHandleTracing_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_TaskDebug_DisableHandleTracing_mid:
        {
            if (NK_TRUE ==
                kl_core_TaskDebug_DisableHandleTracing_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_DisableHandleTracing_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_DisableHandleTracing_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_Task__83009ad2649e40daf39ae2811df777c2a99f3fb0(kss_decision_t *decision,
                                                                                   kss_eid_t src_eid,
                                                                                   nk_sid_t src_sid,
                                                                                   kss_eid_t dst_eid,
                                                                                   nk_sid_t dst_sid,
                                                                                   const
                                                                                   struct nk_message *message,
                                                                                   const
                                                                                   struct nk_arena *arena,
                                                                                   struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Task_Create_mid:
        {
            if (NK_TRUE == kl_core_Task_Create_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_Create_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_Create_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_LoadSeg_mid:
        {
            if (NK_TRUE == kl_core_Task_LoadSeg_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_LoadSeg_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_LoadSeg_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_VmReserve_mid:
        {
            if (NK_TRUE == kl_core_Task_VmReserve_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_VmReserve_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_VmReserve_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_VmFree_mid:
        {
            if (NK_TRUE == kl_core_Task_VmFree_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_VmFree_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_VmFree_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_SetEntry_mid:
        {
            if (NK_TRUE == kl_core_Task_SetEntry_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_SetEntry_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_SetEntry_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_LoadElfSyms_mid:
        {
            if (NK_TRUE == kl_core_Task_LoadElfSyms_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_LoadElfSyms_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_LoadElfSyms_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_LoadElfHdr_mid:
        {
            if (NK_TRUE == kl_core_Task_LoadElfHdr_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_LoadElfHdr_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_LoadElfHdr_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_SetEnv_mid:
        {
            if (NK_TRUE == kl_core_Task_SetEnv_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_SetEnv_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_SetEnv_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_FreeSelfEnv_mid:
        {
            if (NK_TRUE == kl_core_Task_FreeSelfEnv_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_FreeSelfEnv_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_FreeSelfEnv_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_Resume_mid:
        {
            if (NK_TRUE == kl_core_Task_Resume_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_Resume_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_Resume_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_Exit_mid:
        {
            if (NK_TRUE == kl_core_Task_Exit_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_Exit_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_Exit_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_Terminate_mid:
        {
            if (NK_TRUE == kl_core_Task_Terminate_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_Terminate_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_Terminate_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetExitInfo_mid:
        {
            if (NK_TRUE == kl_core_Task_GetExitInfo_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetExitInfo_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetExitInfo_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetThreadContext_mid:
        {
            if (NK_TRUE == kl_core_Task_GetThreadContext_val_req(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetThreadContext_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetThreadContext_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetNextVmRegion_mid:
        {
            if (NK_TRUE == kl_core_Task_GetNextVmRegion_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetNextVmRegion_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetNextVmRegion_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_TerminateAfterFreezing_mid:
        {
            if (NK_TRUE == kl_core_Task_TerminateAfterFreezing_val_req(message,
                                                                       arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_TerminateAfterFreezing_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_TerminateAfterFreezing_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetName_mid:
        {
            if (NK_TRUE == kl_core_Task_GetName_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetName_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetName_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetPath_mid:
        {
            if (NK_TRUE == kl_core_Task_GetPath_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetPath_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetPath_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetInitialThreadPriority_mid:
        {
            if (NK_TRUE ==
                kl_core_Task_GetInitialThreadPriority_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetInitialThreadPriority_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetInitialThreadPriority_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_SetInitialThreadPriority_mid:
        {
            if (NK_TRUE ==
                kl_core_Task_SetInitialThreadPriority_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_SetInitialThreadPriority_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_SetInitialThreadPriority_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetTasksList_mid:
        {
            if (NK_TRUE == kl_core_Task_GetTasksList_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetTasksList_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetTasksList_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_SetInitialThreadSchedPolicy_mid:
        {
            if (NK_TRUE ==
                kl_core_Task_SetInitialThreadSchedPolicy_val_req(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_SetInitialThreadSchedPolicy_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_SetInitialThreadSchedPolicy_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_ReseedAslr_mid:
        {
            if (NK_TRUE == kl_core_Task_ReseedAslr_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_ReseedAslr_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_ReseedAslr_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetElfSyms_mid:
        {
            if (NK_TRUE == kl_core_Task_GetElfSyms_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetElfSyms_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetElfSyms_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_TransferHandle_mid:
        {
            if (NK_TRUE == kl_core_Task_TransferHandle_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_TransferHandle_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_TransferHandle_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetPid_mid:
        {
            if (NK_TRUE == kl_core_Task_GetPid_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetPid_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetPid_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_Thread__8e135981dd8f7c95e81e91275fa0e4ea4870be5e(kss_decision_t *decision,
                                                                                     kss_eid_t src_eid,
                                                                                     nk_sid_t src_sid,
                                                                                     kss_eid_t dst_eid,
                                                                                     nk_sid_t dst_sid,
                                                                                     const
                                                                                     struct nk_message *message,
                                                                                     const
                                                                                     struct nk_arena *arena,
                                                                                     struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Thread_Create_mid:
        {
            if (NK_TRUE == kl_core_Thread_Create_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Create_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Create_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_OpenCurrent_mid:
        {
            if (NK_TRUE == kl_core_Thread_OpenCurrent_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_OpenCurrent_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_OpenCurrent_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Attach_mid:
        {
            if (NK_TRUE == kl_core_Thread_Attach_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Attach_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Attach_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Suspend_mid:
        {
            if (NK_TRUE == kl_core_Thread_Suspend_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Suspend_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Suspend_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Resume_mid:
        {
            if (NK_TRUE == kl_core_Thread_Resume_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Resume_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Resume_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Terminate_mid:
        {
            if (NK_TRUE == kl_core_Thread_Terminate_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Terminate_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Terminate_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Exit_mid:
        {
            if (NK_TRUE == kl_core_Thread_Exit_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Exit_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Exit_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Wait_mid:
        {
            if (NK_TRUE == kl_core_Thread_Wait_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Wait_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Wait_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_SetPriority_mid:
        {
            if (NK_TRUE == kl_core_Thread_SetPriority_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_SetPriority_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_SetPriority_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_SetTls_mid:
        {
            if (NK_TRUE == kl_core_Thread_SetTls_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_SetTls_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_SetTls_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Sleep_mid:
        {
            if (NK_TRUE == kl_core_Thread_Sleep_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Sleep_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Sleep_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_GetInfo_mid:
        {
            if (NK_TRUE == kl_core_Thread_GetInfo_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_GetInfo_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_GetInfo_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_DetachIrq_mid:
        {
            if (NK_TRUE == kl_core_Thread_DetachIrq_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_DetachIrq_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_DetachIrq_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_GetAffinity_mid:
        {
            if (NK_TRUE == kl_core_Thread_GetAffinity_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_GetAffinity_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_GetAffinity_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_SetAffinity_mid:
        {
            if (NK_TRUE == kl_core_Thread_SetAffinity_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_SetAffinity_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_SetAffinity_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_SetSchedPolicy_mid:
        {
            if (NK_TRUE == kl_core_Thread_SetSchedPolicy_val_req(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_SetSchedPolicy_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_SetSchedPolicy_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_GetSchedPolicy_mid:
        {
            if (NK_TRUE == kl_core_Thread_GetSchedPolicy_val_req(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_GetSchedPolicy_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_GetSchedPolicy_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_Time__ecee1c055430d7cbba6d675ee1d85084b518d48d(kss_decision_t *decision,
                                                                                   kss_eid_t src_eid,
                                                                                   nk_sid_t src_sid,
                                                                                   kss_eid_t dst_eid,
                                                                                   nk_sid_t dst_sid,
                                                                                   const
                                                                                   struct nk_message *message,
                                                                                   const
                                                                                   struct nk_arena *arena,
                                                                                   struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Time_SetSystemTime_mid:
        {
            if (NK_TRUE == kl_core_Time_SetSystemTime_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Time_SetSystemTime_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Time_SetSystemTime_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Time_SetSystemTimeAdj_mid:
        {
            if (NK_TRUE == kl_core_Time_SetSystemTimeAdj_val_req(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Time_SetSystemTimeAdj_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Time_SetSystemTimeAdj_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Time_GetSystemTimeAdj_mid:
        {
            if (NK_TRUE == kl_core_Time_GetSystemTimeAdj_val_req(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Time_GetSystemTimeAdj_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Time_GetSystemTimeAdj_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_VMM__9e98540b3cbf2ffea1f6f71f1642f7f230739022(kss_decision_t *decision,
                                                                                  kss_eid_t src_eid,
                                                                                  nk_sid_t src_sid,
                                                                                  kss_eid_t dst_eid,
                                                                                  nk_sid_t dst_sid,
                                                                                  const
                                                                                  struct nk_message *message,
                                                                                  const
                                                                                  struct nk_arena *arena,
                                                                                  struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_VMM_Allocate_mid:
        {
            if (NK_TRUE == kl_core_VMM_Allocate_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Allocate_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Allocate_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Commit_mid:
        {
            if (NK_TRUE == kl_core_VMM_Commit_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Commit_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Commit_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Decommit_mid:
        {
            if (NK_TRUE == kl_core_VMM_Decommit_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Decommit_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Decommit_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Protect_mid:
        {
            if (NK_TRUE == kl_core_VMM_Protect_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Protect_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Protect_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Free_mid:
        {
            if (NK_TRUE == kl_core_VMM_Free_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Free_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Free_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Query_mid:
        {
            if (NK_TRUE == kl_core_VMM_Query_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Query_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Query_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Reset_mid:
        {
            if (NK_TRUE == kl_core_VMM_Reset_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Reset_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Reset_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlCreate_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlCreate_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlCreate_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlCreate_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlCreateFromVm_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlCreateFromVm_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlCreateFromVm_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlCreateFromVm_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlGetSize_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlGetSize_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlGetSize_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlGetSize_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlMap_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlMap_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlMap_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlMap_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlClone_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlClone_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlClone_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlClone_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Request__kl_core_XHCIDBG__4d18006439a671420ef9392077eed16cc064a594(kss_decision_t *decision,
                                                                                      kss_eid_t src_eid,
                                                                                      nk_sid_t src_sid,
                                                                                      kss_eid_t dst_eid,
                                                                                      nk_sid_t dst_sid,
                                                                                      const
                                                                                      struct nk_message *message,
                                                                                      const
                                                                                      struct nk_arena *arena,
                                                                                      struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_XHCIDBG_Start_mid:
        {
            if (NK_TRUE == kl_core_XHCIDBG_Start_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_XHCIDBG_Start_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_XHCIDBG_Start_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_XHCIDBG_Stop_mid:
        {
            if (NK_TRUE == kl_core_XHCIDBG_Stop_val_req(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_XHCIDBG_Stop_val_req");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_XHCIDBG_Stop_val_req");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_Audit__d9d13127fa4d22d5ac2af8b6f76446c8e47b7c38(kss_decision_t *decision,
                                                                                     kss_eid_t src_eid,
                                                                                     nk_sid_t src_sid,
                                                                                     kss_eid_t dst_eid,
                                                                                     nk_sid_t dst_sid,
                                                                                     const
                                                                                     struct nk_message *message,
                                                                                     const
                                                                                     struct nk_arena *arena,
                                                                                     struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Audit_Open_mid:
        {
            if (NK_TRUE == kl_core_Audit_Open_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Audit_Open_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Audit_Open_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Audit_Close_mid:
        {
            if (NK_TRUE == kl_core_Audit_Close_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Audit_Close_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Audit_Close_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Audit_Read_mid:
        {
            if (NK_TRUE == kl_core_Audit_Read_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Audit_Read_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Audit_Read_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_CM__38ab137722ff64a3aa985d5f91cb0e5d6d84969b(kss_decision_t *decision,
                                                                                  kss_eid_t src_eid,
                                                                                  nk_sid_t src_sid,
                                                                                  kss_eid_t dst_eid,
                                                                                  nk_sid_t dst_sid,
                                                                                  const
                                                                                  struct nk_message *message,
                                                                                  const
                                                                                  struct nk_arena *arena,
                                                                                  struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_CM_Connect_mid:
        {
            if (NK_TRUE == kl_core_CM_Connect_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_CM_Connect_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_CM_Connect_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_CM_Listen_mid:
        {
            if (NK_TRUE == kl_core_CM_Listen_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_CM_Listen_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_CM_Listen_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_CM_Drop_mid:
        {
            if (NK_TRUE == kl_core_CM_Drop_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_CM_Drop_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_CM_Drop_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_CM_Accept_mid:
        {
            if (NK_TRUE == kl_core_CM_Accept_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_CM_Accept_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_CM_Accept_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_Efi__48c53ee342548adb934b28633c3b7afd0e11028d(kss_decision_t *decision,
                                                                                   kss_eid_t src_eid,
                                                                                   nk_sid_t src_sid,
                                                                                   kss_eid_t dst_eid,
                                                                                   nk_sid_t dst_sid,
                                                                                   const
                                                                                   struct nk_message *message,
                                                                                   const
                                                                                   struct nk_arena *arena,
                                                                                   struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Efi_GetTime_mid:
        {
            if (NK_TRUE == kl_core_Efi_GetTime_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_GetTime_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_GetTime_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_SetTime_mid:
        {
            if (NK_TRUE == kl_core_Efi_SetTime_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_SetTime_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_SetTime_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_GetVariable_mid:
        {
            if (NK_TRUE == kl_core_Efi_GetVariable_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_GetVariable_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_GetVariable_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_GetNextVariableName_mid:
        {
            if (NK_TRUE == kl_core_Efi_GetNextVariableName_val_res(message,
                                                                   arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_GetNextVariableName_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_GetNextVariableName_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_SetVariable_mid:
        {
            if (NK_TRUE == kl_core_Efi_SetVariable_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_SetVariable_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_SetVariable_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_QueryVariableInfo_mid:
        {
            if (NK_TRUE == kl_core_Efi_QueryVariableInfo_val_res(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_QueryVariableInfo_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_QueryVariableInfo_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Efi_ResetSystem_mid:
        {
            if (NK_TRUE == kl_core_Efi_ResetSystem_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Efi_ResetSystem_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Efi_ResetSystem_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_FSUnsafe__c020e08f678e72fab7652e76dc5e6ad42920685d(kss_decision_t *decision,
                                                                                        kss_eid_t src_eid,
                                                                                        nk_sid_t src_sid,
                                                                                        kss_eid_t dst_eid,
                                                                                        nk_sid_t dst_sid,
                                                                                        const
                                                                                        struct nk_message *message,
                                                                                        const
                                                                                        struct nk_arena *arena,
                                                                                        struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_FSUnsafe_Change_mid:
        {
            if (NK_TRUE == kl_core_FSUnsafe_Change_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FSUnsafe_Change_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FSUnsafe_Change_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_FS__1bf52cea5d66279f1b580f00a01879a36d366883(kss_decision_t *decision,
                                                                                  kss_eid_t src_eid,
                                                                                  nk_sid_t src_sid,
                                                                                  kss_eid_t dst_eid,
                                                                                  nk_sid_t dst_sid,
                                                                                  const
                                                                                  struct nk_message *message,
                                                                                  const
                                                                                  struct nk_arena *arena,
                                                                                  struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_FS_Open_mid:
        {
            if (NK_TRUE == kl_core_FS_Open_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_Open_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_Open_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_Close_mid:
        {
            if (NK_TRUE == kl_core_FS_Close_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_Close_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_Close_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_Read_mid:
        {
            if (NK_TRUE == kl_core_FS_Read_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_Read_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_Read_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_GetSize_mid:
        {
            if (NK_TRUE == kl_core_FS_GetSize_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_GetSize_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_GetSize_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_GetId_mid:
        {
            if (NK_TRUE == kl_core_FS_GetId_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_GetId_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_GetId_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_Count_mid:
        {
            if (NK_TRUE == kl_core_FS_Count_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_Count_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_Count_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_GetInfo_mid:
        {
            if (NK_TRUE == kl_core_FS_GetInfo_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_GetInfo_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_GetInfo_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_FS_GetFsSize_mid:
        {
            if (NK_TRUE == kl_core_FS_GetFsSize_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_FS_GetFsSize_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_FS_GetFsSize_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_HAL__53a7a3f2da521c9fb039f99235b09225ce086dfc(kss_decision_t *decision,
                                                                                   kss_eid_t src_eid,
                                                                                   nk_sid_t src_sid,
                                                                                   kss_eid_t dst_eid,
                                                                                   nk_sid_t dst_sid,
                                                                                   const
                                                                                   struct nk_message *message,
                                                                                   const
                                                                                   struct nk_arena *arena,
                                                                                   struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_HAL_GetEnv_mid:
        {
            if (NK_TRUE == kl_core_HAL_GetEnv_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_GetEnv_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_GetEnv_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_GetPrivReg_mid:
        {
            if (NK_TRUE == kl_core_HAL_GetPrivReg_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_GetPrivReg_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_GetPrivReg_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_SetPrivReg_mid:
        {
            if (NK_TRUE == kl_core_HAL_SetPrivReg_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_SetPrivReg_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_SetPrivReg_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_GetPrivRegRange_mid:
        {
            if (NK_TRUE == kl_core_HAL_GetPrivRegRange_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_GetPrivRegRange_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_GetPrivRegRange_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_SetPrivRegRange_mid:
        {
            if (NK_TRUE == kl_core_HAL_SetPrivRegRange_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_SetPrivRegRange_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_SetPrivRegRange_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_FlushCache_mid:
        {
            if (NK_TRUE == kl_core_HAL_FlushCache_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_FlushCache_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_FlushCache_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_DebugWrite_mid:
        {
            if (NK_TRUE == kl_core_HAL_DebugWrite_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_DebugWrite_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_DebugWrite_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_HAL_GetEntropy_mid:
        {
            if (NK_TRUE == kl_core_HAL_GetEntropy_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_HAL_GetEntropy_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_HAL_GetEntropy_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_Handle__80a5f6b7048dacefcfcdcebb1e8e40fc5c4fe2b8(kss_decision_t *decision,
                                                                                      kss_eid_t src_eid,
                                                                                      nk_sid_t src_sid,
                                                                                      kss_eid_t dst_eid,
                                                                                      nk_sid_t dst_sid,
                                                                                      const
                                                                                      struct nk_message *message,
                                                                                      const
                                                                                      struct nk_arena *arena,
                                                                                      struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Handle_Alloc_mid:
        {
            if (NK_TRUE == kl_core_Handle_Alloc_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Alloc_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Alloc_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Free_mid:
        {
            if (NK_TRUE == kl_core_Handle_Free_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Free_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Free_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Copy_mid:
        {
            if (NK_TRUE == kl_core_Handle_Copy_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Copy_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Copy_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Init_mid:
        {
            if (NK_TRUE == kl_core_Handle_Init_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Init_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Init_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Fini_mid:
        {
            if (NK_TRUE == kl_core_Handle_Fini_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Fini_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Fini_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_CreateUserObject_mid:
        {
            if (NK_TRUE == kl_core_Handle_CreateUserObject_val_res(message,
                                                                   arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_CreateUserObject_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_CreateUserObject_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Close_mid:
        {
            if (NK_TRUE == kl_core_Handle_Close_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Close_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Close_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Connect_mid:
        {
            if (NK_TRUE == kl_core_Handle_Connect_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Connect_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Connect_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Disconnect_mid:
        {
            if (NK_TRUE == kl_core_Handle_Disconnect_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Disconnect_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Disconnect_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_SecurityConnect_mid:
        {
            if (NK_TRUE == kl_core_Handle_SecurityConnect_val_res(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_SecurityConnect_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_SecurityConnect_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_UidAlloc_mid:
        {
            if (NK_TRUE == kl_core_Handle_UidAlloc_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_UidAlloc_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_UidAlloc_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_UidFree_mid:
        {
            if (NK_TRUE == kl_core_Handle_UidFree_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_UidFree_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_UidFree_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_GetSidByHandle_mid:
        {
            if (NK_TRUE == kl_core_Handle_GetSidByHandle_val_res(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_GetSidByHandle_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_GetSidByHandle_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_Revoke_mid:
        {
            if (NK_TRUE == kl_core_Handle_Revoke_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_Revoke_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_Revoke_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_RevokeSubtree_mid:
        {
            if (NK_TRUE == kl_core_Handle_RevokeSubtree_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_RevokeSubtree_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_RevokeSubtree_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Handle_CreateBadge_mid:
        {
            if (NK_TRUE == kl_core_Handle_CreateBadge_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Handle_CreateBadge_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Handle_CreateBadge_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_IOMMU__ad5f2f3c366d39664c3a3187668a89791cc2c38d(kss_decision_t *decision,
                                                                                     kss_eid_t src_eid,
                                                                                     nk_sid_t src_sid,
                                                                                     kss_eid_t dst_eid,
                                                                                     nk_sid_t dst_sid,
                                                                                     const
                                                                                     struct nk_message *message,
                                                                                     const
                                                                                     struct nk_arena *arena,
                                                                                     struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_IOMMU_Attach_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_Attach_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_Attach_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_Attach_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IOMMU_Detach_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_Detach_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_Detach_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_Detach_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IOMMU_CreateDomain_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_CreateDomain_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_CreateDomain_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_CreateDomain_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IOMMU_AttachToDomain_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_AttachToDomain_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_AttachToDomain_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_AttachToDomain_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IOMMU_DetachFromDomain_mid:
        {
            if (NK_TRUE == kl_core_IOMMU_DetachFromDomain_val_res(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IOMMU_DetachFromDomain_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IOMMU_DetachFromDomain_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_IO__9e6310a517abc9a3fea669e539ea4af45bf6ac09(kss_decision_t *decision,
                                                                                  kss_eid_t src_eid,
                                                                                  nk_sid_t src_sid,
                                                                                  kss_eid_t dst_eid,
                                                                                  nk_sid_t dst_sid,
                                                                                  const
                                                                                  struct nk_message *message,
                                                                                  const
                                                                                  struct nk_arena *arena,
                                                                                  struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_IO_RegisterPort_mid:
        {
            if (NK_TRUE == kl_core_IO_RegisterPort_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RegisterPort_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RegisterPort_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_RegisterMmio_mid:
        {
            if (NK_TRUE == kl_core_IO_RegisterMmio_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RegisterMmio_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RegisterMmio_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_RegisterDma_mid:
        {
            if (NK_TRUE == kl_core_IO_RegisterDma_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RegisterDma_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RegisterDma_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_RegisterIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_RegisterIrq_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RegisterIrq_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RegisterIrq_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_RevokeResource_mid:
        {
            if (NK_TRUE == kl_core_IO_RevokeResource_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_RevokeResource_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_RevokeResource_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_MapMem_mid:
        {
            if (NK_TRUE == kl_core_IO_MapMem_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_MapMem_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_MapMem_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_PermitPort_mid:
        {
            if (NK_TRUE == kl_core_IO_PermitPort_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_PermitPort_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_PermitPort_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_AttachIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_AttachIrq_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_AttachIrq_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_AttachIrq_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_DetachIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_DetachIrq_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_DetachIrq_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_DetachIrq_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_EnableIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_EnableIrq_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_EnableIrq_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_EnableIrq_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_DisableIrq_mid:
        {
            if (NK_TRUE == kl_core_IO_DisableIrq_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_DisableIrq_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_DisableIrq_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_ModifyDma_mid:
        {
            if (NK_TRUE == kl_core_IO_ModifyDma_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_ModifyDma_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_ModifyDma_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_MapDma_mid:
        {
            if (NK_TRUE == kl_core_IO_MapDma_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_MapDma_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_MapDma_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_DmaGetInfo_mid:
        {
            if (NK_TRUE == kl_core_IO_DmaGetInfo_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_DmaGetInfo_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_DmaGetInfo_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_DmaGetPhysInfo_mid:
        {
            if (NK_TRUE == kl_core_IO_DmaGetPhysInfo_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_DmaGetPhysInfo_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_DmaGetPhysInfo_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IO_BeginDma_mid:
        {
            if (NK_TRUE == kl_core_IO_BeginDma_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IO_BeginDma_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IO_BeginDma_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_IPC__5e72ad72539079532a5573689ad771676b404d21(kss_decision_t *decision,
                                                                                   kss_eid_t src_eid,
                                                                                   nk_sid_t src_sid,
                                                                                   kss_eid_t dst_eid,
                                                                                   nk_sid_t dst_sid,
                                                                                   const
                                                                                   struct nk_message *message,
                                                                                   const
                                                                                   struct nk_arena *arena,
                                                                                   struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_IPC_CreateSyncObject_mid:
        {
            if (NK_TRUE == kl_core_IPC_CreateSyncObject_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IPC_CreateSyncObject_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IPC_CreateSyncObject_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IPC_SetInterrupt_mid:
        {
            if (NK_TRUE == kl_core_IPC_SetInterrupt_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IPC_SetInterrupt_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IPC_SetInterrupt_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_IPC_ClearInterrupt_mid:
        {
            if (NK_TRUE == kl_core_IPC_ClearInterrupt_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_IPC_ClearInterrupt_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_IPC_ClearInterrupt_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_Log__beb8257a6deb2cea403088a96f1e5baaff70690e(kss_decision_t *decision,
                                                                                   kss_eid_t src_eid,
                                                                                   nk_sid_t src_sid,
                                                                                   kss_eid_t dst_eid,
                                                                                   nk_sid_t dst_sid,
                                                                                   const
                                                                                   struct nk_message *message,
                                                                                   const
                                                                                   struct nk_arena *arena,
                                                                                   struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Log_Handoff_mid:
        {
            if (NK_TRUE == kl_core_Log_Handoff_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Log_Handoff_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Log_Handoff_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Log_FetchMessages_mid:
        {
            if (NK_TRUE == kl_core_Log_FetchMessages_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Log_FetchMessages_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Log_FetchMessages_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Log_GetMessagesHandle_mid:
        {
            if (NK_TRUE == kl_core_Log_GetMessagesHandle_val_res(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Log_GetMessagesHandle_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Log_GetMessagesHandle_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_Notice__8793d13bf2dbbe33353755931bd69bfff59d4a9a(kss_decision_t *decision,
                                                                                      kss_eid_t src_eid,
                                                                                      nk_sid_t src_sid,
                                                                                      kss_eid_t dst_eid,
                                                                                      nk_sid_t dst_sid,
                                                                                      const
                                                                                      struct nk_message *message,
                                                                                      const
                                                                                      struct nk_arena *arena,
                                                                                      struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Notice_Create_mid:
        {
            if (NK_TRUE == kl_core_Notice_Create_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_Create_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_Create_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_SubscribeToObject_mid:
        {
            if (NK_TRUE == kl_core_Notice_SubscribeToObject_val_res(message,
                                                                    arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_SubscribeToObject_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_SubscribeToObject_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_UnsubscribeFromEvent_mid:
        {
            if (NK_TRUE == kl_core_Notice_UnsubscribeFromEvent_val_res(message,
                                                                       arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_UnsubscribeFromEvent_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_UnsubscribeFromEvent_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_UnsubscribeFromObject_mid:
        {
            if (NK_TRUE == kl_core_Notice_UnsubscribeFromObject_val_res(message,
                                                                        arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_UnsubscribeFromObject_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_UnsubscribeFromObject_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_GetEvent_mid:
        {
            if (NK_TRUE == kl_core_Notice_GetEvent_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_GetEvent_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_GetEvent_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_DropAndWake_mid:
        {
            if (NK_TRUE == kl_core_Notice_DropAndWake_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_DropAndWake_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_DropAndWake_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Notice_SetObjectEvent_mid:
        {
            if (NK_TRUE == kl_core_Notice_SetObjectEvent_val_res(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Notice_SetObjectEvent_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Notice_SetObjectEvent_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_PM__48da679642eedb433ccb22d6d59c4415f25e1ded(kss_decision_t *decision,
                                                                                  kss_eid_t src_eid,
                                                                                  nk_sid_t src_sid,
                                                                                  kss_eid_t dst_eid,
                                                                                  nk_sid_t dst_sid,
                                                                                  const
                                                                                  struct nk_message *message,
                                                                                  const
                                                                                  struct nk_arena *arena,
                                                                                  struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_PM_Request_mid:
        {
            if (NK_TRUE == kl_core_PM_Request_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_PM_Request_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_PM_Request_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_PM_SetCpusOnline_mid:
        {
            if (NK_TRUE == kl_core_PM_SetCpusOnline_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_PM_SetCpusOnline_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_PM_SetCpusOnline_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_PM_GetCpusOnline_mid:
        {
            if (NK_TRUE == kl_core_PM_GetCpusOnline_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_PM_GetCpusOnline_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_PM_GetCpusOnline_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_Profiler__b45d66a11240ec329a74bb5c8f9e429b46e4697d(kss_decision_t *decision,
                                                                                        kss_eid_t src_eid,
                                                                                        nk_sid_t src_sid,
                                                                                        kss_eid_t dst_eid,
                                                                                        nk_sid_t dst_sid,
                                                                                        const
                                                                                        struct nk_message *message,
                                                                                        const
                                                                                        struct nk_arena *arena,
                                                                                        struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Profiler_GetCoverageData_mid:
        {
            if (NK_TRUE == kl_core_Profiler_GetCoverageData_val_res(message,
                                                                    arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_GetCoverageData_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_GetCoverageData_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_FlushGcov_mid:
        {
            if (NK_TRUE == kl_core_Profiler_FlushGcov_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_FlushGcov_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_FlushGcov_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_FlushGcovFile_mid:
        {
            if (NK_TRUE == kl_core_Profiler_FlushGcovFile_val_res(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_FlushGcovFile_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_FlushGcovFile_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_GetCounters_mid:
        {
            if (NK_TRUE == kl_core_Profiler_GetCounters_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_GetCounters_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_GetCounters_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_ObjectGetStat_mid:
        {
            if (NK_TRUE == kl_core_Profiler_ObjectGetStat_val_res(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_ObjectGetStat_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_ObjectGetStat_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingStart_mid:
        {
            if (NK_TRUE == kl_core_Profiler_SamplingStart_val_res(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingStart_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingStart_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingStop_mid:
        {
            if (NK_TRUE == kl_core_Profiler_SamplingStop_val_res(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingStop_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingStop_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingRead_mid:
        {
            if (NK_TRUE == kl_core_Profiler_SamplingRead_val_res(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingRead_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingRead_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingAddPidToList_mid:
        {
            if (NK_TRUE ==
                kl_core_Profiler_SamplingAddPidToList_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingAddPidToList_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingAddPidToList_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_SamplingClearPidList_mid:
        {
            if (NK_TRUE ==
                kl_core_Profiler_SamplingClearPidList_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_SamplingClearPidList_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_SamplingClearPidList_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_LoadSegInfo_mid:
        {
            if (NK_TRUE == kl_core_Profiler_LoadSegInfo_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_LoadSegInfo_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_LoadSegInfo_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_UnloadSegInfo_mid:
        {
            if (NK_TRUE == kl_core_Profiler_UnloadSegInfo_val_res(message,
                                                                  arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_UnloadSegInfo_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_UnloadSegInfo_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_KcovAlloc_mid:
        {
            if (NK_TRUE == kl_core_Profiler_KcovAlloc_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_KcovAlloc_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_KcovAlloc_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_KcovFree_mid:
        {
            if (NK_TRUE == kl_core_Profiler_KcovFree_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_KcovFree_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_KcovFree_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_KcovStart_mid:
        {
            if (NK_TRUE == kl_core_Profiler_KcovStart_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_KcovStart_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_KcovStart_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Profiler_KcovStop_mid:
        {
            if (NK_TRUE == kl_core_Profiler_KcovStop_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Profiler_KcovStop_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Profiler_KcovStop_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_Sync__4e22e778788c261fd5a7db5f6472f66c742e93fd(kss_decision_t *decision,
                                                                                    kss_eid_t src_eid,
                                                                                    nk_sid_t src_sid,
                                                                                    kss_eid_t dst_eid,
                                                                                    nk_sid_t dst_sid,
                                                                                    const
                                                                                    struct nk_message *message,
                                                                                    const
                                                                                    struct nk_arena *arena,
                                                                                    struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Sync_Wait_mid:
        {
            if (NK_TRUE == kl_core_Sync_Wait_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Sync_Wait_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Sync_Wait_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Sync_Wake_mid:
        {
            if (NK_TRUE == kl_core_Sync_Wake_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Sync_Wake_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Sync_Wake_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_TaskDebug__5d7437818d31498d1d664fa8da24a2af4c2f6147(kss_decision_t *decision,
                                                                                         kss_eid_t src_eid,
                                                                                         nk_sid_t src_sid,
                                                                                         kss_eid_t dst_eid,
                                                                                         nk_sid_t dst_sid,
                                                                                         const
                                                                                         struct nk_message *message,
                                                                                         const
                                                                                         struct nk_arena *arena,
                                                                                         struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_TaskDebug_GetHandlesCount_mid:
        {
            if (NK_TRUE == kl_core_TaskDebug_GetHandlesCount_val_res(message,
                                                                     arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_GetHandlesCount_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_GetHandlesCount_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_TaskDebug_GetHandles_mid:
        {
            if (NK_TRUE == kl_core_TaskDebug_GetHandles_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_GetHandles_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_GetHandles_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_TaskDebug_GetHandleInfo_mid:
        {
            if (NK_TRUE == kl_core_TaskDebug_GetHandleInfo_val_res(message,
                                                                   arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_GetHandleInfo_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_GetHandleInfo_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_TaskDebug_EnableHandleTracing_mid:
        {
            if (NK_TRUE ==
                kl_core_TaskDebug_EnableHandleTracing_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_EnableHandleTracing_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_EnableHandleTracing_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_TaskDebug_DisableHandleTracing_mid:
        {
            if (NK_TRUE ==
                kl_core_TaskDebug_DisableHandleTracing_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_TaskDebug_DisableHandleTracing_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_TaskDebug_DisableHandleTracing_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_Task__ae2f9e02f75ba85432cf0a058051389131ea69ee(kss_decision_t *decision,
                                                                                    kss_eid_t src_eid,
                                                                                    nk_sid_t src_sid,
                                                                                    kss_eid_t dst_eid,
                                                                                    nk_sid_t dst_sid,
                                                                                    const
                                                                                    struct nk_message *message,
                                                                                    const
                                                                                    struct nk_arena *arena,
                                                                                    struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Task_Create_mid:
        {
            if (NK_TRUE == kl_core_Task_Create_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_Create_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_Create_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_LoadSeg_mid:
        {
            if (NK_TRUE == kl_core_Task_LoadSeg_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_LoadSeg_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_LoadSeg_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_VmReserve_mid:
        {
            if (NK_TRUE == kl_core_Task_VmReserve_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_VmReserve_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_VmReserve_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_VmFree_mid:
        {
            if (NK_TRUE == kl_core_Task_VmFree_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_VmFree_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_VmFree_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_SetEntry_mid:
        {
            if (NK_TRUE == kl_core_Task_SetEntry_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_SetEntry_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_SetEntry_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_LoadElfSyms_mid:
        {
            if (NK_TRUE == kl_core_Task_LoadElfSyms_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_LoadElfSyms_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_LoadElfSyms_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_LoadElfHdr_mid:
        {
            if (NK_TRUE == kl_core_Task_LoadElfHdr_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_LoadElfHdr_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_LoadElfHdr_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_SetEnv_mid:
        {
            if (NK_TRUE == kl_core_Task_SetEnv_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_SetEnv_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_SetEnv_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_FreeSelfEnv_mid:
        {
            if (NK_TRUE == kl_core_Task_FreeSelfEnv_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_FreeSelfEnv_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_FreeSelfEnv_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_Resume_mid:
        {
            if (NK_TRUE == kl_core_Task_Resume_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_Resume_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_Resume_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_Exit_mid:
        {
            if (NK_TRUE == kl_core_Task_Exit_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_Exit_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_Exit_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_Terminate_mid:
        {
            if (NK_TRUE == kl_core_Task_Terminate_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_Terminate_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_Terminate_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetExitInfo_mid:
        {
            if (NK_TRUE == kl_core_Task_GetExitInfo_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetExitInfo_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetExitInfo_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetThreadContext_mid:
        {
            if (NK_TRUE == kl_core_Task_GetThreadContext_val_res(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetThreadContext_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetThreadContext_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetNextVmRegion_mid:
        {
            if (NK_TRUE == kl_core_Task_GetNextVmRegion_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetNextVmRegion_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetNextVmRegion_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_TerminateAfterFreezing_mid:
        {
            if (NK_TRUE == kl_core_Task_TerminateAfterFreezing_val_res(message,
                                                                       arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_TerminateAfterFreezing_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_TerminateAfterFreezing_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetName_mid:
        {
            if (NK_TRUE == kl_core_Task_GetName_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetName_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetName_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetPath_mid:
        {
            if (NK_TRUE == kl_core_Task_GetPath_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetPath_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetPath_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetInitialThreadPriority_mid:
        {
            if (NK_TRUE ==
                kl_core_Task_GetInitialThreadPriority_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetInitialThreadPriority_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetInitialThreadPriority_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_SetInitialThreadPriority_mid:
        {
            if (NK_TRUE ==
                kl_core_Task_SetInitialThreadPriority_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_SetInitialThreadPriority_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_SetInitialThreadPriority_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetTasksList_mid:
        {
            if (NK_TRUE == kl_core_Task_GetTasksList_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetTasksList_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetTasksList_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_SetInitialThreadSchedPolicy_mid:
        {
            if (NK_TRUE ==
                kl_core_Task_SetInitialThreadSchedPolicy_val_res(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_SetInitialThreadSchedPolicy_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_SetInitialThreadSchedPolicy_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_ReseedAslr_mid:
        {
            if (NK_TRUE == kl_core_Task_ReseedAslr_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_ReseedAslr_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_ReseedAslr_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetElfSyms_mid:
        {
            if (NK_TRUE == kl_core_Task_GetElfSyms_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetElfSyms_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetElfSyms_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_TransferHandle_mid:
        {
            if (NK_TRUE == kl_core_Task_TransferHandle_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_TransferHandle_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_TransferHandle_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Task_GetPid_mid:
        {
            if (NK_TRUE == kl_core_Task_GetPid_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Task_GetPid_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Task_GetPid_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_Thread__99ea0e795e60b4bc71e50f64356a2f72a0e0512c(kss_decision_t *decision,
                                                                                      kss_eid_t src_eid,
                                                                                      nk_sid_t src_sid,
                                                                                      kss_eid_t dst_eid,
                                                                                      nk_sid_t dst_sid,
                                                                                      const
                                                                                      struct nk_message *message,
                                                                                      const
                                                                                      struct nk_arena *arena,
                                                                                      struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Thread_Create_mid:
        {
            if (NK_TRUE == kl_core_Thread_Create_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Create_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Create_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_OpenCurrent_mid:
        {
            if (NK_TRUE == kl_core_Thread_OpenCurrent_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_OpenCurrent_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_OpenCurrent_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Attach_mid:
        {
            if (NK_TRUE == kl_core_Thread_Attach_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Attach_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Attach_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Suspend_mid:
        {
            if (NK_TRUE == kl_core_Thread_Suspend_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Suspend_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Suspend_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Resume_mid:
        {
            if (NK_TRUE == kl_core_Thread_Resume_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Resume_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Resume_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Terminate_mid:
        {
            if (NK_TRUE == kl_core_Thread_Terminate_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Terminate_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Terminate_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Exit_mid:
        {
            if (NK_TRUE == kl_core_Thread_Exit_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Exit_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Exit_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Wait_mid:
        {
            if (NK_TRUE == kl_core_Thread_Wait_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Wait_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Wait_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_SetPriority_mid:
        {
            if (NK_TRUE == kl_core_Thread_SetPriority_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_SetPriority_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_SetPriority_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_SetTls_mid:
        {
            if (NK_TRUE == kl_core_Thread_SetTls_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_SetTls_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_SetTls_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_Sleep_mid:
        {
            if (NK_TRUE == kl_core_Thread_Sleep_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_Sleep_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_Sleep_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_GetInfo_mid:
        {
            if (NK_TRUE == kl_core_Thread_GetInfo_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_GetInfo_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_GetInfo_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_DetachIrq_mid:
        {
            if (NK_TRUE == kl_core_Thread_DetachIrq_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_DetachIrq_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_DetachIrq_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_GetAffinity_mid:
        {
            if (NK_TRUE == kl_core_Thread_GetAffinity_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_GetAffinity_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_GetAffinity_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_SetAffinity_mid:
        {
            if (NK_TRUE == kl_core_Thread_SetAffinity_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_SetAffinity_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_SetAffinity_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_SetSchedPolicy_mid:
        {
            if (NK_TRUE == kl_core_Thread_SetSchedPolicy_val_res(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_SetSchedPolicy_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_SetSchedPolicy_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Thread_GetSchedPolicy_mid:
        {
            if (NK_TRUE == kl_core_Thread_GetSchedPolicy_val_res(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Thread_GetSchedPolicy_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Thread_GetSchedPolicy_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_Time__fee1319bdee897bcae0859db7e69b62753220c17(kss_decision_t *decision,
                                                                                    kss_eid_t src_eid,
                                                                                    nk_sid_t src_sid,
                                                                                    kss_eid_t dst_eid,
                                                                                    nk_sid_t dst_sid,
                                                                                    const
                                                                                    struct nk_message *message,
                                                                                    const
                                                                                    struct nk_arena *arena,
                                                                                    struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_Time_SetSystemTime_mid:
        {
            if (NK_TRUE == kl_core_Time_SetSystemTime_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Time_SetSystemTime_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Time_SetSystemTime_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Time_SetSystemTimeAdj_mid:
        {
            if (NK_TRUE == kl_core_Time_SetSystemTimeAdj_val_res(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Time_SetSystemTimeAdj_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Time_SetSystemTimeAdj_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_Time_GetSystemTimeAdj_mid:
        {
            if (NK_TRUE == kl_core_Time_GetSystemTimeAdj_val_res(message,
                                                                 arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_Time_GetSystemTimeAdj_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_Time_GetSystemTimeAdj_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_VMM__95696f577874623d1c34a812884a94626fe4e22a(kss_decision_t *decision,
                                                                                   kss_eid_t src_eid,
                                                                                   nk_sid_t src_sid,
                                                                                   kss_eid_t dst_eid,
                                                                                   nk_sid_t dst_sid,
                                                                                   const
                                                                                   struct nk_message *message,
                                                                                   const
                                                                                   struct nk_arena *arena,
                                                                                   struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_VMM_Allocate_mid:
        {
            if (NK_TRUE == kl_core_VMM_Allocate_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Allocate_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Allocate_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Commit_mid:
        {
            if (NK_TRUE == kl_core_VMM_Commit_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Commit_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Commit_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Decommit_mid:
        {
            if (NK_TRUE == kl_core_VMM_Decommit_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Decommit_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Decommit_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Protect_mid:
        {
            if (NK_TRUE == kl_core_VMM_Protect_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Protect_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Protect_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Free_mid:
        {
            if (NK_TRUE == kl_core_VMM_Free_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Free_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Free_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Query_mid:
        {
            if (NK_TRUE == kl_core_VMM_Query_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Query_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Query_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_Reset_mid:
        {
            if (NK_TRUE == kl_core_VMM_Reset_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_Reset_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_Reset_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlCreate_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlCreate_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlCreate_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlCreate_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlCreateFromVm_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlCreateFromVm_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlCreateFromVm_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlCreateFromVm_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlGetSize_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlGetSize_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlGetSize_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlGetSize_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlMap_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlMap_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlMap_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlMap_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_VMM_MdlClone_mid:
        {
            if (NK_TRUE == kl_core_VMM_MdlClone_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_VMM_MdlClone_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_VMM_MdlClone_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
static
nk_err_t validate__Response__kl_core_XHCIDBG__2272fbe6e81a1f47390f0ad8af6cbe4e165e98f6(kss_decision_t *decision,
                                                                                       kss_eid_t src_eid,
                                                                                       nk_sid_t src_sid,
                                                                                       kss_eid_t dst_eid,
                                                                                       nk_sid_t dst_sid,
                                                                                       const
                                                                                       struct nk_message *message,
                                                                                       const
                                                                                       struct nk_arena *arena,
                                                                                       struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "IPC call, mid: %d", message->mid);
    switch (message->mid) {
        
      case kl_core_XHCIDBG_Start_mid:
        {
            if (NK_TRUE == kl_core_XHCIDBG_Start_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_XHCIDBG_Start_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_XHCIDBG_Start_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      case kl_core_XHCIDBG_Stop_mid:
        {
            if (NK_TRUE == kl_core_XHCIDBG_Stop_val_res(message, arena))
                PSL_TRACE(CLS_KSS_GRANTED, "Message", "%s -> correct",
                          "kl_core_XHCIDBG_Stop_val_res");
            else {
                PSL_TRACE(CLS_KSS_DENIED, "Message", "%s -> invalid",
                          "kl_core_XHCIDBG_Stop_val_res");
                return NK_EINVAL;
            }
            return calltree_0(decision, src_eid, src_sid, dst_eid, dst_sid,
                              message, arena, audit_message);
        }
        
      default:
        {
            PSL_TRACE(CLS_ERROR, "PSL", "mid: %d -> OOB", message->mid);
            return NK_ENOENT;
        }
    }
}
nk_err_t __kss_execute(kss_decision_t *decision, kss_eid_t src_eid,
                       nk_sid_t src_sid, kss_eid_t dst_eid, nk_sid_t dst_sid,
                       const struct nk_message *message, const
                       struct nk_arena *arena,
                       struct kss_audit_message *audit_message)
{
    nk_err_t rc = NK_ENOENT;
    
    PSL_TRACE(CLS_PSL, "PSL", "src: %d, dst: %d", src_eid, dst_eid);
    switch (src_eid) {
        
      case 0:
        switch (dst_eid) {
            
          case 0:
            rc =
                validate__Execute__nk_Execute__9ec7c875d839e5a1b9e4472c3dcb74d7a82d9331(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
            break;
            
          case 1:
            rc =
                validate__Execute__nk_Execute__9ec7c875d839e5a1b9e4472c3dcb74d7a82d9331(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
            break;
            
          case 2:
            rc =
                validate__Execute__nk_Execute__9ec7c875d839e5a1b9e4472c3dcb74d7a82d9331(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
            break;
            
          default:
            break;
        }
        break;
        
      case 1:
        switch (dst_eid) {
            
          case 0:
            rc =
                validate__Execute__nk_Execute__9ec7c875d839e5a1b9e4472c3dcb74d7a82d9331(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
            break;
            
          case 1:
            rc =
                validate__Execute__nk_Execute__9ec7c875d839e5a1b9e4472c3dcb74d7a82d9331(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
            break;
            
          case 2:
            rc =
                validate__Execute__nk_Execute__9ec7c875d839e5a1b9e4472c3dcb74d7a82d9331(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
            break;
            
          default:
            break;
        }
        break;
        
      case 2:
        switch (dst_eid) {
            
          case 0:
            rc =
                validate__Execute__nk_Execute__9ec7c875d839e5a1b9e4472c3dcb74d7a82d9331(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
            break;
            
          case 1:
            rc =
                validate__Execute__nk_Execute__9ec7c875d839e5a1b9e4472c3dcb74d7a82d9331(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
            break;
            
          case 2:
            rc =
                validate__Execute__nk_Execute__9ec7c875d839e5a1b9e4472c3dcb74d7a82d9331(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
            break;
            
          default:
            break;
        }
        break;
        
      default:
        break;
    }
    log_rc(audit_message, rc);
    return rc;
}
static
nk_err_t validate__Error__2kl_core_Core__2kl_core_Core(kss_decision_t *decision,
                                                       kss_eid_t src_eid,
                                                       nk_sid_t src_sid,
                                                       kss_eid_t dst_eid,
                                                       nk_sid_t dst_sid, const
                                                       struct nk_message *message,
                                                       const
                                                       struct nk_arena *arena,
                                                       struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "iid: %d", message->iid);
    
    nk_err_t rc = NK_ENOENT;
    
    switch (message->iid) {
        
      case 0:
        rc =
            validate__Error__kl_core_VMM__a78ac7b765c242a895fe647c4df9b3fbb1e3e302(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      case 1:
        rc =
            validate__Error__kl_core_IO__823fc93e667833fc2cced245c3d148ff3d20c3a6(decision,
                                                                                  src_eid,
                                                                                  src_sid,
                                                                                  dst_eid,
                                                                                  dst_sid,
                                                                                  message,
                                                                                  arena,
                                                                                  audit_message);
        break;
        
      case 2:
        rc =
            validate__Error__kl_core_Thread__908ab87422c99c003e4d3c9ae36a9829f3dcf503(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 3:
        rc =
            validate__Error__kl_core_Handle__96653286716976cc757704f49aa76a2e90f39ad1(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 4:
        rc =
            validate__Error__kl_core_Task__e138f630c31ff6706136636848b4f54a30b9bb3a(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 5:
        rc =
            validate__Error__kl_core_TaskDebug__074f7853ddeff8af0ba67c543527a5201c51361e(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 6:
        rc =
            validate__Error__kl_core_Sync__162da361746c1842f44fcea945d10e6019428afe(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 7:
        rc =
            validate__Error__kl_core_FS__9e3d0d77274d67a9140570815843418a8e4080de(decision,
                                                                                  src_eid,
                                                                                  src_sid,
                                                                                  dst_eid,
                                                                                  dst_sid,
                                                                                  message,
                                                                                  arena,
                                                                                  audit_message);
        break;
        
      case 8:
        rc =
            validate__Error__kl_core_FSUnsafe__9254f858dce54194081d210f94ee5d44ef2610a4(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 9:
        rc =
            validate__Error__kl_core_Time__b03d2ee978febf96e918036eb2edf4f82dc04a93(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 10:
        rc =
            validate__Error__kl_core_HAL__7a9ae0ccf9803fb09220411101c508affc1de9c0(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      case 11:
        rc =
            validate__Error__kl_core_XHCIDBG__66fb525d8309c5ff603aef64b013768fe866d368(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 12:
        rc =
            validate__Error__kl_core_Audit__95d3ff5faaadd2d8a9386c51b93767aa8099be3d(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 13:
        rc =
            validate__Error__kl_core_Profiler__ee45805d647463c80c226e762f8e2e4cc2a299f7(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 14:
        rc =
            validate__Error__kl_core_IOMMU__0a00654332ff29362cf9dda0e998e099f24d3592(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 15:
        rc =
            validate__Error__kl_core_CM__27258f11c55ea0fd9851fb5f9fec795fd2864948(decision,
                                                                                  src_eid,
                                                                                  src_sid,
                                                                                  dst_eid,
                                                                                  dst_sid,
                                                                                  message,
                                                                                  arena,
                                                                                  audit_message);
        break;
        
      case 16:
        rc =
            validate__Error__kl_core_PM__929ece837b8a4cad967d61fd11b2a993aa452306(decision,
                                                                                  src_eid,
                                                                                  src_sid,
                                                                                  dst_eid,
                                                                                  dst_sid,
                                                                                  message,
                                                                                  arena,
                                                                                  audit_message);
        break;
        
      case 17:
        rc =
            validate__Error__kl_core_Notice__c06885b33dd04f2be6f95b13c5ed4bc5932fe7b6(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 18:
        rc =
            validate__Error__kl_core_IPC__ca5864d469b432ebf1b8f36bb9b6802130c41972(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      case 19:
        rc =
            validate__Error__kl_core_Log__76ebab3667966e8c0e43178c4ec33fa4a4cf15f0(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      case 20:
        rc =
            validate__Error__kl_core_Efi__15bc3f2dbc9a0058cff270f5476465a7356d5d1d(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      default:
        break;
    }
    return rc;
}
static
nk_err_t validate__Request__0Einit__2kl_core_Core(kss_decision_t *decision,
                                                  kss_eid_t src_eid,
                                                  nk_sid_t src_sid,
                                                  kss_eid_t dst_eid,
                                                  nk_sid_t dst_sid, const
                                                  struct nk_message *message,
                                                  const struct nk_arena *arena,
                                                  struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "iid: %d", message->iid);
    
    nk_err_t rc = NK_ENOENT;
    
    switch (message->iid) {
        
      case 0:
        rc =
            validate__Request__kl_core_VMM__9e98540b3cbf2ffea1f6f71f1642f7f230739022(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 1:
        rc =
            validate__Request__kl_core_IO__4cc46f0a31ce4ba7b375c70fac8d2c51fcf7ed85(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 2:
        rc =
            validate__Request__kl_core_Thread__8e135981dd8f7c95e81e91275fa0e4ea4870be5e(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 3:
        rc =
            validate__Request__kl_core_Handle__774bfd78165bf037edadf4bff244e5f2c6e2a09c(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 4:
        rc =
            validate__Request__kl_core_Task__83009ad2649e40daf39ae2811df777c2a99f3fb0(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 5:
        rc =
            validate__Request__kl_core_TaskDebug__48b59d2f5602db5d2e630cd908be187fcb3a2faf(decision,
                                                                                           src_eid,
                                                                                           src_sid,
                                                                                           dst_eid,
                                                                                           dst_sid,
                                                                                           message,
                                                                                           arena,
                                                                                           audit_message);
        break;
        
      case 6:
        rc =
            validate__Request__kl_core_Sync__6da01def9052fedbb83c77bc125f119761715d7c(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 7:
        rc =
            validate__Request__kl_core_FS__e19b8cb0ac46d90a250068c9ca8626fe6fe5cc14(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 8:
        rc =
            validate__Request__kl_core_FSUnsafe__755206e70fc72efec82d5ca08b4a2c1516459a22(decision,
                                                                                          src_eid,
                                                                                          src_sid,
                                                                                          dst_eid,
                                                                                          dst_sid,
                                                                                          message,
                                                                                          arena,
                                                                                          audit_message);
        break;
        
      case 9:
        rc =
            validate__Request__kl_core_Time__ecee1c055430d7cbba6d675ee1d85084b518d48d(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 10:
        rc =
            validate__Request__kl_core_HAL__5d6aa03c6b953727636e7b40b6a9176d8f84ac81(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 11:
        rc =
            validate__Request__kl_core_XHCIDBG__4d18006439a671420ef9392077eed16cc064a594(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 12:
        rc =
            validate__Request__kl_core_Audit__30b0af43ff347699df7ad7d939bbdc1d76359870(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 13:
        rc =
            validate__Request__kl_core_Profiler__41078ec5de2cf866098147885d622026e4db94d5(decision,
                                                                                          src_eid,
                                                                                          src_sid,
                                                                                          dst_eid,
                                                                                          dst_sid,
                                                                                          message,
                                                                                          arena,
                                                                                          audit_message);
        break;
        
      case 14:
        rc =
            validate__Request__kl_core_IOMMU__383215b2bffedc87ae6745a74d93cb4eea886512(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 15:
        rc =
            validate__Request__kl_core_CM__20ff06f6a3549d82411710ce8095d44dacbf9b0d(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 16:
        rc =
            validate__Request__kl_core_PM__aa509a2f41137874a757461322666016419b24bc(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 17:
        rc =
            validate__Request__kl_core_Notice__17358c558b7ee6311f3c4f63262cd4df3104befa(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 18:
        rc =
            validate__Request__kl_core_IPC__d34dc2cf5abce4af1039c67e2f4ff98dd17c498b(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 19:
        rc =
            validate__Request__kl_core_Log__c93f30f7e5723193f2035e6a7531cd4401916969(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 20:
        rc =
            validate__Request__kl_core_Efi__5f1cde4cd229d66d367f33bec3d44381192ab039(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      default:
        break;
    }
    return rc;
}
static
nk_err_t validate__Request__1Hello__2kl_core_Core(kss_decision_t *decision,
                                                  kss_eid_t src_eid,
                                                  nk_sid_t src_sid,
                                                  kss_eid_t dst_eid,
                                                  nk_sid_t dst_sid, const
                                                  struct nk_message *message,
                                                  const struct nk_arena *arena,
                                                  struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "iid: %d", message->iid);
    
    nk_err_t rc = NK_ENOENT;
    
    switch (message->iid) {
        
      case 0:
        rc =
            validate__Request__kl_core_VMM__9e98540b3cbf2ffea1f6f71f1642f7f230739022(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 1:
        rc =
            validate__Request__kl_core_IO__4cc46f0a31ce4ba7b375c70fac8d2c51fcf7ed85(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 2:
        rc =
            validate__Request__kl_core_Thread__8e135981dd8f7c95e81e91275fa0e4ea4870be5e(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 3:
        rc =
            validate__Request__kl_core_Handle__774bfd78165bf037edadf4bff244e5f2c6e2a09c(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 4:
        rc =
            validate__Request__kl_core_Task__83009ad2649e40daf39ae2811df777c2a99f3fb0(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 5:
        rc =
            validate__Request__kl_core_TaskDebug__48b59d2f5602db5d2e630cd908be187fcb3a2faf(decision,
                                                                                           src_eid,
                                                                                           src_sid,
                                                                                           dst_eid,
                                                                                           dst_sid,
                                                                                           message,
                                                                                           arena,
                                                                                           audit_message);
        break;
        
      case 6:
        rc =
            validate__Request__kl_core_Sync__6da01def9052fedbb83c77bc125f119761715d7c(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 7:
        rc =
            validate__Request__kl_core_FS__e19b8cb0ac46d90a250068c9ca8626fe6fe5cc14(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 8:
        rc =
            validate__Request__kl_core_FSUnsafe__755206e70fc72efec82d5ca08b4a2c1516459a22(decision,
                                                                                          src_eid,
                                                                                          src_sid,
                                                                                          dst_eid,
                                                                                          dst_sid,
                                                                                          message,
                                                                                          arena,
                                                                                          audit_message);
        break;
        
      case 9:
        rc =
            validate__Request__kl_core_Time__ecee1c055430d7cbba6d675ee1d85084b518d48d(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 10:
        rc =
            validate__Request__kl_core_HAL__5d6aa03c6b953727636e7b40b6a9176d8f84ac81(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 11:
        rc =
            validate__Request__kl_core_XHCIDBG__4d18006439a671420ef9392077eed16cc064a594(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 12:
        rc =
            validate__Request__kl_core_Audit__30b0af43ff347699df7ad7d939bbdc1d76359870(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 13:
        rc =
            validate__Request__kl_core_Profiler__41078ec5de2cf866098147885d622026e4db94d5(decision,
                                                                                          src_eid,
                                                                                          src_sid,
                                                                                          dst_eid,
                                                                                          dst_sid,
                                                                                          message,
                                                                                          arena,
                                                                                          audit_message);
        break;
        
      case 14:
        rc =
            validate__Request__kl_core_IOMMU__383215b2bffedc87ae6745a74d93cb4eea886512(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 15:
        rc =
            validate__Request__kl_core_CM__20ff06f6a3549d82411710ce8095d44dacbf9b0d(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 16:
        rc =
            validate__Request__kl_core_PM__aa509a2f41137874a757461322666016419b24bc(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 17:
        rc =
            validate__Request__kl_core_Notice__17358c558b7ee6311f3c4f63262cd4df3104befa(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 18:
        rc =
            validate__Request__kl_core_IPC__d34dc2cf5abce4af1039c67e2f4ff98dd17c498b(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 19:
        rc =
            validate__Request__kl_core_Log__c93f30f7e5723193f2035e6a7531cd4401916969(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 20:
        rc =
            validate__Request__kl_core_Efi__5f1cde4cd229d66d367f33bec3d44381192ab039(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      default:
        break;
    }
    return rc;
}
static
nk_err_t validate__Request__2kl_core_Core__2kl_core_Core(kss_decision_t *decision,
                                                         kss_eid_t src_eid,
                                                         nk_sid_t src_sid,
                                                         kss_eid_t dst_eid,
                                                         nk_sid_t dst_sid, const
                                                         struct nk_message *message,
                                                         const
                                                         struct nk_arena *arena,
                                                         struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "iid: %d", message->iid);
    
    nk_err_t rc = NK_ENOENT;
    
    switch (message->iid) {
        
      case 0:
        rc =
            validate__Request__kl_core_VMM__9e98540b3cbf2ffea1f6f71f1642f7f230739022(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 1:
        rc =
            validate__Request__kl_core_IO__4cc46f0a31ce4ba7b375c70fac8d2c51fcf7ed85(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 2:
        rc =
            validate__Request__kl_core_Thread__8e135981dd8f7c95e81e91275fa0e4ea4870be5e(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 3:
        rc =
            validate__Request__kl_core_Handle__774bfd78165bf037edadf4bff244e5f2c6e2a09c(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 4:
        rc =
            validate__Request__kl_core_Task__83009ad2649e40daf39ae2811df777c2a99f3fb0(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 5:
        rc =
            validate__Request__kl_core_TaskDebug__48b59d2f5602db5d2e630cd908be187fcb3a2faf(decision,
                                                                                           src_eid,
                                                                                           src_sid,
                                                                                           dst_eid,
                                                                                           dst_sid,
                                                                                           message,
                                                                                           arena,
                                                                                           audit_message);
        break;
        
      case 6:
        rc =
            validate__Request__kl_core_Sync__6da01def9052fedbb83c77bc125f119761715d7c(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 7:
        rc =
            validate__Request__kl_core_FS__e19b8cb0ac46d90a250068c9ca8626fe6fe5cc14(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 8:
        rc =
            validate__Request__kl_core_FSUnsafe__755206e70fc72efec82d5ca08b4a2c1516459a22(decision,
                                                                                          src_eid,
                                                                                          src_sid,
                                                                                          dst_eid,
                                                                                          dst_sid,
                                                                                          message,
                                                                                          arena,
                                                                                          audit_message);
        break;
        
      case 9:
        rc =
            validate__Request__kl_core_Time__ecee1c055430d7cbba6d675ee1d85084b518d48d(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 10:
        rc =
            validate__Request__kl_core_HAL__5d6aa03c6b953727636e7b40b6a9176d8f84ac81(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 11:
        rc =
            validate__Request__kl_core_XHCIDBG__4d18006439a671420ef9392077eed16cc064a594(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 12:
        rc =
            validate__Request__kl_core_Audit__30b0af43ff347699df7ad7d939bbdc1d76359870(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 13:
        rc =
            validate__Request__kl_core_Profiler__41078ec5de2cf866098147885d622026e4db94d5(decision,
                                                                                          src_eid,
                                                                                          src_sid,
                                                                                          dst_eid,
                                                                                          dst_sid,
                                                                                          message,
                                                                                          arena,
                                                                                          audit_message);
        break;
        
      case 14:
        rc =
            validate__Request__kl_core_IOMMU__383215b2bffedc87ae6745a74d93cb4eea886512(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 15:
        rc =
            validate__Request__kl_core_CM__20ff06f6a3549d82411710ce8095d44dacbf9b0d(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 16:
        rc =
            validate__Request__kl_core_PM__aa509a2f41137874a757461322666016419b24bc(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 17:
        rc =
            validate__Request__kl_core_Notice__17358c558b7ee6311f3c4f63262cd4df3104befa(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 18:
        rc =
            validate__Request__kl_core_IPC__d34dc2cf5abce4af1039c67e2f4ff98dd17c498b(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 19:
        rc =
            validate__Request__kl_core_Log__c93f30f7e5723193f2035e6a7531cd4401916969(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 20:
        rc =
            validate__Request__kl_core_Efi__5f1cde4cd229d66d367f33bec3d44381192ab039(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      default:
        break;
    }
    return rc;
}
static
nk_err_t validate__Response__2kl_core_Core__0Einit(kss_decision_t *decision,
                                                   kss_eid_t src_eid,
                                                   nk_sid_t src_sid,
                                                   kss_eid_t dst_eid,
                                                   nk_sid_t dst_sid, const
                                                   struct nk_message *message,
                                                   const struct nk_arena *arena,
                                                   struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "iid: %d", message->iid);
    
    nk_err_t rc = NK_ENOENT;
    
    switch (message->iid) {
        
      case 0:
        rc =
            validate__Response__kl_core_VMM__95696f577874623d1c34a812884a94626fe4e22a(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 1:
        rc =
            validate__Response__kl_core_IO__9e6310a517abc9a3fea669e539ea4af45bf6ac09(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 2:
        rc =
            validate__Response__kl_core_Thread__99ea0e795e60b4bc71e50f64356a2f72a0e0512c(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 3:
        rc =
            validate__Response__kl_core_Handle__80a5f6b7048dacefcfcdcebb1e8e40fc5c4fe2b8(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 4:
        rc =
            validate__Response__kl_core_Task__ae2f9e02f75ba85432cf0a058051389131ea69ee(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 5:
        rc =
            validate__Response__kl_core_TaskDebug__5d7437818d31498d1d664fa8da24a2af4c2f6147(decision,
                                                                                            src_eid,
                                                                                            src_sid,
                                                                                            dst_eid,
                                                                                            dst_sid,
                                                                                            message,
                                                                                            arena,
                                                                                            audit_message);
        break;
        
      case 6:
        rc =
            validate__Response__kl_core_Sync__4e22e778788c261fd5a7db5f6472f66c742e93fd(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 7:
        rc =
            validate__Response__kl_core_FS__1bf52cea5d66279f1b580f00a01879a36d366883(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 8:
        rc =
            validate__Response__kl_core_FSUnsafe__c020e08f678e72fab7652e76dc5e6ad42920685d(decision,
                                                                                           src_eid,
                                                                                           src_sid,
                                                                                           dst_eid,
                                                                                           dst_sid,
                                                                                           message,
                                                                                           arena,
                                                                                           audit_message);
        break;
        
      case 9:
        rc =
            validate__Response__kl_core_Time__fee1319bdee897bcae0859db7e69b62753220c17(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 10:
        rc =
            validate__Response__kl_core_HAL__53a7a3f2da521c9fb039f99235b09225ce086dfc(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 11:
        rc =
            validate__Response__kl_core_XHCIDBG__2272fbe6e81a1f47390f0ad8af6cbe4e165e98f6(decision,
                                                                                          src_eid,
                                                                                          src_sid,
                                                                                          dst_eid,
                                                                                          dst_sid,
                                                                                          message,
                                                                                          arena,
                                                                                          audit_message);
        break;
        
      case 12:
        rc =
            validate__Response__kl_core_Audit__d9d13127fa4d22d5ac2af8b6f76446c8e47b7c38(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 13:
        rc =
            validate__Response__kl_core_Profiler__b45d66a11240ec329a74bb5c8f9e429b46e4697d(decision,
                                                                                           src_eid,
                                                                                           src_sid,
                                                                                           dst_eid,
                                                                                           dst_sid,
                                                                                           message,
                                                                                           arena,
                                                                                           audit_message);
        break;
        
      case 14:
        rc =
            validate__Response__kl_core_IOMMU__ad5f2f3c366d39664c3a3187668a89791cc2c38d(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 15:
        rc =
            validate__Response__kl_core_CM__38ab137722ff64a3aa985d5f91cb0e5d6d84969b(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 16:
        rc =
            validate__Response__kl_core_PM__48da679642eedb433ccb22d6d59c4415f25e1ded(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 17:
        rc =
            validate__Response__kl_core_Notice__8793d13bf2dbbe33353755931bd69bfff59d4a9a(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 18:
        rc =
            validate__Response__kl_core_IPC__5e72ad72539079532a5573689ad771676b404d21(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 19:
        rc =
            validate__Response__kl_core_Log__beb8257a6deb2cea403088a96f1e5baaff70690e(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 20:
        rc =
            validate__Response__kl_core_Efi__48c53ee342548adb934b28633c3b7afd0e11028d(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      default:
        break;
    }
    return rc;
}
static
nk_err_t validate__Response__2kl_core_Core__1Hello(kss_decision_t *decision,
                                                   kss_eid_t src_eid,
                                                   nk_sid_t src_sid,
                                                   kss_eid_t dst_eid,
                                                   nk_sid_t dst_sid, const
                                                   struct nk_message *message,
                                                   const struct nk_arena *arena,
                                                   struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "iid: %d", message->iid);
    
    nk_err_t rc = NK_ENOENT;
    
    switch (message->iid) {
        
      case 0:
        rc =
            validate__Response__kl_core_VMM__95696f577874623d1c34a812884a94626fe4e22a(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 1:
        rc =
            validate__Response__kl_core_IO__9e6310a517abc9a3fea669e539ea4af45bf6ac09(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 2:
        rc =
            validate__Response__kl_core_Thread__99ea0e795e60b4bc71e50f64356a2f72a0e0512c(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 3:
        rc =
            validate__Response__kl_core_Handle__80a5f6b7048dacefcfcdcebb1e8e40fc5c4fe2b8(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 4:
        rc =
            validate__Response__kl_core_Task__ae2f9e02f75ba85432cf0a058051389131ea69ee(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 5:
        rc =
            validate__Response__kl_core_TaskDebug__5d7437818d31498d1d664fa8da24a2af4c2f6147(decision,
                                                                                            src_eid,
                                                                                            src_sid,
                                                                                            dst_eid,
                                                                                            dst_sid,
                                                                                            message,
                                                                                            arena,
                                                                                            audit_message);
        break;
        
      case 6:
        rc =
            validate__Response__kl_core_Sync__4e22e778788c261fd5a7db5f6472f66c742e93fd(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 7:
        rc =
            validate__Response__kl_core_FS__1bf52cea5d66279f1b580f00a01879a36d366883(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 8:
        rc =
            validate__Response__kl_core_FSUnsafe__c020e08f678e72fab7652e76dc5e6ad42920685d(decision,
                                                                                           src_eid,
                                                                                           src_sid,
                                                                                           dst_eid,
                                                                                           dst_sid,
                                                                                           message,
                                                                                           arena,
                                                                                           audit_message);
        break;
        
      case 9:
        rc =
            validate__Response__kl_core_Time__fee1319bdee897bcae0859db7e69b62753220c17(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 10:
        rc =
            validate__Response__kl_core_HAL__53a7a3f2da521c9fb039f99235b09225ce086dfc(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 11:
        rc =
            validate__Response__kl_core_XHCIDBG__2272fbe6e81a1f47390f0ad8af6cbe4e165e98f6(decision,
                                                                                          src_eid,
                                                                                          src_sid,
                                                                                          dst_eid,
                                                                                          dst_sid,
                                                                                          message,
                                                                                          arena,
                                                                                          audit_message);
        break;
        
      case 12:
        rc =
            validate__Response__kl_core_Audit__d9d13127fa4d22d5ac2af8b6f76446c8e47b7c38(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 13:
        rc =
            validate__Response__kl_core_Profiler__b45d66a11240ec329a74bb5c8f9e429b46e4697d(decision,
                                                                                           src_eid,
                                                                                           src_sid,
                                                                                           dst_eid,
                                                                                           dst_sid,
                                                                                           message,
                                                                                           arena,
                                                                                           audit_message);
        break;
        
      case 14:
        rc =
            validate__Response__kl_core_IOMMU__ad5f2f3c366d39664c3a3187668a89791cc2c38d(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 15:
        rc =
            validate__Response__kl_core_CM__38ab137722ff64a3aa985d5f91cb0e5d6d84969b(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 16:
        rc =
            validate__Response__kl_core_PM__48da679642eedb433ccb22d6d59c4415f25e1ded(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 17:
        rc =
            validate__Response__kl_core_Notice__8793d13bf2dbbe33353755931bd69bfff59d4a9a(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 18:
        rc =
            validate__Response__kl_core_IPC__5e72ad72539079532a5573689ad771676b404d21(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 19:
        rc =
            validate__Response__kl_core_Log__beb8257a6deb2cea403088a96f1e5baaff70690e(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 20:
        rc =
            validate__Response__kl_core_Efi__48c53ee342548adb934b28633c3b7afd0e11028d(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      default:
        break;
    }
    return rc;
}
static
nk_err_t validate__Response__2kl_core_Core__2kl_core_Core(kss_decision_t *decision,
                                                          kss_eid_t src_eid,
                                                          nk_sid_t src_sid,
                                                          kss_eid_t dst_eid,
                                                          nk_sid_t dst_sid,
                                                          const
                                                          struct nk_message *message,
                                                          const
                                                          struct nk_arena *arena,
                                                          struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "iid: %d", message->iid);
    
    nk_err_t rc = NK_ENOENT;
    
    switch (message->iid) {
        
      case 0:
        rc =
            validate__Response__kl_core_VMM__95696f577874623d1c34a812884a94626fe4e22a(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 1:
        rc =
            validate__Response__kl_core_IO__9e6310a517abc9a3fea669e539ea4af45bf6ac09(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 2:
        rc =
            validate__Response__kl_core_Thread__99ea0e795e60b4bc71e50f64356a2f72a0e0512c(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 3:
        rc =
            validate__Response__kl_core_Handle__80a5f6b7048dacefcfcdcebb1e8e40fc5c4fe2b8(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 4:
        rc =
            validate__Response__kl_core_Task__ae2f9e02f75ba85432cf0a058051389131ea69ee(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 5:
        rc =
            validate__Response__kl_core_TaskDebug__5d7437818d31498d1d664fa8da24a2af4c2f6147(decision,
                                                                                            src_eid,
                                                                                            src_sid,
                                                                                            dst_eid,
                                                                                            dst_sid,
                                                                                            message,
                                                                                            arena,
                                                                                            audit_message);
        break;
        
      case 6:
        rc =
            validate__Response__kl_core_Sync__4e22e778788c261fd5a7db5f6472f66c742e93fd(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 7:
        rc =
            validate__Response__kl_core_FS__1bf52cea5d66279f1b580f00a01879a36d366883(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 8:
        rc =
            validate__Response__kl_core_FSUnsafe__c020e08f678e72fab7652e76dc5e6ad42920685d(decision,
                                                                                           src_eid,
                                                                                           src_sid,
                                                                                           dst_eid,
                                                                                           dst_sid,
                                                                                           message,
                                                                                           arena,
                                                                                           audit_message);
        break;
        
      case 9:
        rc =
            validate__Response__kl_core_Time__fee1319bdee897bcae0859db7e69b62753220c17(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 10:
        rc =
            validate__Response__kl_core_HAL__53a7a3f2da521c9fb039f99235b09225ce086dfc(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 11:
        rc =
            validate__Response__kl_core_XHCIDBG__2272fbe6e81a1f47390f0ad8af6cbe4e165e98f6(decision,
                                                                                          src_eid,
                                                                                          src_sid,
                                                                                          dst_eid,
                                                                                          dst_sid,
                                                                                          message,
                                                                                          arena,
                                                                                          audit_message);
        break;
        
      case 12:
        rc =
            validate__Response__kl_core_Audit__d9d13127fa4d22d5ac2af8b6f76446c8e47b7c38(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 13:
        rc =
            validate__Response__kl_core_Profiler__b45d66a11240ec329a74bb5c8f9e429b46e4697d(decision,
                                                                                           src_eid,
                                                                                           src_sid,
                                                                                           dst_eid,
                                                                                           dst_sid,
                                                                                           message,
                                                                                           arena,
                                                                                           audit_message);
        break;
        
      case 14:
        rc =
            validate__Response__kl_core_IOMMU__ad5f2f3c366d39664c3a3187668a89791cc2c38d(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 15:
        rc =
            validate__Response__kl_core_CM__38ab137722ff64a3aa985d5f91cb0e5d6d84969b(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 16:
        rc =
            validate__Response__kl_core_PM__48da679642eedb433ccb22d6d59c4415f25e1ded(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 17:
        rc =
            validate__Response__kl_core_Notice__8793d13bf2dbbe33353755931bd69bfff59d4a9a(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 18:
        rc =
            validate__Response__kl_core_IPC__5e72ad72539079532a5573689ad771676b404d21(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 19:
        rc =
            validate__Response__kl_core_Log__beb8257a6deb2cea403088a96f1e5baaff70690e(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 20:
        rc =
            validate__Response__kl_core_Efi__48c53ee342548adb934b28633c3b7afd0e11028d(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      default:
        break;
    }
    return rc;
}
static nk_err_t validate__Error__2kl_core_Core__0Einit(kss_decision_t *decision,
                                                       kss_eid_t src_eid,
                                                       nk_sid_t src_sid,
                                                       kss_eid_t dst_eid,
                                                       nk_sid_t dst_sid, const
                                                       struct nk_message *message,
                                                       const
                                                       struct nk_arena *arena,
                                                       struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "iid: %d", message->iid);
    
    nk_err_t rc = NK_ENOENT;
    
    switch (message->iid) {
        
      case 0:
        rc =
            validate__Error__kl_core_VMM__a78ac7b765c242a895fe647c4df9b3fbb1e3e302(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      case 1:
        rc =
            validate__Error__kl_core_IO__823fc93e667833fc2cced245c3d148ff3d20c3a6(decision,
                                                                                  src_eid,
                                                                                  src_sid,
                                                                                  dst_eid,
                                                                                  dst_sid,
                                                                                  message,
                                                                                  arena,
                                                                                  audit_message);
        break;
        
      case 2:
        rc =
            validate__Error__kl_core_Thread__908ab87422c99c003e4d3c9ae36a9829f3dcf503(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 3:
        rc =
            validate__Error__kl_core_Handle__96653286716976cc757704f49aa76a2e90f39ad1(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 4:
        rc =
            validate__Error__kl_core_Task__e138f630c31ff6706136636848b4f54a30b9bb3a(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 5:
        rc =
            validate__Error__kl_core_TaskDebug__074f7853ddeff8af0ba67c543527a5201c51361e(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 6:
        rc =
            validate__Error__kl_core_Sync__162da361746c1842f44fcea945d10e6019428afe(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 7:
        rc =
            validate__Error__kl_core_FS__9e3d0d77274d67a9140570815843418a8e4080de(decision,
                                                                                  src_eid,
                                                                                  src_sid,
                                                                                  dst_eid,
                                                                                  dst_sid,
                                                                                  message,
                                                                                  arena,
                                                                                  audit_message);
        break;
        
      case 8:
        rc =
            validate__Error__kl_core_FSUnsafe__9254f858dce54194081d210f94ee5d44ef2610a4(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 9:
        rc =
            validate__Error__kl_core_Time__b03d2ee978febf96e918036eb2edf4f82dc04a93(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 10:
        rc =
            validate__Error__kl_core_HAL__7a9ae0ccf9803fb09220411101c508affc1de9c0(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      case 11:
        rc =
            validate__Error__kl_core_XHCIDBG__66fb525d8309c5ff603aef64b013768fe866d368(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 12:
        rc =
            validate__Error__kl_core_Audit__95d3ff5faaadd2d8a9386c51b93767aa8099be3d(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 13:
        rc =
            validate__Error__kl_core_Profiler__ee45805d647463c80c226e762f8e2e4cc2a299f7(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 14:
        rc =
            validate__Error__kl_core_IOMMU__0a00654332ff29362cf9dda0e998e099f24d3592(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 15:
        rc =
            validate__Error__kl_core_CM__27258f11c55ea0fd9851fb5f9fec795fd2864948(decision,
                                                                                  src_eid,
                                                                                  src_sid,
                                                                                  dst_eid,
                                                                                  dst_sid,
                                                                                  message,
                                                                                  arena,
                                                                                  audit_message);
        break;
        
      case 16:
        rc =
            validate__Error__kl_core_PM__929ece837b8a4cad967d61fd11b2a993aa452306(decision,
                                                                                  src_eid,
                                                                                  src_sid,
                                                                                  dst_eid,
                                                                                  dst_sid,
                                                                                  message,
                                                                                  arena,
                                                                                  audit_message);
        break;
        
      case 17:
        rc =
            validate__Error__kl_core_Notice__c06885b33dd04f2be6f95b13c5ed4bc5932fe7b6(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 18:
        rc =
            validate__Error__kl_core_IPC__ca5864d469b432ebf1b8f36bb9b6802130c41972(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      case 19:
        rc =
            validate__Error__kl_core_Log__76ebab3667966e8c0e43178c4ec33fa4a4cf15f0(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      case 20:
        rc =
            validate__Error__kl_core_Efi__15bc3f2dbc9a0058cff270f5476465a7356d5d1d(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      default:
        break;
    }
    return rc;
}
static nk_err_t validate__Error__2kl_core_Core__1Hello(kss_decision_t *decision,
                                                       kss_eid_t src_eid,
                                                       nk_sid_t src_sid,
                                                       kss_eid_t dst_eid,
                                                       nk_sid_t dst_sid, const
                                                       struct nk_message *message,
                                                       const
                                                       struct nk_arena *arena,
                                                       struct kss_audit_message *audit_message)
{
    PSL_TRACE(CLS_PSL, "PSL", "iid: %d", message->iid);
    
    nk_err_t rc = NK_ENOENT;
    
    switch (message->iid) {
        
      case 0:
        rc =
            validate__Error__kl_core_VMM__a78ac7b765c242a895fe647c4df9b3fbb1e3e302(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      case 1:
        rc =
            validate__Error__kl_core_IO__823fc93e667833fc2cced245c3d148ff3d20c3a6(decision,
                                                                                  src_eid,
                                                                                  src_sid,
                                                                                  dst_eid,
                                                                                  dst_sid,
                                                                                  message,
                                                                                  arena,
                                                                                  audit_message);
        break;
        
      case 2:
        rc =
            validate__Error__kl_core_Thread__908ab87422c99c003e4d3c9ae36a9829f3dcf503(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 3:
        rc =
            validate__Error__kl_core_Handle__96653286716976cc757704f49aa76a2e90f39ad1(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 4:
        rc =
            validate__Error__kl_core_Task__e138f630c31ff6706136636848b4f54a30b9bb3a(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 5:
        rc =
            validate__Error__kl_core_TaskDebug__074f7853ddeff8af0ba67c543527a5201c51361e(decision,
                                                                                         src_eid,
                                                                                         src_sid,
                                                                                         dst_eid,
                                                                                         dst_sid,
                                                                                         message,
                                                                                         arena,
                                                                                         audit_message);
        break;
        
      case 6:
        rc =
            validate__Error__kl_core_Sync__162da361746c1842f44fcea945d10e6019428afe(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 7:
        rc =
            validate__Error__kl_core_FS__9e3d0d77274d67a9140570815843418a8e4080de(decision,
                                                                                  src_eid,
                                                                                  src_sid,
                                                                                  dst_eid,
                                                                                  dst_sid,
                                                                                  message,
                                                                                  arena,
                                                                                  audit_message);
        break;
        
      case 8:
        rc =
            validate__Error__kl_core_FSUnsafe__9254f858dce54194081d210f94ee5d44ef2610a4(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 9:
        rc =
            validate__Error__kl_core_Time__b03d2ee978febf96e918036eb2edf4f82dc04a93(decision,
                                                                                    src_eid,
                                                                                    src_sid,
                                                                                    dst_eid,
                                                                                    dst_sid,
                                                                                    message,
                                                                                    arena,
                                                                                    audit_message);
        break;
        
      case 10:
        rc =
            validate__Error__kl_core_HAL__7a9ae0ccf9803fb09220411101c508affc1de9c0(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      case 11:
        rc =
            validate__Error__kl_core_XHCIDBG__66fb525d8309c5ff603aef64b013768fe866d368(decision,
                                                                                       src_eid,
                                                                                       src_sid,
                                                                                       dst_eid,
                                                                                       dst_sid,
                                                                                       message,
                                                                                       arena,
                                                                                       audit_message);
        break;
        
      case 12:
        rc =
            validate__Error__kl_core_Audit__95d3ff5faaadd2d8a9386c51b93767aa8099be3d(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 13:
        rc =
            validate__Error__kl_core_Profiler__ee45805d647463c80c226e762f8e2e4cc2a299f7(decision,
                                                                                        src_eid,
                                                                                        src_sid,
                                                                                        dst_eid,
                                                                                        dst_sid,
                                                                                        message,
                                                                                        arena,
                                                                                        audit_message);
        break;
        
      case 14:
        rc =
            validate__Error__kl_core_IOMMU__0a00654332ff29362cf9dda0e998e099f24d3592(decision,
                                                                                     src_eid,
                                                                                     src_sid,
                                                                                     dst_eid,
                                                                                     dst_sid,
                                                                                     message,
                                                                                     arena,
                                                                                     audit_message);
        break;
        
      case 15:
        rc =
            validate__Error__kl_core_CM__27258f11c55ea0fd9851fb5f9fec795fd2864948(decision,
                                                                                  src_eid,
                                                                                  src_sid,
                                                                                  dst_eid,
                                                                                  dst_sid,
                                                                                  message,
                                                                                  arena,
                                                                                  audit_message);
        break;
        
      case 16:
        rc =
            validate__Error__kl_core_PM__929ece837b8a4cad967d61fd11b2a993aa452306(decision,
                                                                                  src_eid,
                                                                                  src_sid,
                                                                                  dst_eid,
                                                                                  dst_sid,
                                                                                  message,
                                                                                  arena,
                                                                                  audit_message);
        break;
        
      case 17:
        rc =
            validate__Error__kl_core_Notice__c06885b33dd04f2be6f95b13c5ed4bc5932fe7b6(decision,
                                                                                      src_eid,
                                                                                      src_sid,
                                                                                      dst_eid,
                                                                                      dst_sid,
                                                                                      message,
                                                                                      arena,
                                                                                      audit_message);
        break;
        
      case 18:
        rc =
            validate__Error__kl_core_IPC__ca5864d469b432ebf1b8f36bb9b6802130c41972(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      case 19:
        rc =
            validate__Error__kl_core_Log__76ebab3667966e8c0e43178c4ec33fa4a4cf15f0(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      case 20:
        rc =
            validate__Error__kl_core_Efi__15bc3f2dbc9a0058cff270f5476465a7356d5d1d(decision,
                                                                                   src_eid,
                                                                                   src_sid,
                                                                                   dst_eid,
                                                                                   dst_sid,
                                                                                   message,
                                                                                   arena,
                                                                                   audit_message);
        break;
        
      default:
        break;
    }
    return rc;
}
nk_err_t __kss_error(kss_decision_t *decision, kss_eid_t src_eid,
                     nk_sid_t src_sid, kss_eid_t dst_eid, nk_sid_t dst_sid,
                     const struct nk_message *message, const
                     struct nk_arena *arena,
                     struct kss_audit_message *audit_message)
{
    nk_err_t rc = NK_ENOENT;
    
    PSL_TRACE(CLS_PSL, "PSL", "src: %d, dst: %d", src_eid, dst_eid);
    switch (src_eid) {
        
      case 2:
        switch (dst_eid) {
            
          case 0:
            rc = validate__Error__2kl_core_Core__0Einit(decision, src_eid,
                                                        src_sid, dst_eid,
                                                        dst_sid, message, arena,
                                                        audit_message);
            break;
            
          case 1:
            rc = validate__Error__2kl_core_Core__1Hello(decision, src_eid,
                                                        src_sid, dst_eid,
                                                        dst_sid, message, arena,
                                                        audit_message);
            break;
            
          case 2:
            rc = validate__Error__2kl_core_Core__2kl_core_Core(decision,
                                                               src_eid, src_sid,
                                                               dst_eid, dst_sid,
                                                               message, arena,
                                                               audit_message);
            break;
            
          default:
            break;
        }
        break;
        
      default:
        break;
    }
    log_rc(audit_message, rc);
    return rc;
}
nk_err_t __kss_request(kss_decision_t *decision, kss_eid_t src_eid,
                       nk_sid_t src_sid, kss_eid_t dst_eid, nk_sid_t dst_sid,
                       const struct nk_message *message, const
                       struct nk_arena *arena,
                       struct kss_audit_message *audit_message)
{
    nk_err_t rc = NK_ENOENT;
    
    PSL_TRACE(CLS_PSL, "PSL", "src: %d, dst: %d", src_eid, dst_eid);
    switch (src_eid) {
        
      case 0:
        switch (dst_eid) {
            
          case 2:
            rc = validate__Request__0Einit__2kl_core_Core(decision, src_eid,
                                                          src_sid, dst_eid,
                                                          dst_sid, message,
                                                          arena, audit_message);
            break;
            
          default:
            break;
        }
        break;
        
      case 1:
        switch (dst_eid) {
            
          case 2:
            rc = validate__Request__1Hello__2kl_core_Core(decision, src_eid,
                                                          src_sid, dst_eid,
                                                          dst_sid, message,
                                                          arena, audit_message);
            break;
            
          default:
            break;
        }
        break;
        
      case 2:
        switch (dst_eid) {
            
          case 2:
            rc = validate__Request__2kl_core_Core__2kl_core_Core(decision,
                                                                 src_eid,
                                                                 src_sid,
                                                                 dst_eid,
                                                                 dst_sid,
                                                                 message, arena,
                                                                 audit_message);
            break;
            
          default:
            break;
        }
        break;
        
      default:
        break;
    }
    log_rc(audit_message, rc);
    return rc;
}
nk_err_t __kss_response(kss_decision_t *decision, kss_eid_t src_eid,
                        nk_sid_t src_sid, kss_eid_t dst_eid, nk_sid_t dst_sid,
                        const struct nk_message *message, const
                        struct nk_arena *arena,
                        struct kss_audit_message *audit_message)
{
    nk_err_t rc = NK_ENOENT;
    
    PSL_TRACE(CLS_PSL, "PSL", "src: %d, dst: %d", src_eid, dst_eid);
    switch (src_eid) {
        
      case 2:
        switch (dst_eid) {
            
          case 0:
            rc = validate__Response__2kl_core_Core__0Einit(decision, src_eid,
                                                           src_sid, dst_eid,
                                                           dst_sid, message,
                                                           arena,
                                                           audit_message);
            break;
            
          case 1:
            rc = validate__Response__2kl_core_Core__1Hello(decision, src_eid,
                                                           src_sid, dst_eid,
                                                           dst_sid, message,
                                                           arena,
                                                           audit_message);
            break;
            
          case 2:
            rc = validate__Response__2kl_core_Core__2kl_core_Core(decision,
                                                                  src_eid,
                                                                  src_sid,
                                                                  dst_eid,
                                                                  dst_sid,
                                                                  message,
                                                                  arena,
                                                                  audit_message);
            break;
            
          default:
            break;
        }
        break;
        
      default:
        break;
    }
    log_rc(audit_message, rc);
    return rc;
}
const char *__kss_get_eiid(kss_eid_t eid)
{
    static const char *empty = "";
    
    PSL_TRACE(CLS_KSS, "KSS", "eid: %d", eid);
    if (eid < nk_array_size(eiids)) {
        PSL_TRACE(CLS_KSS, "KSS", "eid: %d -> eiid: %s", eid, eiids[eid]);
        return eiids[eid];
    } else {
        PSL_TRACE(CLS_ERROR, "KSS", "eid: %d -> OOB", eid);
        return empty;
    }
}
kss_eid_t __kss_get_eid(const char *eiid)
{
    const char **p;
    
    PSL_TRACE(CLS_KSS, "KSS", "eiid: %s", eiid);
    nk_assert(eiid != NK_NULL);
    p = (const char **) nk_bsearch(&eiid, eiids, nk_array_size(eiids),
                                   sizeof(eiids[0]), get_eid_cmp);
    if (p != NK_NULL) {
        PSL_TRACE(CLS_KSS, "KSS", "eiid: %s -> eid: %ld", eiid, p - eiids);
        return (kss_eid_t) (p - eiids);
    } else {
        PSL_TRACE(CLS_ERROR, "KSS", "eiid: %s -> not found", eiid);
        return KSS_INVALID_EID;
    }
}
nk_size_t __kss_get_num_slots(void)
{
    PSL_TRACE(CLS_KSS, "KSS", "slots: %d", 0);
    return 0;
}
nk_err_t __kss_unit_test(void)
{
    PSL_TRACE(CLS_TEST, "Test", "Unit tests were not generated.");
    return NK_EOK;
}
